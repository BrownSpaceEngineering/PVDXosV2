
PVDXos.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003544  00000000  00000000  00001000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000004  20000000  00003544  00005000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bkupram      00000000  47000000  47000000  00005004  2**0
                  CONTENTS
  3 .qspi         00000000  04000000  04000000  00005004  2**0
                  CONTENTS
  4 .bss          00020674  20000004  00003548  00005004  2**2
                  ALLOC
  5 .stack        00010000  20020678  00023bbc  00005004  2**0
                  ALLOC
  6 .ARM.attributes 0000002e  00000000  00000000  00005004  2**0
                  CONTENTS, READONLY
  7 .comment      00000044  00000000  00000000  00005032  2**0
                  CONTENTS, READONLY
  8 .debug_info   00029cda  00000000  00000000  00005076  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_abbrev 00005255  00000000  00000000  0002ed50  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_loclists 0000cc0d  00000000  00000000  00033fa5  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_aranges 00001378  00000000  00000000  00040bb2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_rnglists 00001a6e  00000000  00000000  00041f2a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_macro  00030da5  00000000  00000000  00043998  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line   0001f45d  00000000  00000000  0007473d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_str    0010cf7d  00000000  00000000  00093b9a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_frame  000034b4  00000000  00000000  001a0b18  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00000000 <exception_table>:
*  Return value
*    >= 0 - Number of bytes written.
*     < 0 - Error.
*
*/
int SEGGER_RTT_TerminalOut (unsigned char TerminalId, const char* s) {
       0:	78 06 03 20 81 28 00 00 7d 28 00 00 7d 28 00 00     x.. .(..}(..}(..
  int                   Status;
  unsigned              FragLen;
  unsigned              Avail;
  SEGGER_RTT_BUFFER_UP* pRing;
  //
  INIT();
      10:	7d 28 00 00 7d 28 00 00 7d 28 00 00 00 00 00 00     }(..}(..}(......
	...
    //
    FragLen = STRLEN(s);
    //
    // How we output depends upon the mode...
    //
    SEGGER_RTT_LOCK();
      2c:	61 0a 00 00 7d 28 00 00 00 00 00 00 f1 0a 00 00     a...}(..........
    Avail = _GetAvailWriteSpace(pRing);
      3c:	55 0b 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     U...}(..}(..}(..
    case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
      //
      // If we are in skip mode and there is no space for the whole
      // of this output, don't bother switching terminals at all.
      //
      if (Avail < (FragLen + 4u)) {
      4c:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
    case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
      //
      // If we are in blocking mode, output everything.
      //
      _PostTerminalSwitch(pRing, TerminalId);
      Status = (int)_WriteBlocking(pRing, s, FragLen);
      5c:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
        _PostTerminalSwitch(pRing, TerminalId);
      6c:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
        Status = (int)_WriteBlocking(pRing, s, (FragLen < (Avail - 4u)) ? FragLen : (Avail - 4u));
      7c:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
      break;
    }
    //
    // Finish up.
    //
    SEGGER_RTT_UNLOCK();
      8c:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
  } else {
    Status = -1;
      9c:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
  }
  return Status;
      ac:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
      bc:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
			break;
		case WDT_CLK_4096CYCLE *WDT_PERIOD_RATE:
			timeout_period_reg = WDT_PERIOD_4096CYCLE;
			break;
		case WDT_CLK_8192CYCLE *WDT_PERIOD_RATE:
			timeout_period_reg = WDT_PERIOD_8192CYCLE;
      cc:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue(pxQueue);
      dc:	7d 28 00 00 7d 28 00 00 7d 28 00 00 00 00 00 00     }(..}(..}(......
	...
      f4:	9d 1c 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     ....}(..}(..}(..

		/* Update the timeout state to see if it has expired yet. */
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
     104:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
#if (configUSE_MUTEXES == 1)
				{
					if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
						taskENTER_CRITICAL();
						{
							xInheritanceOccurred = xTaskPriorityInherit((void *)pxQueue->pxMutexHolder);
     114:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
						mtCOVERAGE_TEST_MARKER();
					}
				}
#endif

				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToReceive), xTicksToWait);
     124:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
				prvUnlockQueue(pxQueue);
				if (xTaskResumeAll() == pdFALSE) {
					portYIELD_WITHIN_API();
     134:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
     144:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
				(void)xTaskResumeAll();
			}
		} else {
			/* Timed out. */
			prvUnlockQueue(pxQueue);
			(void)xTaskResumeAll();
     154:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if (xInheritanceOccurred != pdFALSE) {
						taskENTER_CRITICAL();
     164:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout(pxQueue);
							vTaskPriorityDisinheritAfterTimeout((void *)pxQueue->pxMutexHolder,
     174:	7d 28 00 00 00 00 00 00 00 00 00 00 7d 28 00 00     }(..........}(..
							                                    uxHighestWaitingPriority);
						}
						taskEXIT_CRITICAL();
     184:	7d 28 00 00 7d 28 00 00 7d 28 00 00 00 00 00 00     }(..}(..}(......
     194:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
     1a4:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
     1b4:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
     1c4:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
     1d4:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
     1e4:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
     1f4:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
     204:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
     214:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
     224:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
     234:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
     244:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..
     254:	7d 28 00 00 7d 28 00 00 7d 28 00 00 7d 28 00 00     }(..}(..}(..}(..

00000264 <deregister_tm_clones>:
     264:	4803      	ldr	r0, [pc, #12]	@ (274 <deregister_tm_clones+0x10>)
     266:	4b04      	ldr	r3, [pc, #16]	@ (278 <deregister_tm_clones+0x14>)
     268:	4283      	cmp	r3, r0
     26a:	d002      	beq.n	272 <deregister_tm_clones+0xe>
     26c:	4b03      	ldr	r3, [pc, #12]	@ (27c <deregister_tm_clones+0x18>)
     26e:	b103      	cbz	r3, 272 <deregister_tm_clones+0xe>
     270:	4718      	bx	r3
     272:	4770      	bx	lr
     274:	00003544 	.word	0x00003544
     278:	00003544 	.word	0x00003544
     27c:	00000000 	.word	0x00000000

00000280 <register_tm_clones>:
     280:	4805      	ldr	r0, [pc, #20]	@ (298 <register_tm_clones+0x18>)
     282:	4b06      	ldr	r3, [pc, #24]	@ (29c <register_tm_clones+0x1c>)
     284:	1a1b      	subs	r3, r3, r0
     286:	0fd9      	lsrs	r1, r3, #31
     288:	eb01 01a3 	add.w	r1, r1, r3, asr #2
     28c:	1049      	asrs	r1, r1, #1
     28e:	d002      	beq.n	296 <register_tm_clones+0x16>
     290:	4b03      	ldr	r3, [pc, #12]	@ (2a0 <register_tm_clones+0x20>)
     292:	b103      	cbz	r3, 296 <register_tm_clones+0x16>
     294:	4718      	bx	r3
     296:	4770      	bx	lr
     298:	00003544 	.word	0x00003544
     29c:	00003544 	.word	0x00003544
     2a0:	00000000 	.word	0x00000000

000002a4 <__do_global_dtors_aux>:
     2a4:	b510      	push	{r4, lr}
     2a6:	4c06      	ldr	r4, [pc, #24]	@ (2c0 <__do_global_dtors_aux+0x1c>)
     2a8:	7823      	ldrb	r3, [r4, #0]
     2aa:	b943      	cbnz	r3, 2be <__do_global_dtors_aux+0x1a>
     2ac:	f7ff ffda 	bl	264 <deregister_tm_clones>
     2b0:	4b04      	ldr	r3, [pc, #16]	@ (2c4 <__do_global_dtors_aux+0x20>)
     2b2:	b113      	cbz	r3, 2ba <__do_global_dtors_aux+0x16>
     2b4:	4804      	ldr	r0, [pc, #16]	@ (2c8 <__do_global_dtors_aux+0x24>)
     2b6:	f3af 8000 	nop.w
     2ba:	2301      	movs	r3, #1
     2bc:	7023      	strb	r3, [r4, #0]
     2be:	bd10      	pop	{r4, pc}
     2c0:	20000004 	.word	0x20000004
     2c4:	00000000 	.word	0x00000000
     2c8:	00003544 	.word	0x00003544

000002cc <frame_dummy>:
     2cc:	b508      	push	{r3, lr}
     2ce:	4b05      	ldr	r3, [pc, #20]	@ (2e4 <frame_dummy+0x18>)
     2d0:	b11b      	cbz	r3, 2da <frame_dummy+0xe>
     2d2:	4905      	ldr	r1, [pc, #20]	@ (2e8 <frame_dummy+0x1c>)
     2d4:	4805      	ldr	r0, [pc, #20]	@ (2ec <frame_dummy+0x20>)
     2d6:	f3af 8000 	nop.w
     2da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     2de:	f7ff bfcf 	b.w	280 <register_tm_clones>
     2e2:	bf00      	nop
     2e4:	00000000 	.word	0x00000000
     2e8:	20000008 	.word	0x20000008
     2ec:	00003544 	.word	0x00003544

000002f0 <main>:
#include "globals.h"

int main(void)
{
     2f0:	b573      	push	{r0, r1, r4, r5, r6, lr}
            /* Initializes MCU, drivers and middleware */
            atmel_start_init();
     2f2:	4b0e      	ldr	r3, [pc, #56]	@ (32c <main+0x3c>)
            printf("ATMEL Initialization Complete!\n");
     2f4:	4c0e      	ldr	r4, [pc, #56]	@ (330 <main+0x40>)

            // Create Heartbeat Task
            // xTaskCreate(main_func, "Task Name", Stack Size, Parameters, Priority, Task Handle);
            BaseType_t heartbeatCreateStatus = xTaskCreate(heartbeat_main, "Heartbeat", 1000, NULL, 1, NULL);
     2f6:	4e0f      	ldr	r6, [pc, #60]	@ (334 <main+0x44>)
            atmel_start_init();
     2f8:	4798      	blx	r3
            printf("ATMEL Initialization Complete!\n");
     2fa:	490f      	ldr	r1, [pc, #60]	@ (338 <main+0x48>)
     2fc:	2000      	movs	r0, #0
     2fe:	47a0      	blx	r4
            BaseType_t heartbeatCreateStatus = xTaskCreate(heartbeat_main, "Heartbeat", 1000, NULL, 1, NULL);
     300:	2500      	movs	r5, #0
     302:	2301      	movs	r3, #1
     304:	490d      	ldr	r1, [pc, #52]	@ (33c <main+0x4c>)
     306:	480e      	ldr	r0, [pc, #56]	@ (340 <main+0x50>)
     308:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
     30c:	e9cd 3500 	strd	r3, r5, [sp]
     310:	462b      	mov	r3, r5
     312:	47b0      	blx	r6
            if (heartbeatCreateStatus != pdPASS) {
     314:	2801      	cmp	r0, #1
                printf("Heartbeat Task Creation Failed!\n");
     316:	bf14      	ite	ne
     318:	490a      	ldrne	r1, [pc, #40]	@ (344 <main+0x54>)
            } else {
                printf("Heartbeat Task Created!\n");
     31a:	490b      	ldreq	r1, [pc, #44]	@ (348 <main+0x58>)
     31c:	4628      	mov	r0, r5
     31e:	47a0      	blx	r4
            }

            // Start the scheduler
            vTaskStartScheduler();
     320:	4b0a      	ldr	r3, [pc, #40]	@ (34c <main+0x5c>)
     322:	4798      	blx	r3

            printf("Work completed -- Looping forever\n");
     324:	490a      	ldr	r1, [pc, #40]	@ (350 <main+0x60>)
     326:	2000      	movs	r0, #0
     328:	47a0      	blx	r4
            while (1) {
     32a:	e7fe      	b.n	32a <main+0x3a>
     32c:	00002911 	.word	0x00002911
     330:	00000909 	.word	0x00000909
     334:	000029c9 	.word	0x000029c9
     338:	000032e8 	.word	0x000032e8
     33c:	00003308 	.word	0x00003308
     340:	00000355 	.word	0x00000355
     344:	00003312 	.word	0x00003312
     348:	00003333 	.word	0x00003333
     34c:	00002b61 	.word	0x00002b61
     350:	0000334c 	.word	0x0000334c

00000354 <heartbeat_main>:
#include "heartbeat_task.h"
#include "SEGGER_RTT_printf.h"

void heartbeat_main(void *pvParameters) {
     354:	b580      	push	{r7, lr}
    printf("Heartbeat Task Started!\n");
     356:	4913      	ldr	r1, [pc, #76]	@ (3a4 <heartbeat_main+0x50>)
     358:	4b13      	ldr	r3, [pc, #76]	@ (3a8 <heartbeat_main+0x54>)
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = ~data;
}

static inline void hri_port_clear_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     35a:	4d14      	ldr	r5, [pc, #80]	@ (3ac <heartbeat_main+0x58>)
     35c:	2000      	movs	r0, #0
     35e:	4798      	blx	r3
     360:	f04f 4880 	mov.w	r8, #1073741824	@ 0x40000000
    while(1) {
        gpio_set_pin_level(LED_Orange1, false);
        vTaskDelay(pdMS_TO_TICKS(100));
     364:	4c12      	ldr	r4, [pc, #72]	@ (3b0 <heartbeat_main+0x5c>)
     366:	f8c5 8114 	str.w	r8, [r5, #276]	@ 0x114
     36a:	f04f 4700 	mov.w	r7, #2147483648	@ 0x80000000
     36e:	2064      	movs	r0, #100	@ 0x64
     370:	47a0      	blx	r4
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     372:	2602      	movs	r6, #2
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     374:	f8c5 7114 	str.w	r7, [r5, #276]	@ 0x114
        gpio_set_pin_level(LED_Orange2, false);
        vTaskDelay(pdMS_TO_TICKS(100));
     378:	2064      	movs	r0, #100	@ 0x64
     37a:	47a0      	blx	r4
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     37c:	f8c5 6098 	str.w	r6, [r5, #152]	@ 0x98
        gpio_set_pin_level(LED_Red, true);
        vTaskDelay(pdMS_TO_TICKS(400));
     380:	f44f 70c8 	mov.w	r0, #400	@ 0x190
     384:	47a0      	blx	r4
     386:	f8c5 8118 	str.w	r8, [r5, #280]	@ 0x118
        gpio_set_pin_level(LED_Orange1, true);
        vTaskDelay(pdMS_TO_TICKS(33));
     38a:	2021      	movs	r0, #33	@ 0x21
     38c:	47a0      	blx	r4
     38e:	f8c5 7118 	str.w	r7, [r5, #280]	@ 0x118
        gpio_set_pin_level(LED_Orange2, true);
        vTaskDelay(pdMS_TO_TICKS(33));
     392:	2021      	movs	r0, #33	@ 0x21
     394:	47a0      	blx	r4
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     396:	f8c5 6094 	str.w	r6, [r5, #148]	@ 0x94
        gpio_set_pin_level(LED_Red, false);
        vTaskDelay(pdMS_TO_TICKS(300));
     39a:	f44f 7096 	mov.w	r0, #300	@ 0x12c
     39e:	47a0      	blx	r4
    while(1) {
     3a0:	e7e0      	b.n	364 <heartbeat_main+0x10>
     3a2:	bf00      	nop
     3a4:	0000336f 	.word	0x0000336f
     3a8:	00000909 	.word	0x00000909
     3ac:	41008000 	.word	0x41008000
     3b0:	00002ded 	.word	0x00002ded

000003b4 <_GetAvailWriteSpace>:
  RdOff = pRing->RdOff;
     3b4:	6903      	ldr	r3, [r0, #16]
  WrOff = pRing->WrOff;
     3b6:	68c2      	ldr	r2, [r0, #12]
  if (RdOff <= WrOff) {
     3b8:	4293      	cmp	r3, r2
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
     3ba:	bf9c      	itt	ls
     3bc:	6881      	ldrls	r1, [r0, #8]
     3be:	185b      	addls	r3, r3, r1
    r = RdOff - WrOff - 1u;
     3c0:	3b01      	subs	r3, #1
     3c2:	1a98      	subs	r0, r3, r2
}
     3c4:	4770      	bx	lr
	...

000003c8 <_WriteNoCheck>:
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
     3c8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  Rem = pRing->SizeOfBuffer - WrOff;
     3cc:	e9d0 8402 	ldrd	r8, r4, [r0, #8]
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
     3d0:	4605      	mov	r5, r0
  Rem = pRing->SizeOfBuffer - WrOff;
     3d2:	eba8 0604 	sub.w	r6, r8, r4
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
     3d6:	6840      	ldr	r0, [r0, #4]
     3d8:	f8df 9028 	ldr.w	r9, [pc, #40]	@ 404 <_WriteNoCheck+0x3c>
  if (Rem > NumBytes) {
     3dc:	4296      	cmp	r6, r2
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
     3de:	4420      	add	r0, r4
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
     3e0:	460f      	mov	r7, r1
    pRing->WrOff = WrOff + NumBytes;
     3e2:	4414      	add	r4, r2
  if (Rem > NumBytes) {
     3e4:	d905      	bls.n	3f2 <_WriteNoCheck+0x2a>
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
     3e6:	47c8      	blx	r9
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
     3e8:	f3bf 8f5f 	dmb	sy
    pRing->WrOff = WrOff + NumBytes;
     3ec:	60ec      	str	r4, [r5, #12]
}
     3ee:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
     3f2:	4632      	mov	r2, r6
    NumBytesAtOnce = NumBytes - Rem;
     3f4:	eba4 0408 	sub.w	r4, r4, r8
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
     3f8:	47c8      	blx	r9
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
     3fa:	6868      	ldr	r0, [r5, #4]
     3fc:	4622      	mov	r2, r4
     3fe:	19b9      	adds	r1, r7, r6
     400:	e7f1      	b.n	3e6 <_WriteNoCheck+0x1e>
     402:	bf00      	nop
     404:	000032cd 	.word	0x000032cd

00000408 <_WriteBlocking>:
static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
     408:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  WrOff = pRing->WrOff;
     40c:	68c5      	ldr	r5, [r0, #12]
    SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
     40e:	f8df 9054 	ldr.w	r9, [pc, #84]	@ 464 <_WriteBlocking+0x5c>
static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
     412:	4606      	mov	r6, r0
     414:	468a      	mov	sl, r1
     416:	4617      	mov	r7, r2
  NumBytesWritten = 0u;
     418:	f04f 0800 	mov.w	r8, #0
    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
     41c:	6933      	ldr	r3, [r6, #16]
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
     41e:	68b4      	ldr	r4, [r6, #8]
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
     420:	6870      	ldr	r0, [r6, #4]
    if (RdOff > WrOff) {
     422:	429d      	cmp	r5, r3
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
     424:	bf28      	it	cs
     426:	191b      	addcs	r3, r3, r4
    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
     428:	1b64      	subs	r4, r4, r5
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
     42a:	42bc      	cmp	r4, r7
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
     42c:	f103 33ff 	add.w	r3, r3, #4294967295	@ 0xffffffff
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
     430:	bf28      	it	cs
     432:	463c      	movcs	r4, r7
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
     434:	1b5b      	subs	r3, r3, r5
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
     436:	429c      	cmp	r4, r3
     438:	bf28      	it	cs
     43a:	461c      	movcs	r4, r3
    SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
     43c:	4651      	mov	r1, sl
     43e:	4622      	mov	r2, r4
     440:	4428      	add	r0, r5
     442:	47c8      	blx	r9
    if (WrOff == pRing->SizeOfBuffer) {
     444:	68b3      	ldr	r3, [r6, #8]
    WrOff           += NumBytesToWrite;
     446:	4425      	add	r5, r4
    NumBytesWritten += NumBytesToWrite;
     448:	44a0      	add	r8, r4
    pBuffer         += NumBytesToWrite;
     44a:	44a2      	add	sl, r4
    NumBytes        -= NumBytesToWrite;
     44c:	1b3f      	subs	r7, r7, r4
      WrOff = 0u;
     44e:	42ab      	cmp	r3, r5
     450:	bf08      	it	eq
     452:	2500      	moveq	r5, #0
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
     454:	f3bf 8f5f 	dmb	sy
    pRing->WrOff = WrOff;
     458:	60f5      	str	r5, [r6, #12]
  } while (NumBytes);
     45a:	2f00      	cmp	r7, #0
     45c:	d1de      	bne.n	41c <_WriteBlocking+0x14>
}
     45e:	4640      	mov	r0, r8
     460:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     464:	000032cd 	.word	0x000032cd

00000468 <_DoInit>:
  memset((SEGGER_RTT_CB*)p, 0, sizeof(_SEGGER_RTT));         // Make sure that the RTT CB is always zero initialized.
     468:	4b15      	ldr	r3, [pc, #84]	@ (4c0 <_DoInit+0x58>)
static void _DoInit(void) {
     46a:	b510      	push	{r4, lr}
  memset((SEGGER_RTT_CB*)p, 0, sizeof(_SEGGER_RTT));         // Make sure that the RTT CB is always zero initialized.
     46c:	22a8      	movs	r2, #168	@ 0xa8
     46e:	4c15      	ldr	r4, [pc, #84]	@ (4c4 <_DoInit+0x5c>)
     470:	2100      	movs	r1, #0
     472:	4618      	mov	r0, r3
     474:	47a0      	blx	r4
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
     476:	2203      	movs	r2, #3
     478:	6102      	str	r2, [r0, #16]
  p->aUp[0].sName         = "Terminal";
     47a:	4913      	ldr	r1, [pc, #76]	@ (4c8 <_DoInit+0x60>)
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
     47c:	6142      	str	r2, [r0, #20]
  p->aUp[0].pBuffer       = _acUpBuffer;
     47e:	f100 02a8 	add.w	r2, r0, #168	@ 0xa8
  p->aUp[0].sName         = "Terminal";
     482:	6181      	str	r1, [r0, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
     484:	61c2      	str	r2, [r0, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
     486:	f44f 6280 	mov.w	r2, #1024	@ 0x400
     48a:	6202      	str	r2, [r0, #32]
  p->aUp[0].RdOff         = 0u;
     48c:	2200      	movs	r2, #0
     48e:	6282      	str	r2, [r0, #40]	@ 0x28
  p->aUp[0].WrOff         = 0u;
     490:	6242      	str	r2, [r0, #36]	@ 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
     492:	62c2      	str	r2, [r0, #44]	@ 0x2c
  p->aDown[0].sName         = "Terminal";
     494:	6601      	str	r1, [r0, #96]	@ 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
     496:	f500 6195 	add.w	r1, r0, #1192	@ 0x4a8
     49a:	6641      	str	r1, [r0, #100]	@ 0x64
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
     49c:	2110      	movs	r1, #16
     49e:	6681      	str	r1, [r0, #104]	@ 0x68
  memset((SEGGER_RTT_CB*)p, 0, sizeof(_SEGGER_RTT));         // Make sure that the RTT CB is always zero initialized.
     4a0:	4603      	mov	r3, r0
  p->aDown[0].RdOff         = 0u;
     4a2:	6702      	str	r2, [r0, #112]	@ 0x70
  p->aDown[0].WrOff         = 0u;
     4a4:	66c2      	str	r2, [r0, #108]	@ 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
     4a6:	6742      	str	r2, [r0, #116]	@ 0x74
  RTT__DMB();                       // Force order of memory accesses for cores that may perform out-of-order memory accesses
     4a8:	f3bf 8f5f 	dmb	sy
  for (i = 0; i < sizeof(_aInitStr) - 1; ++i) {
     4ac:	4907      	ldr	r1, [pc, #28]	@ (4cc <_DoInit+0x64>)
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
     4ae:	f811 0d01 	ldrb.w	r0, [r1, #-1]!
     4b2:	5498      	strb	r0, [r3, r2]
  for (i = 0; i < sizeof(_aInitStr) - 1; ++i) {
     4b4:	3201      	adds	r2, #1
     4b6:	2a10      	cmp	r2, #16
     4b8:	d1f9      	bne.n	4ae <_DoInit+0x46>
  RTT__DMB();                       // Force order of memory accesses for cores that may perform out-of-order memory accesses
     4ba:	f3bf 8f5f 	dmb	sy
}
     4be:	bd10      	pop	{r4, pc}
     4c0:	20000020 	.word	0x20000020
     4c4:	00003275 	.word	0x00003275
     4c8:	00003388 	.word	0x00003388
     4cc:	00003489 	.word	0x00003489

000004d0 <SEGGER_RTT_WriteNoLock>:
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
     4d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
     4d4:	4b14      	ldr	r3, [pc, #80]	@ (528 <SEGGER_RTT_WriteNoLock+0x58>)
     4d6:	2718      	movs	r7, #24
     4d8:	fb00 7507 	mla	r5, r0, r7, r7
     4dc:	441d      	add	r5, r3
  switch (pRing->Flags) {
     4de:	fb07 3300 	mla	r3, r7, r0, r3
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
     4e2:	460e      	mov	r6, r1
  switch (pRing->Flags) {
     4e4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     4e6:	2b01      	cmp	r3, #1
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
     4e8:	4614      	mov	r4, r2
  switch (pRing->Flags) {
     4ea:	d00b      	beq.n	504 <SEGGER_RTT_WriteNoLock+0x34>
     4ec:	2b02      	cmp	r3, #2
     4ee:	d015      	beq.n	51c <SEGGER_RTT_WriteNoLock+0x4c>
     4f0:	b923      	cbnz	r3, 4fc <SEGGER_RTT_WriteNoLock+0x2c>
    Avail = _GetAvailWriteSpace(pRing);
     4f2:	4b0e      	ldr	r3, [pc, #56]	@ (52c <SEGGER_RTT_WriteNoLock+0x5c>)
     4f4:	4628      	mov	r0, r5
     4f6:	4798      	blx	r3
    if (Avail < NumBytes) {
     4f8:	4284      	cmp	r4, r0
     4fa:	d909      	bls.n	510 <SEGGER_RTT_WriteNoLock+0x40>
    Status = 0u;
     4fc:	2400      	movs	r4, #0
}
     4fe:	4620      	mov	r0, r4
     500:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    Avail = _GetAvailWriteSpace(pRing);
     504:	4b09      	ldr	r3, [pc, #36]	@ (52c <SEGGER_RTT_WriteNoLock+0x5c>)
     506:	4628      	mov	r0, r5
     508:	4798      	blx	r3
    Status = Avail < NumBytes ? Avail : NumBytes;
     50a:	4284      	cmp	r4, r0
     50c:	bf28      	it	cs
     50e:	4604      	movcs	r4, r0
    _WriteNoCheck(pRing, pData, Status);
     510:	4b07      	ldr	r3, [pc, #28]	@ (530 <SEGGER_RTT_WriteNoLock+0x60>)
     512:	4622      	mov	r2, r4
     514:	4631      	mov	r1, r6
     516:	4628      	mov	r0, r5
     518:	4798      	blx	r3
    break;
     51a:	e7f0      	b.n	4fe <SEGGER_RTT_WriteNoLock+0x2e>
    Status = _WriteBlocking(pRing, pData, NumBytes);
     51c:	4628      	mov	r0, r5
     51e:	4b05      	ldr	r3, [pc, #20]	@ (534 <SEGGER_RTT_WriteNoLock+0x64>)
}
     520:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    Status = _WriteBlocking(pRing, pData, NumBytes);
     524:	4718      	bx	r3
     526:	bf00      	nop
     528:	20000020 	.word	0x20000020
     52c:	000003b5 	.word	0x000003b5
     530:	000003c9 	.word	0x000003c9
     534:	00000409 	.word	0x00000409

00000538 <SEGGER_RTT_Write>:
unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
     538:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  INIT();
     53a:	4b0b      	ldr	r3, [pc, #44]	@ (568 <SEGGER_RTT_Write+0x30>)
     53c:	781b      	ldrb	r3, [r3, #0]
     53e:	2b53      	cmp	r3, #83	@ 0x53
unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
     540:	4604      	mov	r4, r0
     542:	460d      	mov	r5, r1
     544:	4616      	mov	r6, r2
  INIT();
     546:	d001      	beq.n	54c <SEGGER_RTT_Write+0x14>
     548:	4b08      	ldr	r3, [pc, #32]	@ (56c <SEGGER_RTT_Write+0x34>)
     54a:	4798      	blx	r3
  SEGGER_RTT_LOCK();
     54c:	f3ef 8711 	mrs	r7, BASEPRI
     550:	f04f 0120 	mov.w	r1, #32
     554:	f381 8811 	msr	BASEPRI, r1
  Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);  // Call the non-locking write function
     558:	4b05      	ldr	r3, [pc, #20]	@ (570 <SEGGER_RTT_Write+0x38>)
     55a:	4632      	mov	r2, r6
     55c:	4629      	mov	r1, r5
     55e:	4620      	mov	r0, r4
     560:	4798      	blx	r3
  SEGGER_RTT_UNLOCK();
     562:	f387 8811 	msr	BASEPRI, r7
}
     566:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     568:	20000020 	.word	0x20000020
     56c:	00000469 	.word	0x00000469
     570:	000004d1 	.word	0x000004d1

00000574 <_StoreChar>:
*       _StoreChar
*/
static void _StoreChar(SEGGER_RTT_PRINTF_DESC * p, char c) {
  unsigned Cnt;

  Cnt = p->Cnt;
     574:	6882      	ldr	r2, [r0, #8]
static void _StoreChar(SEGGER_RTT_PRINTF_DESC * p, char c) {
     576:	b510      	push	{r4, lr}
     578:	4604      	mov	r4, r0
  if ((Cnt + 1u) <= p->BufferSize) {
     57a:	6840      	ldr	r0, [r0, #4]
     57c:	1c53      	adds	r3, r2, #1
     57e:	4283      	cmp	r3, r0
     580:	d805      	bhi.n	58e <_StoreChar+0x1a>
    *(p->pBuffer + Cnt) = c;
     582:	6820      	ldr	r0, [r4, #0]
     584:	5481      	strb	r1, [r0, r2]
    p->Cnt = Cnt + 1u;
     586:	60a3      	str	r3, [r4, #8]
    p->ReturnValue++;
     588:	68e3      	ldr	r3, [r4, #12]
     58a:	3301      	adds	r3, #1
     58c:	60e3      	str	r3, [r4, #12]
  }
  //
  // Write part of string, when the buffer is full
  //
  if (p->Cnt == p->BufferSize) {
     58e:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
     592:	429a      	cmp	r2, r3
     594:	d10b      	bne.n	5ae <_StoreChar+0x3a>
    if (SEGGER_RTT_Write(p->RTTBufferIndex, p->pBuffer, p->Cnt) != p->Cnt) {
     596:	4b06      	ldr	r3, [pc, #24]	@ (5b0 <_StoreChar+0x3c>)
     598:	6821      	ldr	r1, [r4, #0]
     59a:	6920      	ldr	r0, [r4, #16]
     59c:	4798      	blx	r3
     59e:	68a3      	ldr	r3, [r4, #8]
     5a0:	4298      	cmp	r0, r3
      p->ReturnValue = -1;
     5a2:	bf15      	itete	ne
     5a4:	f04f 33ff 	movne.w	r3, #4294967295	@ 0xffffffff
    } else {
      p->Cnt = 0u;
     5a8:	2300      	moveq	r3, #0
      p->ReturnValue = -1;
     5aa:	60e3      	strne	r3, [r4, #12]
      p->Cnt = 0u;
     5ac:	60a3      	streq	r3, [r4, #8]
    }
  }
}
     5ae:	bd10      	pop	{r4, pc}
     5b0:	00000539 	.word	0x00000539

000005b4 <_PrintUnsigned>:

/*********************************************************************
*
*       _PrintUnsigned
*/
static void _PrintUnsigned(SEGGER_RTT_PRINTF_DESC * pBufferDesc, unsigned v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
     5b4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
     5b8:	4699      	mov	r9, r3
     5ba:	e9dd 430a 	ldrd	r4, r3, [sp, #40]	@ 0x28
     5be:	4616      	mov	r6, r2
     5c0:	4605      	mov	r5, r0
     5c2:	4688      	mov	r8, r1
  unsigned Digit;
  unsigned Number;
  unsigned Width;
  char c;

  Number = v;
     5c4:	460a      	mov	r2, r1
  Digit = 1u;
  //
  // Get actual field width
  //
  Width = 1u;
     5c6:	f04f 0a01 	mov.w	sl, #1
  while (Number >= Base) {
     5ca:	42b2      	cmp	r2, r6
     5cc:	d212      	bcs.n	5f4 <_PrintUnsigned+0x40>
    Number = (Number / Base);
    Width++;
  }
  if (NumDigits > Width) {
     5ce:	45ca      	cmp	sl, r9
     5d0:	bf38      	it	cc
     5d2:	46ca      	movcc	sl, r9
    Width = NumDigits;
  }
  //
  // Print leading chars if necessary
  //
  if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) {
     5d4:	f013 0b01 	ands.w	fp, r3, #1
     5d8:	d101      	bne.n	5de <_PrintUnsigned+0x2a>
    if (FieldWidth != 0u) {
     5da:	b984      	cbnz	r4, 5fe <_PrintUnsigned+0x4a>
      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && (NumDigits == 0u)) {
        c = '0';
      } else {
        c = ' ';
     5dc:	2400      	movs	r4, #0
          break;
        }
      }
    }
  }
  if (pBufferDesc->ReturnValue >= 0) {
     5de:	68eb      	ldr	r3, [r5, #12]
     5e0:	2b00      	cmp	r3, #0
     5e2:	db3f      	blt.n	664 <_PrintUnsigned+0xb0>
  Digit = 1u;
     5e4:	2701      	movs	r7, #1
    // Compute Digit.
    // Loop until Digit has the value of the highest digit required.
    // Example: If the output is 345 (Base 10), loop 2 times until Digit is 100.
    //
    while (1) {
      if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
     5e6:	f1b9 0f01 	cmp.w	r9, #1
     5ea:	d920      	bls.n	62e <_PrintUnsigned+0x7a>
        NumDigits--;
     5ec:	f109 39ff 	add.w	r9, r9, #4294967295	@ 0xffffffff
        Div = v / Digit;
        if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
          break;
        }
      }
      Digit *= Base;
     5f0:	4377      	muls	r7, r6
      if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
     5f2:	e7f8      	b.n	5e6 <_PrintUnsigned+0x32>
    Width++;
     5f4:	f10a 0a01 	add.w	sl, sl, #1
    Number = (Number / Base);
     5f8:	fbb2 f2f6 	udiv	r2, r2, r6
    Width++;
     5fc:	e7e5      	b.n	5ca <_PrintUnsigned+0x16>
      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && (NumDigits == 0u)) {
     5fe:	079b      	lsls	r3, r3, #30
     600:	d513      	bpl.n	62a <_PrintUnsigned+0x76>
        c = ' ';
     602:	f1b9 0f00 	cmp.w	r9, #0
     606:	bf0c      	ite	eq
     608:	2730      	moveq	r7, #48	@ 0x30
     60a:	2720      	movne	r7, #32
        _StoreChar(pBufferDesc, c);
     60c:	4a1d      	ldr	r2, [pc, #116]	@ (684 <_PrintUnsigned+0xd0>)
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
     60e:	45a2      	cmp	sl, r4
     610:	d2e5      	bcs.n	5de <_PrintUnsigned+0x2a>
        _StoreChar(pBufferDesc, c);
     612:	4639      	mov	r1, r7
     614:	4628      	mov	r0, r5
     616:	4790      	blx	r2
        if (pBufferDesc->ReturnValue < 0) {
     618:	68eb      	ldr	r3, [r5, #12]
     61a:	4a1a      	ldr	r2, [pc, #104]	@ (684 <_PrintUnsigned+0xd0>)
     61c:	2b00      	cmp	r3, #0
        FieldWidth--;
     61e:	f104 34ff 	add.w	r4, r4, #4294967295	@ 0xffffffff
        if (pBufferDesc->ReturnValue < 0) {
     622:	dbdc      	blt.n	5de <_PrintUnsigned+0x2a>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
     624:	2c00      	cmp	r4, #0
     626:	d1f2      	bne.n	60e <_PrintUnsigned+0x5a>
     628:	e7d8      	b.n	5dc <_PrintUnsigned+0x28>
        c = ' ';
     62a:	2720      	movs	r7, #32
     62c:	e7ee      	b.n	60c <_PrintUnsigned+0x58>
        Div = v / Digit;
     62e:	fbb8 f3f7 	udiv	r3, r8, r7
        if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
     632:	429e      	cmp	r6, r3
     634:	d9dc      	bls.n	5f0 <_PrintUnsigned+0x3c>
    // Output digits
    //
    do {
      Div = v / Digit;
      v -= Div * Digit;
      _StoreChar(pBufferDesc, _aV2C[Div]);
     636:	4b13      	ldr	r3, [pc, #76]	@ (684 <_PrintUnsigned+0xd0>)
     638:	4a13      	ldr	r2, [pc, #76]	@ (688 <_PrintUnsigned+0xd4>)
     63a:	4699      	mov	r9, r3
      Div = v / Digit;
     63c:	fbb8 f1f7 	udiv	r1, r8, r7
      _StoreChar(pBufferDesc, _aV2C[Div]);
     640:	4628      	mov	r0, r5
     642:	fb07 8811 	mls	r8, r7, r1, r8
     646:	5c51      	ldrb	r1, [r2, r1]
     648:	4798      	blx	r3
      if (pBufferDesc->ReturnValue < 0) {
     64a:	68e9      	ldr	r1, [r5, #12]
     64c:	2900      	cmp	r1, #0
     64e:	db05      	blt.n	65c <_PrintUnsigned+0xa8>
        break;
      }
      Digit /= Base;
     650:	fbb7 f1f6 	udiv	r1, r7, r6
    } while (Digit);
     654:	42b7      	cmp	r7, r6
     656:	4b0b      	ldr	r3, [pc, #44]	@ (684 <_PrintUnsigned+0xd0>)
     658:	4a0b      	ldr	r2, [pc, #44]	@ (688 <_PrintUnsigned+0xd4>)
     65a:	d205      	bcs.n	668 <_PrintUnsigned+0xb4>
    //
    // Print trailing spaces if necessary
    //
    if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == FORMAT_FLAG_LEFT_JUSTIFY) {
     65c:	f1bb 0f00 	cmp.w	fp, #0
     660:	d000      	beq.n	664 <_PrintUnsigned+0xb0>
      if (FieldWidth != 0u) {
     662:	b95c      	cbnz	r4, 67c <_PrintUnsigned+0xc8>
          }
        }
      }
    }
  }
}
     664:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      Digit /= Base;
     668:	460f      	mov	r7, r1
     66a:	e7e7      	b.n	63c <_PrintUnsigned+0x88>
          _StoreChar(pBufferDesc, ' ');
     66c:	2120      	movs	r1, #32
     66e:	4628      	mov	r0, r5
     670:	47c8      	blx	r9
          if (pBufferDesc->ReturnValue < 0) {
     672:	68eb      	ldr	r3, [r5, #12]
     674:	2b00      	cmp	r3, #0
          FieldWidth--;
     676:	f104 34ff 	add.w	r4, r4, #4294967295	@ 0xffffffff
          if (pBufferDesc->ReturnValue < 0) {
     67a:	dbf3      	blt.n	664 <_PrintUnsigned+0xb0>
        while ((FieldWidth != 0u) && (Width < FieldWidth)) {
     67c:	4554      	cmp	r4, sl
     67e:	d8f5      	bhi.n	66c <_PrintUnsigned+0xb8>
     680:	e7f0      	b.n	664 <_PrintUnsigned+0xb0>
     682:	bf00      	nop
     684:	00000575 	.word	0x00000575
     688:	0000349a 	.word	0x0000349a

0000068c <SEGGER_RTT_vprintf>:
*
*  Return values
*    >= 0:  Number of bytes which have been stored in the "Up"-buffer.
*     < 0:  Error
*/
int SEGGER_RTT_vprintf(unsigned BufferIndex, const char * sFormat, va_list * pParamList) {
     68c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  unsigned FieldWidth;
  char acBuffer[SEGGER_RTT_PRINTF_BUFFER_SIZE];

  BufferDesc.pBuffer        = acBuffer;
  BufferDesc.BufferSize     = SEGGER_RTT_PRINTF_BUFFER_SIZE;
  BufferDesc.Cnt            = 0u;
     690:	2300      	movs	r3, #0
int SEGGER_RTT_vprintf(unsigned BufferIndex, const char * sFormat, va_list * pParamList) {
     692:	b09b      	sub	sp, #108	@ 0x6c
     694:	460f      	mov	r7, r1
  BufferDesc.Cnt            = 0u;
     696:	2140      	movs	r1, #64	@ 0x40
     698:	e9cd 1306 	strd	r1, r3, [sp, #24]
  BufferDesc.RTTBufferIndex = BufferIndex;
  BufferDesc.ReturnValue    = 0;
     69c:	e9cd 3008 	strd	r3, r0, [sp, #32]
  BufferDesc.pBuffer        = acBuffer;
     6a0:	f10d 0b28 	add.w	fp, sp, #40	@ 0x28
int SEGGER_RTT_vprintf(unsigned BufferIndex, const char * sFormat, va_list * pParamList) {
     6a4:	9003      	str	r0, [sp, #12]
     6a6:	4616      	mov	r6, r2
  BufferDesc.pBuffer        = acBuffer;
     6a8:	f8cd b014 	str.w	fp, [sp, #20]

  do {
    c = *sFormat;
     6ac:	f817 1b01 	ldrb.w	r1, [r7], #1
    sFormat++;
    if (c == 0u) {
     6b0:	b939      	cbnz	r1, 6c2 <SEGGER_RTT_vprintf+0x36>
    } else {
      _StoreChar(&BufferDesc, c);
    }
  } while (BufferDesc.ReturnValue >= 0);

  if (BufferDesc.ReturnValue > 0) {
     6b2:	9d08      	ldr	r5, [sp, #32]
     6b4:	2d00      	cmp	r5, #0
     6b6:	f300 8116 	bgt.w	8e6 <SEGGER_RTT_vprintf+0x25a>
    if (BufferDesc.Cnt != 0u) {
      SEGGER_RTT_Write(BufferIndex, acBuffer, BufferDesc.Cnt);
    }
    BufferDesc.ReturnValue += (int)BufferDesc.Cnt;
  }
  return BufferDesc.ReturnValue;
     6ba:	9808      	ldr	r0, [sp, #32]
}
     6bc:	b01b      	add	sp, #108	@ 0x6c
     6be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (c == '%') {
     6c2:	2925      	cmp	r1, #37	@ 0x25
     6c4:	f040 80d9 	bne.w	87a <SEGGER_RTT_vprintf+0x1ee>
      FormatFlags = 0u;
     6c8:	2500      	movs	r5, #0
        c = *sFormat;
     6ca:	463a      	mov	r2, r7
     6cc:	f812 3b01 	ldrb.w	r3, [r2], #1
        switch (c) {
     6d0:	2b2d      	cmp	r3, #45	@ 0x2d
     6d2:	d018      	beq.n	706 <SEGGER_RTT_vprintf+0x7a>
     6d4:	d812      	bhi.n	6fc <SEGGER_RTT_vprintf+0x70>
     6d6:	2b23      	cmp	r3, #35	@ 0x23
     6d8:	d01c      	beq.n	714 <SEGGER_RTT_vprintf+0x88>
     6da:	2b2b      	cmp	r3, #43	@ 0x2b
     6dc:	d017      	beq.n	70e <SEGGER_RTT_vprintf+0x82>
      FieldWidth = 0u;
     6de:	2400      	movs	r4, #0
        c = *sFormat;
     6e0:	463a      	mov	r2, r7
     6e2:	f812 3b01 	ldrb.w	r3, [r2], #1
        if ((c < '0') || (c > '9')) {
     6e6:	f1a3 0130 	sub.w	r1, r3, #48	@ 0x30
     6ea:	2909      	cmp	r1, #9
     6ec:	d815      	bhi.n	71a <SEGGER_RTT_vprintf+0x8e>
        FieldWidth = (FieldWidth * 10u) + ((unsigned)c - '0');
     6ee:	210a      	movs	r1, #10
     6f0:	fb01 3304 	mla	r3, r1, r4, r3
     6f4:	f1a3 0430 	sub.w	r4, r3, #48	@ 0x30
        sFormat++;
     6f8:	4617      	mov	r7, r2
        c = *sFormat;
     6fa:	e7f1      	b.n	6e0 <SEGGER_RTT_vprintf+0x54>
        switch (c) {
     6fc:	2b30      	cmp	r3, #48	@ 0x30
     6fe:	d1ee      	bne.n	6de <SEGGER_RTT_vprintf+0x52>
        case '0': FormatFlags |= FORMAT_FLAG_PAD_ZERO;     sFormat++; break;
     700:	f045 0502 	orr.w	r5, r5, #2
     704:	e001      	b.n	70a <SEGGER_RTT_vprintf+0x7e>
        case '-': FormatFlags |= FORMAT_FLAG_LEFT_JUSTIFY; sFormat++; break;
     706:	f045 0501 	orr.w	r5, r5, #1
      FormatFlags = 0u;
     70a:	4617      	mov	r7, r2
     70c:	e7dd      	b.n	6ca <SEGGER_RTT_vprintf+0x3e>
        case '+': FormatFlags |= FORMAT_FLAG_PRINT_SIGN;   sFormat++; break;
     70e:	f045 0504 	orr.w	r5, r5, #4
     712:	e7fa      	b.n	70a <SEGGER_RTT_vprintf+0x7e>
        case '#': FormatFlags |= FORMAT_FLAG_ALTERNATE;    sFormat++; break;
     714:	f045 0508 	orr.w	r5, r5, #8
     718:	e7f7      	b.n	70a <SEGGER_RTT_vprintf+0x7e>
      if (c == '.') {
     71a:	2b2e      	cmp	r3, #46	@ 0x2e
     71c:	d111      	bne.n	742 <SEGGER_RTT_vprintf+0xb6>
        sFormat++;
     71e:	4617      	mov	r7, r2
      NumDigits = 0u;
     720:	f04f 0a00 	mov.w	sl, #0
          NumDigits = NumDigits * 10u + ((unsigned)c - '0');
     724:	200a      	movs	r0, #10
          c = *sFormat;
     726:	4639      	mov	r1, r7
     728:	f811 2b01 	ldrb.w	r2, [r1], #1
          if ((c < '0') || (c > '9')) {
     72c:	f1a2 0c30 	sub.w	ip, r2, #48	@ 0x30
     730:	f1bc 0f09 	cmp.w	ip, #9
     734:	d807      	bhi.n	746 <SEGGER_RTT_vprintf+0xba>
          NumDigits = NumDigits * 10u + ((unsigned)c - '0');
     736:	fb00 220a 	mla	r2, r0, sl, r2
     73a:	f1a2 0a30 	sub.w	sl, r2, #48	@ 0x30
          sFormat++;
     73e:	460f      	mov	r7, r1
          c = *sFormat;
     740:	e7f1      	b.n	726 <SEGGER_RTT_vprintf+0x9a>
      NumDigits = 0u;
     742:	f04f 0a00 	mov.w	sl, #0
      c = *sFormat;
     746:	463a      	mov	r2, r7
     748:	f812 1b01 	ldrb.w	r1, [r2], #1
        if ((c == 'l') || (c == 'h')) {
     74c:	f001 00fb 	and.w	r0, r1, #251	@ 0xfb
     750:	2868      	cmp	r0, #104	@ 0x68
          sFormat++;
     752:	4617      	mov	r7, r2
        if ((c == 'l') || (c == 'h')) {
     754:	d0f8      	beq.n	748 <SEGGER_RTT_vprintf+0xbc>
      switch (c) {
     756:	2978      	cmp	r1, #120	@ 0x78
     758:	d80b      	bhi.n	772 <SEGGER_RTT_vprintf+0xe6>
     75a:	296f      	cmp	r1, #111	@ 0x6f
     75c:	d80d      	bhi.n	77a <SEGGER_RTT_vprintf+0xee>
     75e:	2963      	cmp	r1, #99	@ 0x63
     760:	f000 8087 	beq.w	872 <SEGGER_RTT_vprintf+0x1e6>
     764:	d822      	bhi.n	7ac <SEGGER_RTT_vprintf+0x120>
     766:	2925      	cmp	r1, #37	@ 0x25
     768:	f000 8087 	beq.w	87a <SEGGER_RTT_vprintf+0x1ee>
     76c:	2958      	cmp	r1, #88	@ 0x58
     76e:	f000 809a 	beq.w	8a6 <SEGGER_RTT_vprintf+0x21a>
  } while (BufferDesc.ReturnValue >= 0);
     772:	9b08      	ldr	r3, [sp, #32]
     774:	2b00      	cmp	r3, #0
     776:	da99      	bge.n	6ac <SEGGER_RTT_vprintf+0x20>
     778:	e79b      	b.n	6b2 <SEGGER_RTT_vprintf+0x26>
      switch (c) {
     77a:	3970      	subs	r1, #112	@ 0x70
     77c:	2908      	cmp	r1, #8
     77e:	d8f8      	bhi.n	772 <SEGGER_RTT_vprintf+0xe6>
     780:	a201      	add	r2, pc, #4	@ (adr r2, 788 <SEGGER_RTT_vprintf+0xfc>)
     782:	f852 f021 	ldr.w	pc, [r2, r1, lsl #2]
     786:	bf00      	nop
     788:	000008d7 	.word	0x000008d7
     78c:	00000773 	.word	0x00000773
     790:	00000773 	.word	0x00000773
     794:	000008b7 	.word	0x000008b7
     798:	00000773 	.word	0x00000773
     79c:	00000895 	.word	0x00000895
     7a0:	00000773 	.word	0x00000773
     7a4:	00000773 	.word	0x00000773
     7a8:	000008a7 	.word	0x000008a7
     7ac:	2964      	cmp	r1, #100	@ 0x64
     7ae:	d1e0      	bne.n	772 <SEGGER_RTT_vprintf+0xe6>
        v = va_arg(*pParamList, int);
     7b0:	6832      	ldr	r2, [r6, #0]
     7b2:	f8d2 8000 	ldr.w	r8, [r2]
     7b6:	1d11      	adds	r1, r2, #4
  Number = (v < 0) ? -v : v;
     7b8:	ea88 72e8 	eor.w	r2, r8, r8, asr #31
        v = va_arg(*pParamList, int);
     7bc:	6031      	str	r1, [r6, #0]
  Number = (v < 0) ? -v : v;
     7be:	eba2 72e8 	sub.w	r2, r2, r8, asr #31
  Width = 1u;
     7c2:	f04f 0901 	mov.w	r9, #1
    Number = (Number / (int)Base);
     7c6:	210a      	movs	r1, #10
  while (Number >= (int)Base) {
     7c8:	2a09      	cmp	r2, #9
     7ca:	dc5a      	bgt.n	882 <SEGGER_RTT_vprintf+0x1f6>
  if (NumDigits > Width) {
     7cc:	45d1      	cmp	r9, sl
     7ce:	bf38      	it	cc
     7d0:	46d1      	movcc	r9, sl
  if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN))) {
     7d2:	b12c      	cbz	r4, 7e0 <SEGGER_RTT_vprintf+0x154>
     7d4:	f1b8 0f00 	cmp.w	r8, #0
     7d8:	db01      	blt.n	7de <SEGGER_RTT_vprintf+0x152>
     7da:	076a      	lsls	r2, r5, #29
     7dc:	d500      	bpl.n	7e0 <SEGGER_RTT_vprintf+0x154>
    FieldWidth--;
     7de:	3c01      	subs	r4, #1
  if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
     7e0:	07ab      	lsls	r3, r5, #30
     7e2:	d502      	bpl.n	7ea <SEGGER_RTT_vprintf+0x15e>
     7e4:	f1ba 0f00 	cmp.w	sl, #0
     7e8:	d011      	beq.n	80e <SEGGER_RTT_vprintf+0x182>
     7ea:	07e8      	lsls	r0, r5, #31
     7ec:	d40f      	bmi.n	80e <SEGGER_RTT_vprintf+0x182>
    if (FieldWidth != 0u) {
     7ee:	b16c      	cbz	r4, 80c <SEGGER_RTT_vprintf+0x180>
        _StoreChar(pBufferDesc, ' ');
     7f0:	4a42      	ldr	r2, [pc, #264]	@ (8fc <SEGGER_RTT_vprintf+0x270>)
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
     7f2:	45a1      	cmp	r9, r4
     7f4:	d20b      	bcs.n	80e <SEGGER_RTT_vprintf+0x182>
        _StoreChar(pBufferDesc, ' ');
     7f6:	2120      	movs	r1, #32
     7f8:	a805      	add	r0, sp, #20
     7fa:	4790      	blx	r2
        if (pBufferDesc->ReturnValue < 0) {
     7fc:	9908      	ldr	r1, [sp, #32]
     7fe:	2900      	cmp	r1, #0
        FieldWidth--;
     800:	f104 34ff 	add.w	r4, r4, #4294967295	@ 0xffffffff
        if (pBufferDesc->ReturnValue < 0) {
     804:	db03      	blt.n	80e <SEGGER_RTT_vprintf+0x182>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
     806:	4a3d      	ldr	r2, [pc, #244]	@ (8fc <SEGGER_RTT_vprintf+0x270>)
     808:	2c00      	cmp	r4, #0
     80a:	d1f2      	bne.n	7f2 <SEGGER_RTT_vprintf+0x166>
  Width = 1u;
     80c:	2400      	movs	r4, #0
  if (pBufferDesc->ReturnValue >= 0) {
     80e:	9a08      	ldr	r2, [sp, #32]
     810:	2a00      	cmp	r2, #0
     812:	dbae      	blt.n	772 <SEGGER_RTT_vprintf+0xe6>
    if (v < 0) {
     814:	f1b8 0f00 	cmp.w	r8, #0
     818:	da38      	bge.n	88c <SEGGER_RTT_vprintf+0x200>
      v = -v;
     81a:	f1c8 0800 	rsb	r8, r8, #0
      _StoreChar(pBufferDesc, '-');
     81e:	212d      	movs	r1, #45	@ 0x2d
      _StoreChar(pBufferDesc, '+');
     820:	4a36      	ldr	r2, [pc, #216]	@ (8fc <SEGGER_RTT_vprintf+0x270>)
     822:	a805      	add	r0, sp, #20
     824:	4790      	blx	r2
    if (pBufferDesc->ReturnValue >= 0) {
     826:	9a08      	ldr	r2, [sp, #32]
     828:	2a00      	cmp	r2, #0
     82a:	dba2      	blt.n	772 <SEGGER_RTT_vprintf+0xe6>
      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
     82c:	f005 0203 	and.w	r2, r5, #3
     830:	2a02      	cmp	r2, #2
     832:	d112      	bne.n	85a <SEGGER_RTT_vprintf+0x1ce>
     834:	f1ba 0f00 	cmp.w	sl, #0
     838:	d10f      	bne.n	85a <SEGGER_RTT_vprintf+0x1ce>
        if (FieldWidth != 0u) {
     83a:	b16c      	cbz	r4, 858 <SEGGER_RTT_vprintf+0x1cc>
            _StoreChar(pBufferDesc, '0');
     83c:	4a2f      	ldr	r2, [pc, #188]	@ (8fc <SEGGER_RTT_vprintf+0x270>)
          while ((FieldWidth != 0u) && (Width < FieldWidth)) {
     83e:	45a1      	cmp	r9, r4
     840:	d20b      	bcs.n	85a <SEGGER_RTT_vprintf+0x1ce>
            _StoreChar(pBufferDesc, '0');
     842:	2130      	movs	r1, #48	@ 0x30
     844:	a805      	add	r0, sp, #20
     846:	4790      	blx	r2
            if (pBufferDesc->ReturnValue < 0) {
     848:	9908      	ldr	r1, [sp, #32]
     84a:	2900      	cmp	r1, #0
            FieldWidth--;
     84c:	f104 34ff 	add.w	r4, r4, #4294967295	@ 0xffffffff
            if (pBufferDesc->ReturnValue < 0) {
     850:	db03      	blt.n	85a <SEGGER_RTT_vprintf+0x1ce>
          while ((FieldWidth != 0u) && (Width < FieldWidth)) {
     852:	4a2a      	ldr	r2, [pc, #168]	@ (8fc <SEGGER_RTT_vprintf+0x270>)
     854:	2c00      	cmp	r4, #0
     856:	d1f2      	bne.n	83e <SEGGER_RTT_vprintf+0x1b2>
  Width = 1u;
     858:	2400      	movs	r4, #0
      if (pBufferDesc->ReturnValue >= 0) {
     85a:	9a08      	ldr	r2, [sp, #32]
     85c:	2a00      	cmp	r2, #0
     85e:	db88      	blt.n	772 <SEGGER_RTT_vprintf+0xe6>
        _PrintUnsigned(pBufferDesc, (unsigned)v, Base, NumDigits, FieldWidth, FormatFlags);
     860:	e9cd 4500 	strd	r4, r5, [sp]
     864:	4653      	mov	r3, sl
     866:	220a      	movs	r2, #10
     868:	4641      	mov	r1, r8
        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, 8u, 8u, 0u);
     86a:	4c25      	ldr	r4, [pc, #148]	@ (900 <SEGGER_RTT_vprintf+0x274>)
     86c:	a805      	add	r0, sp, #20
     86e:	47a0      	blx	r4
        break;
     870:	e77f      	b.n	772 <SEGGER_RTT_vprintf+0xe6>
        v = va_arg(*pParamList, int);
     872:	6833      	ldr	r3, [r6, #0]
     874:	1d1a      	adds	r2, r3, #4
        _StoreChar(&BufferDesc, c0);
     876:	7819      	ldrb	r1, [r3, #0]
        v = va_arg(*pParamList, int);
     878:	6032      	str	r2, [r6, #0]
      _StoreChar(&BufferDesc, c);
     87a:	4b20      	ldr	r3, [pc, #128]	@ (8fc <SEGGER_RTT_vprintf+0x270>)
     87c:	a805      	add	r0, sp, #20
     87e:	4798      	blx	r3
     880:	e777      	b.n	772 <SEGGER_RTT_vprintf+0xe6>
    Width++;
     882:	f109 0901 	add.w	r9, r9, #1
    Number = (Number / (int)Base);
     886:	fbb2 f2f1 	udiv	r2, r2, r1
    Width++;
     88a:	e79d      	b.n	7c8 <SEGGER_RTT_vprintf+0x13c>
    } else if ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN) {
     88c:	0769      	lsls	r1, r5, #29
     88e:	d5cd      	bpl.n	82c <SEGGER_RTT_vprintf+0x1a0>
      _StoreChar(pBufferDesc, '+');
     890:	212b      	movs	r1, #43	@ 0x2b
     892:	e7c5      	b.n	820 <SEGGER_RTT_vprintf+0x194>
        v = va_arg(*pParamList, int);
     894:	6831      	ldr	r1, [r6, #0]
     896:	1d0a      	adds	r2, r1, #4
     898:	6032      	str	r2, [r6, #0]
        _PrintUnsigned(&BufferDesc, (unsigned)v, 10u, NumDigits, FieldWidth, FormatFlags);
     89a:	e9cd 4500 	strd	r4, r5, [sp]
     89e:	4653      	mov	r3, sl
     8a0:	220a      	movs	r2, #10
        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, 8u, 8u, 0u);
     8a2:	6809      	ldr	r1, [r1, #0]
     8a4:	e7e1      	b.n	86a <SEGGER_RTT_vprintf+0x1de>
        v = va_arg(*pParamList, int);
     8a6:	6831      	ldr	r1, [r6, #0]
     8a8:	1d0a      	adds	r2, r1, #4
     8aa:	6032      	str	r2, [r6, #0]
        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, NumDigits, FieldWidth, FormatFlags);
     8ac:	e9cd 4500 	strd	r4, r5, [sp]
     8b0:	4653      	mov	r3, sl
        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, 8u, 8u, 0u);
     8b2:	2210      	movs	r2, #16
     8b4:	e7f5      	b.n	8a2 <SEGGER_RTT_vprintf+0x216>
          const char * s = va_arg(*pParamList, const char *);
     8b6:	6833      	ldr	r3, [r6, #0]
           _StoreChar(&BufferDesc, c);
     8b8:	4d10      	ldr	r5, [pc, #64]	@ (8fc <SEGGER_RTT_vprintf+0x270>)
          const char * s = va_arg(*pParamList, const char *);
     8ba:	1d1a      	adds	r2, r3, #4
     8bc:	6032      	str	r2, [r6, #0]
     8be:	681c      	ldr	r4, [r3, #0]
            c = *s;
     8c0:	f814 1b01 	ldrb.w	r1, [r4], #1
            if (c == '\0') {
     8c4:	2900      	cmp	r1, #0
     8c6:	f43f af54 	beq.w	772 <SEGGER_RTT_vprintf+0xe6>
           _StoreChar(&BufferDesc, c);
     8ca:	a805      	add	r0, sp, #20
     8cc:	47a8      	blx	r5
          } while (BufferDesc.ReturnValue >= 0);
     8ce:	9b08      	ldr	r3, [sp, #32]
     8d0:	2b00      	cmp	r3, #0
     8d2:	daf5      	bge.n	8c0 <SEGGER_RTT_vprintf+0x234>
     8d4:	e74d      	b.n	772 <SEGGER_RTT_vprintf+0xe6>
        v = va_arg(*pParamList, int);
     8d6:	6831      	ldr	r1, [r6, #0]
     8d8:	1d0b      	adds	r3, r1, #4
     8da:	6033      	str	r3, [r6, #0]
        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, 8u, 8u, 0u);
     8dc:	2200      	movs	r2, #0
     8de:	2308      	movs	r3, #8
     8e0:	e9cd 3200 	strd	r3, r2, [sp]
     8e4:	e7e5      	b.n	8b2 <SEGGER_RTT_vprintf+0x226>
    if (BufferDesc.Cnt != 0u) {
     8e6:	9c07      	ldr	r4, [sp, #28]
     8e8:	b124      	cbz	r4, 8f4 <SEGGER_RTT_vprintf+0x268>
      SEGGER_RTT_Write(BufferIndex, acBuffer, BufferDesc.Cnt);
     8ea:	9803      	ldr	r0, [sp, #12]
     8ec:	4b05      	ldr	r3, [pc, #20]	@ (904 <SEGGER_RTT_vprintf+0x278>)
     8ee:	4622      	mov	r2, r4
     8f0:	4659      	mov	r1, fp
     8f2:	4798      	blx	r3
    BufferDesc.ReturnValue += (int)BufferDesc.Cnt;
     8f4:	442c      	add	r4, r5
     8f6:	9408      	str	r4, [sp, #32]
     8f8:	e6df      	b.n	6ba <SEGGER_RTT_vprintf+0x2e>
     8fa:	bf00      	nop
     8fc:	00000575 	.word	0x00000575
     900:	000005b5 	.word	0x000005b5
     904:	00000539 	.word	0x00000539

00000908 <SEGGER_RTT_printf>:
*          u: Print the argument as an unsigned integer
*          x: Print the argument as an hexadecimal integer
*          s: Print the string pointed to by the argument
*          p: Print the argument as an 8-digit hexadecimal integer. (Argument shall be a pointer to void.)
*/
int SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...) {
     908:	b40e      	push	{r1, r2, r3}
     90a:	b503      	push	{r0, r1, lr}
     90c:	ab03      	add	r3, sp, #12
  int r;
  va_list ParamList;

  va_start(ParamList, sFormat);
  r = SEGGER_RTT_vprintf(BufferIndex, sFormat, &ParamList);
     90e:	aa01      	add	r2, sp, #4
int SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...) {
     910:	f853 1b04 	ldr.w	r1, [r3], #4
  va_start(ParamList, sFormat);
     914:	9301      	str	r3, [sp, #4]
  r = SEGGER_RTT_vprintf(BufferIndex, sFormat, &ParamList);
     916:	4b03      	ldr	r3, [pc, #12]	@ (924 <SEGGER_RTT_printf+0x1c>)
     918:	4798      	blx	r3
  va_end(ParamList);
  return r;
}
     91a:	b002      	add	sp, #8
     91c:	f85d eb04 	ldr.w	lr, [sp], #4
     920:	b003      	add	sp, #12
     922:	4770      	bx	lr
     924:	0000068d 	.word	0x0000068d

00000928 <vListInitialise>:
void vListInitialise(List_t *const pxList)
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = (ListItem_t *)&(
     928:	f100 0308 	add.w	r3, r0, #8
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     92c:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = (ListItem_t *)&(pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as
     930:	e9c0 2302 	strd	r2, r3, [r0, #8]
	pxList->pxIndex = (ListItem_t *)&(
     934:	6043      	str	r3, [r0, #4]
	                                                                the list end to save RAM.  This is checked and
	                                                                valid. */
	pxList->xListEnd.pxPrevious = (ListItem_t *)&(
     936:	6103      	str	r3, [r0, #16]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	pxList->uxNumberOfItems = (UBaseType_t)0U;
     938:	2300      	movs	r3, #0
     93a:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE(pxList);
	listSET_LIST_INTEGRITY_CHECK_2_VALUE(pxList);
}
     93c:	4770      	bx	lr

0000093e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem(ListItem_t *const pxItem)
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     93e:	2300      	movs	r3, #0
     940:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
}
     942:	4770      	bx	lr

00000944 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd(List_t *const pxList, ListItem_t *const pxNewListItem)
{
	ListItem_t *const pxIndex = pxList->pxIndex;
     944:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY(pxNewListItem);

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext     = pxIndex;
     946:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     948:	689a      	ldr	r2, [r3, #8]
     94a:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     94c:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious         = pxNewListItem;
     94e:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = (void *)pxList;

	(pxList->uxNumberOfItems)++;
     950:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = (void *)pxList;
     952:	6108      	str	r0, [r1, #16]
	(pxList->uxNumberOfItems)++;
     954:	3301      	adds	r3, #1
     956:	6003      	str	r3, [r0, #0]
}
     958:	4770      	bx	lr

0000095a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert(List_t *const pxList, ListItem_t *const pxNewListItem)
{
     95a:	b530      	push	{r4, r5, lr}
	ListItem_t *     pxIterator;
	const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     95c:	680c      	ldr	r4, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if (xValueOfInsertion == portMAX_DELAY) {
     95e:	1c63      	adds	r3, r4, #1
     960:	d10a      	bne.n	978 <vListInsert+0x1e>
		pxIterator = pxList->xListEnd.pxPrevious;
     962:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext             = pxIterator->pxNext;
     964:	685a      	ldr	r2, [r3, #4]
     966:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     968:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious         = pxIterator;
     96a:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext                = pxNewListItem;
     96c:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = (void *)pxList;

	(pxList->uxNumberOfItems)++;
     96e:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = (void *)pxList;
     970:	6108      	str	r0, [r1, #16]
	(pxList->uxNumberOfItems)++;
     972:	3301      	adds	r3, #1
     974:	6003      	str	r3, [r0, #0]
}
     976:	bd30      	pop	{r4, r5, pc}
		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
     978:	f100 0208 	add.w	r2, r0, #8
     97c:	4613      	mov	r3, r2
     97e:	6852      	ldr	r2, [r2, #4]
     980:	6815      	ldr	r5, [r2, #0]
     982:	42a5      	cmp	r5, r4
     984:	d9fa      	bls.n	97c <vListInsert+0x22>
     986:	e7ed      	b.n	964 <vListInsert+0xa>

00000988 <uxListRemove>:
{
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     988:	e9d0 1201 	ldrd	r1, r2, [r0, #4]
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;
     98c:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     98e:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     990:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if (pxList->pxIndex == pxItemToRemove) {
     992:	6859      	ldr	r1, [r3, #4]
     994:	4281      	cmp	r1, r0
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     996:	bf08      	it	eq
     998:	605a      	streq	r2, [r3, #4]
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     99a:	2200      	movs	r2, #0
     99c:	6102      	str	r2, [r0, #16]
	(pxList->uxNumberOfItems)--;
     99e:	681a      	ldr	r2, [r3, #0]
     9a0:	3a01      	subs	r2, #1
     9a2:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
     9a4:	6818      	ldr	r0, [r3, #0]
}
     9a6:	4770      	bx	lr

000009a8 <_delay_init>:
	                | (1 << SysTick_CTRL_CLKSOURCE_Pos);
}
/**
 * \brief Initialize delay functionality
 */
void _delay_init(void *const hw)
     9a8:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
     9ac:	f06f 427f 	mvn.w	r2, #4278190080	@ 0xff000000
     9b0:	615a      	str	r2, [r3, #20]
     9b2:	2205      	movs	r2, #5
     9b4:	611a      	str	r2, [r3, #16]
     9b6:	4770      	bx	lr

000009b8 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
     9b8:	4808      	ldr	r0, [pc, #32]	@ (9dc <prvPortStartFirstTask+0x24>)
     9ba:	6800      	ldr	r0, [r0, #0]
     9bc:	6800      	ldr	r0, [r0, #0]
     9be:	f380 8808 	msr	MSP, r0
     9c2:	f04f 0000 	mov.w	r0, #0
     9c6:	f380 8814 	msr	CONTROL, r0
     9ca:	b662      	cpsie	i
     9cc:	b661      	cpsie	f
     9ce:	f3bf 8f4f 	dsb	sy
     9d2:	f3bf 8f6f 	isb	sy
     9d6:	df00      	svc	0
     9d8:	bf00      	nop
	               " cpsie f				\n"
	               " dsb					\n"
	               " isb					\n"
	               " svc 0					\n" /* System call to start first task. */
	               " nop					\n");
}
     9da:	0000      	.short	0x0000
     9dc:	e000ed08 	.word	0xe000ed08

000009e0 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP(void)
{
	__asm volatile("	ldr.w r0, =0xE000ED88		\n" /* The FPU enable bits are in the CPACR. */
     9e0:	f8df 000c 	ldr.w	r0, [pc, #12]	@ 9f0 <vPortEnableVFP+0x10>
     9e4:	6801      	ldr	r1, [r0, #0]
     9e6:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
     9ea:	6001      	str	r1, [r0, #0]
     9ec:	4770      	bx	lr
	               "	ldr r1, [r0]				\n"
	               "								\n"
	               "	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
	               "	str r1, [r0]				\n"
	               "	bx r14						");
}
     9ee:	0000      	.short	0x0000
     9f0:	e000ed88 	.word	0xe000ed88

000009f4 <prvTaskExitError>:
{
     9f4:	b082      	sub	sp, #8
	volatile uint32_t ulDummy = 0;
     9f6:	2300      	movs	r3, #0
     9f8:	9301      	str	r3, [sp, #4]
	configASSERT(uxCriticalNesting == ~0UL);
     9fa:	4b0d      	ldr	r3, [pc, #52]	@ (a30 <prvTaskExitError+0x3c>)
     9fc:	681b      	ldr	r3, [r3, #0]
     9fe:	3301      	adds	r3, #1
     a00:	d008      	beq.n	a14 <prvTaskExitError+0x20>

portFORCE_INLINE static void vPortRaiseBASEPRI(void)
{
	uint32_t ulNewBASEPRI;

	__asm volatile("	mov %0, %1												\n"
     a02:	f04f 0380 	mov.w	r3, #128	@ 0x80
     a06:	f383 8811 	msr	BASEPRI, r3
     a0a:	f3bf 8f6f 	isb	sy
     a0e:	f3bf 8f4f 	dsb	sy
     a12:	e7fe      	b.n	a12 <prvTaskExitError+0x1e>
     a14:	f04f 0380 	mov.w	r3, #128	@ 0x80
     a18:	f383 8811 	msr	BASEPRI, r3
     a1c:	f3bf 8f6f 	isb	sy
     a20:	f3bf 8f4f 	dsb	sy
	while (ulDummy == 0) {
     a24:	9b01      	ldr	r3, [sp, #4]
     a26:	2b00      	cmp	r3, #0
     a28:	d0fc      	beq.n	a24 <prvTaskExitError+0x30>
}
     a2a:	b002      	add	sp, #8
     a2c:	4770      	bx	lr
     a2e:	bf00      	nop
     a30:	20000000 	.word	0x20000000

00000a34 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR; /* xPSR */
     a34:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
     a38:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* LR */
     a3c:	4b07      	ldr	r3, [pc, #28]	@ (a5c <pxPortInitialiseStack+0x28>)
     a3e:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ((StackType_t)pxCode) & portSTART_ADDRESS_MASK; /* PC */
     a42:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = portINITIAL_EXC_RETURN;
     a46:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = ((StackType_t)pxCode) & portSTART_ADDRESS_MASK; /* PC */
     a4a:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = (StackType_t)pvParameters; /* R0 */
     a4e:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
     a52:	f840 3c24 	str.w	r3, [r0, #-36]
}
     a56:	3844      	subs	r0, #68	@ 0x44
     a58:	4770      	bx	lr
     a5a:	bf00      	nop
     a5c:	000009f5 	.word	0x000009f5

00000a60 <SVCall_Handler>:
	__asm volatile("	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
     a60:	4b07      	ldr	r3, [pc, #28]	@ (a80 <pxCurrentTCBConst2>)
     a62:	6819      	ldr	r1, [r3, #0]
     a64:	6808      	ldr	r0, [r1, #0]
     a66:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     a6a:	f380 8809 	msr	PSP, r0
     a6e:	f3bf 8f6f 	isb	sy
     a72:	f04f 0000 	mov.w	r0, #0
     a76:	f380 8811 	msr	BASEPRI, r0
     a7a:	4770      	bx	lr
     a7c:	f3af 8000 	nop.w

00000a80 <pxCurrentTCBConst2>:
     a80:	200205f4 	.word	0x200205f4

00000a84 <vPortEnterCritical>:
     a84:	f04f 0380 	mov.w	r3, #128	@ 0x80
     a88:	f383 8811 	msr	BASEPRI, r3
     a8c:	f3bf 8f6f 	isb	sy
     a90:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
     a94:	4a0a      	ldr	r2, [pc, #40]	@ (ac0 <vPortEnterCritical+0x3c>)
     a96:	6813      	ldr	r3, [r2, #0]
     a98:	3301      	adds	r3, #1
	if (uxCriticalNesting == 1) {
     a9a:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
     a9c:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 1) {
     a9e:	d10e      	bne.n	abe <vPortEnterCritical+0x3a>
		configASSERT((portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK) == 0);
     aa0:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
     aa4:	f8d3 3d04 	ldr.w	r3, [r3, #3332]	@ 0xd04
     aa8:	b2db      	uxtb	r3, r3
     aaa:	b143      	cbz	r3, abe <vPortEnterCritical+0x3a>
     aac:	f04f 0380 	mov.w	r3, #128	@ 0x80
     ab0:	f383 8811 	msr	BASEPRI, r3
     ab4:	f3bf 8f6f 	isb	sy
     ab8:	f3bf 8f4f 	dsb	sy
     abc:	e7fe      	b.n	abc <vPortEnterCritical+0x38>
}
     abe:	4770      	bx	lr
     ac0:	20000000 	.word	0x20000000

00000ac4 <vPortExitCritical>:
	configASSERT(uxCriticalNesting);
     ac4:	4a08      	ldr	r2, [pc, #32]	@ (ae8 <vPortExitCritical+0x24>)
     ac6:	6813      	ldr	r3, [r2, #0]
     ac8:	b943      	cbnz	r3, adc <vPortExitCritical+0x18>
     aca:	f04f 0380 	mov.w	r3, #128	@ 0x80
     ace:	f383 8811 	msr	BASEPRI, r3
     ad2:	f3bf 8f6f 	isb	sy
     ad6:	f3bf 8f4f 	dsb	sy
     ada:	e7fe      	b.n	ada <vPortExitCritical+0x16>
	uxCriticalNesting--;
     adc:	3b01      	subs	r3, #1
     ade:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
     ae0:	b90b      	cbnz	r3, ae6 <vPortExitCritical+0x22>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI(uint32_t ulNewMaskValue)
{
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
     ae2:	f383 8811 	msr	BASEPRI, r3
}
     ae6:	4770      	bx	lr
     ae8:	20000000 	.word	0x20000000
     aec:	00000000 	.word	0x00000000

00000af0 <PendSV_Handler>:
	__asm volatile(
     af0:	f3ef 8009 	mrs	r0, PSP
     af4:	f3bf 8f6f 	isb	sy
     af8:	4b15      	ldr	r3, [pc, #84]	@ (b50 <pxCurrentTCBConst>)
     afa:	681a      	ldr	r2, [r3, #0]
     afc:	f01e 0f10 	tst.w	lr, #16
     b00:	bf08      	it	eq
     b02:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
     b06:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     b0a:	6010      	str	r0, [r2, #0]
     b0c:	e92d 0009 	stmdb	sp!, {r0, r3}
     b10:	f04f 0080 	mov.w	r0, #128	@ 0x80
     b14:	f380 8811 	msr	BASEPRI, r0
     b18:	f3bf 8f4f 	dsb	sy
     b1c:	f3bf 8f6f 	isb	sy
     b20:	f002 f990 	bl	2e44 <vTaskSwitchContext>
     b24:	f04f 0000 	mov.w	r0, #0
     b28:	f380 8811 	msr	BASEPRI, r0
     b2c:	bc09      	pop	{r0, r3}
     b2e:	6819      	ldr	r1, [r3, #0]
     b30:	6808      	ldr	r0, [r1, #0]
     b32:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     b36:	f01e 0f10 	tst.w	lr, #16
     b3a:	bf08      	it	eq
     b3c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
     b40:	f380 8809 	msr	PSP, r0
     b44:	f3bf 8f6f 	isb	sy
     b48:	4770      	bx	lr
     b4a:	bf00      	nop
     b4c:	f3af 8000 	nop.w

00000b50 <pxCurrentTCBConst>:
     b50:	200205f4 	.word	0x200205f4

00000b54 <SysTick_Handler>:
{
     b54:	b508      	push	{r3, lr}
	__asm volatile("	mov %0, %1												\n"
     b56:	f04f 0380 	mov.w	r3, #128	@ 0x80
     b5a:	f383 8811 	msr	BASEPRI, r3
     b5e:	f3bf 8f6f 	isb	sy
     b62:	f3bf 8f4f 	dsb	sy
		if (xTaskIncrementTick() != pdFALSE) {
     b66:	4b06      	ldr	r3, [pc, #24]	@ (b80 <SysTick_Handler+0x2c>)
     b68:	4798      	blx	r3
     b6a:	b128      	cbz	r0, b78 <SysTick_Handler+0x24>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
     b6c:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
     b70:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
     b74:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
     b78:	2300      	movs	r3, #0
     b7a:	f383 8811 	msr	BASEPRI, r3
}
     b7e:	bd08      	pop	{r3, pc}
     b80:	00002c01 	.word	0x00002c01

00000b84 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_CTRL_REG          = 0UL;
     b84:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
     b88:	2200      	movs	r2, #0
     b8a:	611a      	str	r2, [r3, #16]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
     b8c:	619a      	str	r2, [r3, #24]
	portNVIC_SYSTICK_LOAD_REG = (configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
     b8e:	f240 52db 	movw	r2, #1499	@ 0x5db
     b92:	615a      	str	r2, [r3, #20]
	portNVIC_SYSTICK_CTRL_REG = (portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT);
     b94:	2207      	movs	r2, #7
     b96:	611a      	str	r2, [r3, #16]
}
     b98:	4770      	bx	lr
	...

00000b9c <xPortStartScheduler>:
	configASSERT(portCPUID != portCORTEX_M7_r0p1_ID);
     b9c:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
{
     ba0:	b537      	push	{r0, r1, r2, r4, r5, lr}
	configASSERT(portCPUID != portCORTEX_M7_r0p1_ID);
     ba2:	f8d3 1d00 	ldr.w	r1, [r3, #3328]	@ 0xd00
     ba6:	4a38      	ldr	r2, [pc, #224]	@ (c88 <xPortStartScheduler+0xec>)
     ba8:	4291      	cmp	r1, r2
     baa:	d108      	bne.n	bbe <xPortStartScheduler+0x22>
	__asm volatile("	mov %0, %1												\n"
     bac:	f04f 0380 	mov.w	r3, #128	@ 0x80
     bb0:	f383 8811 	msr	BASEPRI, r3
     bb4:	f3bf 8f6f 	isb	sy
     bb8:	f3bf 8f4f 	dsb	sy
     bbc:	e7fe      	b.n	bbc <xPortStartScheduler+0x20>
	configASSERT(portCPUID != portCORTEX_M7_r0p0_ID);
     bbe:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	@ 0xd00
     bc2:	4b32      	ldr	r3, [pc, #200]	@ (c8c <xPortStartScheduler+0xf0>)
     bc4:	429a      	cmp	r2, r3
     bc6:	d108      	bne.n	bda <xPortStartScheduler+0x3e>
     bc8:	f04f 0380 	mov.w	r3, #128	@ 0x80
     bcc:	f383 8811 	msr	BASEPRI, r3
     bd0:	f3bf 8f6f 	isb	sy
     bd4:	f3bf 8f4f 	dsb	sy
     bd8:	e7fe      	b.n	bd8 <xPortStartScheduler+0x3c>
		ulOriginalPriority = *pucFirstUserPriorityRegister;
     bda:	4b2d      	ldr	r3, [pc, #180]	@ (c90 <xPortStartScheduler+0xf4>)
     bdc:	781a      	ldrb	r2, [r3, #0]
     bde:	b2d2      	uxtb	r2, r2
     be0:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
     be2:	22ff      	movs	r2, #255	@ 0xff
     be4:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
     be6:	781b      	ldrb	r3, [r3, #0]
     be8:	b2db      	uxtb	r3, r3
     bea:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
     bee:	f89d 2003 	ldrb.w	r2, [sp, #3]
     bf2:	4b28      	ldr	r3, [pc, #160]	@ (c94 <xPortStartScheduler+0xf8>)
     bf4:	f002 0280 	and.w	r2, r2, #128	@ 0x80
     bf8:	701a      	strb	r2, [r3, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
     bfa:	2207      	movs	r2, #7
     bfc:	605a      	str	r2, [r3, #4]
		while ((ucMaxPriorityValue & portTOP_BIT_OF_BYTE) == portTOP_BIT_OF_BYTE) {
     bfe:	f89d 1003 	ldrb.w	r1, [sp, #3]
			ulMaxPRIGROUPValue--;
     c02:	685a      	ldr	r2, [r3, #4]
		while ((ucMaxPriorityValue & portTOP_BIT_OF_BYTE) == portTOP_BIT_OF_BYTE) {
     c04:	0609      	lsls	r1, r1, #24
     c06:	d40a      	bmi.n	c1e <xPortStartScheduler+0x82>
			configASSERT((portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue) == configPRIO_BITS);
     c08:	2a04      	cmp	r2, #4
     c0a:	d011      	beq.n	c30 <xPortStartScheduler+0x94>
     c0c:	f04f 0380 	mov.w	r3, #128	@ 0x80
     c10:	f383 8811 	msr	BASEPRI, r3
     c14:	f3bf 8f6f 	isb	sy
     c18:	f3bf 8f4f 	dsb	sy
     c1c:	e7fe      	b.n	c1c <xPortStartScheduler+0x80>
			ulMaxPRIGROUPValue--;
     c1e:	3a01      	subs	r2, #1
     c20:	605a      	str	r2, [r3, #4]
			ucMaxPriorityValue <<= (uint8_t)0x01;
     c22:	f89d 2003 	ldrb.w	r2, [sp, #3]
     c26:	0052      	lsls	r2, r2, #1
     c28:	b2d2      	uxtb	r2, r2
     c2a:	f88d 2003 	strb.w	r2, [sp, #3]
     c2e:	e7e6      	b.n	bfe <xPortStartScheduler+0x62>
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
     c30:	f44f 6280 	mov.w	r2, #1024	@ 0x400
     c34:	605a      	str	r2, [r3, #4]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
     c36:	9b01      	ldr	r3, [sp, #4]
     c38:	f102 22e0 	add.w	r2, r2, #3758153728	@ 0xe000e000
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
     c3c:	f04f 24e0 	mov.w	r4, #3758153728	@ 0xe000e000
		*pucFirstUserPriorityRegister = ulOriginalPriority;
     c40:	b2db      	uxtb	r3, r3
     c42:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
     c44:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	@ 0xd20
     c48:	f443 0360 	orr.w	r3, r3, #14680064	@ 0xe00000
     c4c:	f8c4 3d20 	str.w	r3, [r4, #3360]	@ 0xd20
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
     c50:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	@ 0xd20
     c54:	f043 4360 	orr.w	r3, r3, #3758096384	@ 0xe0000000
     c58:	f8c4 3d20 	str.w	r3, [r4, #3360]	@ 0xd20
	vPortSetupTimerInterrupt();
     c5c:	4b0e      	ldr	r3, [pc, #56]	@ (c98 <xPortStartScheduler+0xfc>)
     c5e:	4798      	blx	r3
	uxCriticalNesting = 0;
     c60:	4b0e      	ldr	r3, [pc, #56]	@ (c9c <xPortStartScheduler+0x100>)
     c62:	2500      	movs	r5, #0
     c64:	601d      	str	r5, [r3, #0]
	vPortEnableVFP();
     c66:	4b0e      	ldr	r3, [pc, #56]	@ (ca0 <xPortStartScheduler+0x104>)
     c68:	4798      	blx	r3
	*(portFPCCR) |= portASPEN_AND_LSPEN_BITS;
     c6a:	f8d4 3f34 	ldr.w	r3, [r4, #3892]	@ 0xf34
     c6e:	f043 4340 	orr.w	r3, r3, #3221225472	@ 0xc0000000
     c72:	f8c4 3f34 	str.w	r3, [r4, #3892]	@ 0xf34
	prvPortStartFirstTask();
     c76:	4b0b      	ldr	r3, [pc, #44]	@ (ca4 <xPortStartScheduler+0x108>)
     c78:	4798      	blx	r3
	vTaskSwitchContext();
     c7a:	4b0b      	ldr	r3, [pc, #44]	@ (ca8 <xPortStartScheduler+0x10c>)
     c7c:	4798      	blx	r3
	prvTaskExitError();
     c7e:	4b0b      	ldr	r3, [pc, #44]	@ (cac <xPortStartScheduler+0x110>)
     c80:	4798      	blx	r3
}
     c82:	4628      	mov	r0, r5
     c84:	b003      	add	sp, #12
     c86:	bd30      	pop	{r4, r5, pc}
     c88:	410fc271 	.word	0x410fc271
     c8c:	410fc270 	.word	0x410fc270
     c90:	e000e400 	.word	0xe000e400
     c94:	200004dc 	.word	0x200004dc
     c98:	00000b85 	.word	0x00000b85
     c9c:	20000000 	.word	0x20000000
     ca0:	000009e1 	.word	0x000009e1
     ca4:	000009b9 	.word	0x000009b9
     ca8:	00002e45 	.word	0x00002e45
     cac:	000009f5 	.word	0x000009f5

00000cb0 <vPortValidateInterruptPriority>:
{
	uint32_t ulCurrentInterrupt;
	uint8_t  ucCurrentPriority;

	/* Obtain the number of the currently executing interrupt. */
	__asm volatile("mrs %0, ipsr" : "=r"(ulCurrentInterrupt)::"memory");
     cb0:	f3ef 8305 	mrs	r3, IPSR

	/* Is the interrupt number a user defined interrupt? */
	if (ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER) {
     cb4:	2b0f      	cmp	r3, #15
     cb6:	4a11      	ldr	r2, [pc, #68]	@ (cfc <vPortValidateInterruptPriority+0x4c>)
     cb8:	d90d      	bls.n	cd6 <vPortValidateInterruptPriority+0x26>
		/* Look up the interrupt's priority. */
		ucCurrentPriority = pcInterruptPriorityRegisters[ulCurrentInterrupt];
     cba:	4911      	ldr	r1, [pc, #68]	@ (d00 <vPortValidateInterruptPriority+0x50>)
     cbc:	5c5b      	ldrb	r3, [r3, r1]
		interrupt entry is as fast and simple as possible.

		The following links provide detailed information:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html
		http://www.freertos.org/FAQHelp.html */
		configASSERT(ucCurrentPriority >= ucMaxSysCallPriority);
     cbe:	7811      	ldrb	r1, [r2, #0]
     cc0:	4299      	cmp	r1, r3
     cc2:	d908      	bls.n	cd6 <vPortValidateInterruptPriority+0x26>
     cc4:	f04f 0380 	mov.w	r3, #128	@ 0x80
     cc8:	f383 8811 	msr	BASEPRI, r3
     ccc:	f3bf 8f6f 	isb	sy
     cd0:	f3bf 8f4f 	dsb	sy
     cd4:	e7fe      	b.n	cd4 <vPortValidateInterruptPriority+0x24>
	configuration then the correct setting can be achieved on all Cortex-M
	devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
	scheduler.  Note however that some vendor specific peripheral libraries
	assume a non-zero priority group setting, in which cases using a value
	of zero will result in unpredictable behaviour. */
	configASSERT((portAIRCR_REG & portPRIORITY_GROUP_MASK) <= ulMaxPRIGROUPValue);
     cd6:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
     cda:	6852      	ldr	r2, [r2, #4]
     cdc:	f8d3 3d0c 	ldr.w	r3, [r3, #3340]	@ 0xd0c
     ce0:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
     ce4:	4293      	cmp	r3, r2
     ce6:	d908      	bls.n	cfa <vPortValidateInterruptPriority+0x4a>
     ce8:	f04f 0380 	mov.w	r3, #128	@ 0x80
     cec:	f383 8811 	msr	BASEPRI, r3
     cf0:	f3bf 8f6f 	isb	sy
     cf4:	f3bf 8f4f 	dsb	sy
     cf8:	e7fe      	b.n	cf8 <vPortValidateInterruptPriority+0x48>
}
     cfa:	4770      	bx	lr
     cfc:	200004dc 	.word	0x200004dc
     d00:	e000e3f0 	.word	0xe000e3f0

00000d04 <hri_wdt_wait_for_sync>:
typedef uint8_t  hri_wdt_intenset_reg_t;
typedef uint8_t  hri_wdt_intflag_reg_t;

static inline void hri_wdt_wait_for_sync(const void *const hw, hri_wdt_syncbusy_reg_t reg)
{
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
     d04:	6883      	ldr	r3, [r0, #8]
     d06:	420b      	tst	r3, r1
     d08:	d1fc      	bne.n	d04 <hri_wdt_wait_for_sync>
	};
}
     d0a:	4770      	bx	lr

00000d0c <_wdt_init>:
{
     d0c:	b538      	push	{r3, r4, r5, lr}
	ASSERT(dev && dev->hw);
     d0e:	4604      	mov	r4, r0
     d10:	b118      	cbz	r0, d1a <_wdt_init+0xe>
     d12:	6800      	ldr	r0, [r0, #0]
     d14:	3800      	subs	r0, #0
     d16:	bf18      	it	ne
     d18:	2001      	movne	r0, #1
     d1a:	4b10      	ldr	r3, [pc, #64]	@ (d5c <_wdt_init+0x50>)
     d1c:	4910      	ldr	r1, [pc, #64]	@ (d60 <_wdt_init+0x54>)
}

static inline bool hri_wdt_get_CTRLA_ALWAYSON_bit(const void *const hw)
{
	uint8_t tmp;
	hri_wdt_wait_for_sync(hw, WDT_SYNCBUSY_ENABLE | WDT_SYNCBUSY_WEN | WDT_SYNCBUSY_ALWAYSON);
     d1e:	4d11      	ldr	r5, [pc, #68]	@ (d64 <_wdt_init+0x58>)
     d20:	2250      	movs	r2, #80	@ 0x50
     d22:	4798      	blx	r3
	if (hri_wdt_get_CTRLA_ALWAYSON_bit(dev->hw) || hri_wdt_get_CTRLA_ENABLE_bit(dev->hw)) {
     d24:	6822      	ldr	r2, [r4, #0]
     d26:	210e      	movs	r1, #14
     d28:	4610      	mov	r0, r2
     d2a:	47a8      	blx	r5
	tmp = ((Wdt *)hw)->CTRLA.reg;
     d2c:	7813      	ldrb	r3, [r2, #0]
     d2e:	09db      	lsrs	r3, r3, #7
     d30:	d002      	beq.n	d38 <_wdt_init+0x2c>
		return ERR_DENIED;
     d32:	f06f 0010 	mvn.w	r0, #16
}
     d36:	bd38      	pop	{r3, r4, r5, pc}
	hri_wdt_wait_for_sync(hw, WDT_SYNCBUSY_ENABLE | WDT_SYNCBUSY_WEN | WDT_SYNCBUSY_ALWAYSON);
     d38:	47a8      	blx	r5
	tmp = ((Wdt *)hw)->CTRLA.reg;
     d3a:	7813      	ldrb	r3, [r2, #0]
	if (hri_wdt_get_CTRLA_ALWAYSON_bit(dev->hw) || hri_wdt_get_CTRLA_ENABLE_bit(dev->hw)) {
     d3c:	f3c3 0440 	ubfx	r4, r3, #1, #1
     d40:	079b      	lsls	r3, r3, #30
     d42:	d4f6      	bmi.n	d32 <_wdt_init+0x26>
	((Wdt *)hw)->CTRLA.reg &= ~WDT_CTRLA_WEN;
     d44:	7813      	ldrb	r3, [r2, #0]
     d46:	f003 03fb 	and.w	r3, r3, #251	@ 0xfb
     d4a:	7013      	strb	r3, [r2, #0]
	hri_wdt_wait_for_sync(hw, WDT_SYNCBUSY_ENABLE | WDT_SYNCBUSY_WEN | WDT_SYNCBUSY_ALWAYSON);
     d4c:	47a8      	blx	r5

static inline void hri_wdt_write_CONFIG_PER_bf(const void *const hw, hri_wdt_config_reg_t data)
{
	uint8_t tmp;
	WDT_CRITICAL_SECTION_ENTER();
	tmp = ((Wdt *)hw)->CONFIG.reg;
     d4e:	7853      	ldrb	r3, [r2, #1]
	tmp &= ~WDT_CONFIG_PER_Msk;
     d50:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
	tmp |= WDT_CONFIG_PER(data);
	((Wdt *)hw)->CONFIG.reg = tmp;
     d54:	7053      	strb	r3, [r2, #1]
	return ERR_NONE;
     d56:	4620      	mov	r0, r4
     d58:	e7ed      	b.n	d36 <_wdt_init+0x2a>
     d5a:	bf00      	nop
     d5c:	00001ab5 	.word	0x00001ab5
     d60:	00003391 	.word	0x00003391
     d64:	00000d05 	.word	0x00000d05

00000d68 <pvPortMalloc>:
static size_t xNextFreeByte = (size_t)0;

/*-----------------------------------------------------------*/

void *pvPortMalloc(size_t xWantedSize)
{
     d68:	b538      	push	{r3, r4, r5, lr}
	static uint8_t *pucAlignedHeap = NULL;

/* Ensure that blocks are always aligned to the required number of bytes. */
#if (portBYTE_ALIGNMENT != 1)
	{
		if (xWantedSize & portBYTE_ALIGNMENT_MASK) {
     d6a:	0743      	lsls	r3, r0, #29
{
     d6c:	4604      	mov	r4, r0
			xWantedSize += (portBYTE_ALIGNMENT - (xWantedSize & portBYTE_ALIGNMENT_MASK));
		}
	}
#endif

	vTaskSuspendAll();
     d6e:	4b0e      	ldr	r3, [pc, #56]	@ (da8 <pvPortMalloc+0x40>)
			xWantedSize += (portBYTE_ALIGNMENT - (xWantedSize & portBYTE_ALIGNMENT_MASK));
     d70:	bf1c      	itt	ne
     d72:	f020 0407 	bicne.w	r4, r0, #7
     d76:	3408      	addne	r4, #8
	vTaskSuspendAll();
     d78:	4798      	blx	r3
	{
		if (pucAlignedHeap == NULL) {
     d7a:	4b0c      	ldr	r3, [pc, #48]	@ (dac <pvPortMalloc+0x44>)
     d7c:	681a      	ldr	r2, [r3, #0]
     d7e:	b91a      	cbnz	r2, d88 <pvPortMalloc+0x20>
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = (uint8_t *)(((portPOINTER_SIZE_TYPE)&ucHeap[portBYTE_ALIGNMENT])
			                             & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));
     d80:	4a0b      	ldr	r2, [pc, #44]	@ (db0 <pvPortMalloc+0x48>)
     d82:	f022 0207 	bic.w	r2, r2, #7
			pucAlignedHeap = (uint8_t *)(((portPOINTER_SIZE_TYPE)&ucHeap[portBYTE_ALIGNMENT])
     d86:	601a      	str	r2, [r3, #0]
		}

		/* Check there is enough room left for the allocation. */
		if (((xNextFreeByte + xWantedSize) < configADJUSTED_HEAP_SIZE)
     d88:	685a      	ldr	r2, [r3, #4]
     d8a:	490a      	ldr	r1, [pc, #40]	@ (db4 <pvPortMalloc+0x4c>)
     d8c:	4414      	add	r4, r2
     d8e:	428c      	cmp	r4, r1
     d90:	d808      	bhi.n	da4 <pvPortMalloc+0x3c>
		    && ((xNextFreeByte + xWantedSize) > xNextFreeByte)) /* Check for overflow. */
     d92:	42a2      	cmp	r2, r4
     d94:	d206      	bcs.n	da4 <pvPortMalloc+0x3c>
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     d96:	681d      	ldr	r5, [r3, #0]
			xNextFreeByte += xWantedSize;
     d98:	605c      	str	r4, [r3, #4]
			pvReturn = pucAlignedHeap + xNextFreeByte;
     d9a:	4415      	add	r5, r2
		}

		traceMALLOC(pvReturn, xWantedSize);
	}
	(void)xTaskResumeAll();
     d9c:	4b06      	ldr	r3, [pc, #24]	@ (db8 <pvPortMalloc+0x50>)
     d9e:	4798      	blx	r3
		}
	}
#endif

	return pvReturn;
}
     da0:	4628      	mov	r0, r5
     da2:	bd38      	pop	{r3, r4, r5, pc}
	void *          pvReturn       = NULL;
     da4:	2500      	movs	r5, #0
     da6:	e7f9      	b.n	d9c <pvPortMalloc+0x34>
     da8:	00002be1 	.word	0x00002be1
     dac:	200004e4 	.word	0x200004e4
     db0:	200004f4 	.word	0x200004f4
     db4:	0001fff7 	.word	0x0001fff7
     db8:	00002cfd 	.word	0x00002cfd

00000dbc <vPortFree>:
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	(void)pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT(pv == NULL);
     dbc:	b140      	cbz	r0, dd0 <vPortFree+0x14>
     dbe:	f04f 0380 	mov.w	r3, #128	@ 0x80
     dc2:	f383 8811 	msr	BASEPRI, r3
     dc6:	f3bf 8f6f 	isb	sy
     dca:	f3bf 8f4f 	dsb	sy
     dce:	e7fe      	b.n	dce <vPortFree+0x12>
}
     dd0:	4770      	bx	lr
	...

00000dd4 <prvIsQueueEmpty>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty(const Queue_t *pxQueue)
{
     dd4:	b510      	push	{r4, lr}
     dd6:	4604      	mov	r4, r0
	BaseType_t xReturn;

	taskENTER_CRITICAL();
     dd8:	4b04      	ldr	r3, [pc, #16]	@ (dec <prvIsQueueEmpty+0x18>)
     dda:	4798      	blx	r3
	{
		if (pxQueue->uxMessagesWaiting == (UBaseType_t)0) {
     ddc:	6ba4      	ldr	r4, [r4, #56]	@ 0x38
			xReturn = pdTRUE;
		} else {
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     dde:	4b04      	ldr	r3, [pc, #16]	@ (df0 <prvIsQueueEmpty+0x1c>)
     de0:	4798      	blx	r3

	return xReturn;
}
     de2:	fab4 f084 	clz	r0, r4
     de6:	0940      	lsrs	r0, r0, #5
     de8:	bd10      	pop	{r4, pc}
     dea:	bf00      	nop
     dec:	00000a85 	.word	0x00000a85
     df0:	00000ac5 	.word	0x00000ac5

00000df4 <prvCopyDataToQueue>:
{
     df4:	b570      	push	{r4, r5, r6, lr}
     df6:	4616      	mov	r6, r2
	if (pxQueue->uxItemSize == (UBaseType_t)0) {
     df8:	6c02      	ldr	r2, [r0, #64]	@ 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     dfa:	6b85      	ldr	r5, [r0, #56]	@ 0x38
{
     dfc:	4604      	mov	r4, r0
	if (pxQueue->uxItemSize == (UBaseType_t)0) {
     dfe:	b942      	cbnz	r2, e12 <prvCopyDataToQueue+0x1e>
			if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
     e00:	6806      	ldr	r6, [r0, #0]
     e02:	b99e      	cbnz	r6, e2c <prvCopyDataToQueue+0x38>
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
     e04:	6840      	ldr	r0, [r0, #4]
     e06:	4b14      	ldr	r3, [pc, #80]	@ (e58 <prvCopyDataToQueue+0x64>)
     e08:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
     e0a:	6066      	str	r6, [r4, #4]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + (UBaseType_t)1;
     e0c:	3501      	adds	r5, #1
     e0e:	63a5      	str	r5, [r4, #56]	@ 0x38
}
     e10:	bd70      	pop	{r4, r5, r6, pc}
	} else if (xPosition == queueSEND_TO_BACK) {
     e12:	4b12      	ldr	r3, [pc, #72]	@ (e5c <prvCopyDataToQueue+0x68>)
     e14:	b966      	cbnz	r6, e30 <prvCopyDataToQueue+0x3c>
		(void)memcpy((void *)pxQueue->pcWriteTo,
     e16:	6880      	ldr	r0, [r0, #8]
     e18:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     e1a:	68a3      	ldr	r3, [r4, #8]
     e1c:	6c22      	ldr	r2, [r4, #64]	@ 0x40
     e1e:	4413      	add	r3, r2
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
     e20:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     e22:	60a3      	str	r3, [r4, #8]
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
     e24:	4293      	cmp	r3, r2
			pxQueue->pcWriteTo = pxQueue->pcHead;
     e26:	bf24      	itt	cs
     e28:	6823      	ldrcs	r3, [r4, #0]
     e2a:	60a3      	strcs	r3, [r4, #8]
	BaseType_t  xReturn = pdFALSE;
     e2c:	2000      	movs	r0, #0
     e2e:	e7ed      	b.n	e0c <prvCopyDataToQueue+0x18>
		(void)memcpy((void *)pxQueue->u.pcReadFrom,
     e30:	68c0      	ldr	r0, [r0, #12]
     e32:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     e34:	6c22      	ldr	r2, [r4, #64]	@ 0x40
     e36:	68e3      	ldr	r3, [r4, #12]
     e38:	4251      	negs	r1, r2
     e3a:	1a9b      	subs	r3, r3, r2
		if (pxQueue->u.pcReadFrom
     e3c:	6822      	ldr	r2, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     e3e:	60e3      	str	r3, [r4, #12]
		if (pxQueue->u.pcReadFrom
     e40:	4293      	cmp	r3, r2
			pxQueue->u.pcReadFrom = (pxQueue->pcTail - pxQueue->uxItemSize);
     e42:	bf3e      	ittt	cc
     e44:	6863      	ldrcc	r3, [r4, #4]
     e46:	185b      	addcc	r3, r3, r1
     e48:	60e3      	strcc	r3, [r4, #12]
		if (xPosition == queueOVERWRITE) {
     e4a:	2e02      	cmp	r6, #2
     e4c:	d1ee      	bne.n	e2c <prvCopyDataToQueue+0x38>
			if (uxMessagesWaiting > (UBaseType_t)0) {
     e4e:	b10d      	cbz	r5, e54 <prvCopyDataToQueue+0x60>
				--uxMessagesWaiting;
     e50:	3d01      	subs	r5, #1
     e52:	e7eb      	b.n	e2c <prvCopyDataToQueue+0x38>
	BaseType_t  xReturn = pdFALSE;
     e54:	4628      	mov	r0, r5
     e56:	e7d9      	b.n	e0c <prvCopyDataToQueue+0x18>
     e58:	00003071 	.word	0x00003071
     e5c:	000032cd 	.word	0x000032cd

00000e60 <prvNotifyQueueSetContainer>:
	/*-----------------------------------------------------------*/

#if (configUSE_QUEUE_SETS == 1)

static BaseType_t prvNotifyQueueSetContainer(const Queue_t *const pxQueue, const BaseType_t xCopyPosition)
{
     e60:	b573      	push	{r0, r1, r4, r5, r6, lr}
	Queue_t *  pxQueueSetContainer = pxQueue->pxQueueSetContainer;
     e62:	6c84      	ldr	r4, [r0, #72]	@ 0x48
{
     e64:	9001      	str	r0, [sp, #4]
     e66:	460a      	mov	r2, r1
	BaseType_t xReturn             = pdFALSE;

	/* This function must be called form a critical section. */

	configASSERT(pxQueueSetContainer);
     e68:	b944      	cbnz	r4, e7c <prvNotifyQueueSetContainer+0x1c>
     e6a:	f04f 0380 	mov.w	r3, #128	@ 0x80
     e6e:	f383 8811 	msr	BASEPRI, r3
     e72:	f3bf 8f6f 	isb	sy
     e76:	f3bf 8f4f 	dsb	sy
     e7a:	e7fe      	b.n	e7a <prvNotifyQueueSetContainer+0x1a>
	configASSERT(pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength);
     e7c:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
     e7e:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
     e80:	4299      	cmp	r1, r3
     e82:	d308      	bcc.n	e96 <prvNotifyQueueSetContainer+0x36>
     e84:	f04f 0380 	mov.w	r3, #128	@ 0x80
     e88:	f383 8811 	msr	BASEPRI, r3
     e8c:	f3bf 8f6f 	isb	sy
     e90:	f3bf 8f4f 	dsb	sy
     e94:	e7fe      	b.n	e94 <prvNotifyQueueSetContainer+0x34>

	if (pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength) {
     e96:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
     e98:	428b      	cmp	r3, r1
     e9a:	d91a      	bls.n	ed2 <prvNotifyQueueSetContainer+0x72>
		const int8_t cTxLock = pxQueueSetContainer->cTxLock;
     e9c:	f894 5045 	ldrb.w	r5, [r4, #69]	@ 0x45

		traceQUEUE_SEND(pxQueueSetContainer);

		/* The data copied is the handle of the queue that contains data. */
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
     ea0:	4b0d      	ldr	r3, [pc, #52]	@ (ed8 <prvNotifyQueueSetContainer+0x78>)
     ea2:	a901      	add	r1, sp, #4
     ea4:	4620      	mov	r0, r4
     ea6:	4798      	blx	r3
		const int8_t cTxLock = pxQueueSetContainer->cTxLock;
     ea8:	b26d      	sxtb	r5, r5

		if (cTxLock == queueUNLOCKED) {
     eaa:	1c6b      	adds	r3, r5, #1
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
     eac:	4606      	mov	r6, r0
		if (cTxLock == queueUNLOCKED) {
     eae:	d10b      	bne.n	ec8 <prvNotifyQueueSetContainer+0x68>
			if (listLIST_IS_EMPTY(&(pxQueueSetContainer->xTasksWaitingToReceive)) == pdFALSE) {
     eb0:	6a63      	ldr	r3, [r4, #36]	@ 0x24
     eb2:	b133      	cbz	r3, ec2 <prvNotifyQueueSetContainer+0x62>
				if (xTaskRemoveFromEventList(&(pxQueueSetContainer->xTasksWaitingToReceive)) != pdFALSE) {
     eb4:	4b09      	ldr	r3, [pc, #36]	@ (edc <prvNotifyQueueSetContainer+0x7c>)
     eb6:	f104 0024 	add.w	r0, r4, #36	@ 0x24
     eba:	4798      	blx	r3
					/* The task waiting has a higher priority. */
					xReturn = pdTRUE;
     ebc:	2800      	cmp	r0, #0
     ebe:	bf18      	it	ne
     ec0:	2601      	movne	r6, #1
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
     ec2:	4630      	mov	r0, r6
     ec4:	b002      	add	sp, #8
     ec6:	bd70      	pop	{r4, r5, r6, pc}
			pxQueueSetContainer->cTxLock = (int8_t)(cTxLock + 1);
     ec8:	3501      	adds	r5, #1
     eca:	b26d      	sxtb	r5, r5
     ecc:	f884 5045 	strb.w	r5, [r4, #69]	@ 0x45
     ed0:	e7f7      	b.n	ec2 <prvNotifyQueueSetContainer+0x62>
	BaseType_t xReturn             = pdFALSE;
     ed2:	2600      	movs	r6, #0
     ed4:	e7f5      	b.n	ec2 <prvNotifyQueueSetContainer+0x62>
     ed6:	bf00      	nop
     ed8:	00000df5 	.word	0x00000df5
     edc:	00002f31 	.word	0x00002f31

00000ee0 <prvCopyDataFromQueue>:
{
     ee0:	4603      	mov	r3, r0
     ee2:	b410      	push	{r4}
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
     ee4:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
{
     ee6:	4608      	mov	r0, r1
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
     ee8:	b16a      	cbz	r2, f06 <prvCopyDataFromQueue+0x26>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     eea:	68dc      	ldr	r4, [r3, #12]
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
     eec:	6859      	ldr	r1, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     eee:	4414      	add	r4, r2
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
     ef0:	428c      	cmp	r4, r1
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     ef2:	bf28      	it	cs
     ef4:	6819      	ldrcs	r1, [r3, #0]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     ef6:	60dc      	str	r4, [r3, #12]
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     ef8:	bf28      	it	cs
     efa:	60d9      	strcs	r1, [r3, #12]
		(void)memcpy((void *)pvBuffer,
     efc:	68d9      	ldr	r1, [r3, #12]
}
     efe:	f85d 4b04 	ldr.w	r4, [sp], #4
		(void)memcpy((void *)pvBuffer,
     f02:	4b02      	ldr	r3, [pc, #8]	@ (f0c <prvCopyDataFromQueue+0x2c>)
     f04:	4718      	bx	r3
}
     f06:	f85d 4b04 	ldr.w	r4, [sp], #4
     f0a:	4770      	bx	lr
     f0c:	000032cd 	.word	0x000032cd

00000f10 <prvUnlockQueue>:
{
     f10:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     f14:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
     f16:	4e1e      	ldr	r6, [pc, #120]	@ (f90 <prvUnlockQueue+0x80>)
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
     f18:	4f1e      	ldr	r7, [pc, #120]	@ (f94 <prvUnlockQueue+0x84>)
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
     f1a:	f8df 8084 	ldr.w	r8, [pc, #132]	@ fa0 <prvUnlockQueue+0x90>
	taskENTER_CRITICAL();
     f1e:	47b0      	blx	r6
		int8_t cTxLock = pxQueue->cTxLock;
     f20:	f894 5045 	ldrb.w	r5, [r4, #69]	@ 0x45
     f24:	46b1      	mov	r9, r6
						vTaskMissedYield();
     f26:	4e1c      	ldr	r6, [pc, #112]	@ (f98 <prvUnlockQueue+0x88>)
		int8_t cTxLock = pxQueue->cTxLock;
     f28:	b26d      	sxtb	r5, r5
		while (cTxLock > queueLOCKED_UNMODIFIED) {
     f2a:	2d00      	cmp	r5, #0
     f2c:	dd0b      	ble.n	f46 <prvUnlockQueue+0x36>
				if (pxQueue->pxQueueSetContainer != NULL) {
     f2e:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
     f30:	b13b      	cbz	r3, f42 <prvUnlockQueue+0x32>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
     f32:	2100      	movs	r1, #0
     f34:	4620      	mov	r0, r4
     f36:	47c0      	blx	r8
     f38:	b100      	cbz	r0, f3c <prvUnlockQueue+0x2c>
						vTaskMissedYield();
     f3a:	47b0      	blx	r6
			--cTxLock;
     f3c:	3d01      	subs	r5, #1
     f3e:	b26d      	sxtb	r5, r5
     f40:	e7f3      	b.n	f2a <prvUnlockQueue+0x1a>
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
     f42:	6a63      	ldr	r3, [r4, #36]	@ 0x24
     f44:	b9cb      	cbnz	r3, f7a <prvUnlockQueue+0x6a>
		pxQueue->cTxLock = queueUNLOCKED;
     f46:	23ff      	movs	r3, #255	@ 0xff
     f48:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
	taskEXIT_CRITICAL();
     f4c:	4e13      	ldr	r6, [pc, #76]	@ (f9c <prvUnlockQueue+0x8c>)
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
     f4e:	f8df 8044 	ldr.w	r8, [pc, #68]	@ f94 <prvUnlockQueue+0x84>
	taskEXIT_CRITICAL();
     f52:	47b0      	blx	r6
	taskENTER_CRITICAL();
     f54:	47c8      	blx	r9
		int8_t cRxLock = pxQueue->cRxLock;
     f56:	f894 5044 	ldrb.w	r5, [r4, #68]	@ 0x44
					vTaskMissedYield();
     f5a:	f8df 903c 	ldr.w	r9, [pc, #60]	@ f98 <prvUnlockQueue+0x88>
		int8_t cRxLock = pxQueue->cRxLock;
     f5e:	b26d      	sxtb	r5, r5
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
     f60:	f104 0710 	add.w	r7, r4, #16
		while (cRxLock > queueLOCKED_UNMODIFIED) {
     f64:	2d00      	cmp	r5, #0
     f66:	dd01      	ble.n	f6c <prvUnlockQueue+0x5c>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
     f68:	6923      	ldr	r3, [r4, #16]
     f6a:	b953      	cbnz	r3, f82 <prvUnlockQueue+0x72>
		pxQueue->cRxLock = queueUNLOCKED;
     f6c:	23ff      	movs	r3, #255	@ 0xff
     f6e:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
	taskEXIT_CRITICAL();
     f72:	4633      	mov	r3, r6
}
     f74:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	taskEXIT_CRITICAL();
     f78:	4718      	bx	r3
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
     f7a:	f104 0024 	add.w	r0, r4, #36	@ 0x24
     f7e:	47b8      	blx	r7
     f80:	e7da      	b.n	f38 <prvUnlockQueue+0x28>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
     f82:	4638      	mov	r0, r7
     f84:	47c0      	blx	r8
     f86:	b100      	cbz	r0, f8a <prvUnlockQueue+0x7a>
					vTaskMissedYield();
     f88:	47c8      	blx	r9
				--cRxLock;
     f8a:	3d01      	subs	r5, #1
     f8c:	b26d      	sxtb	r5, r5
     f8e:	e7e9      	b.n	f64 <prvUnlockQueue+0x54>
     f90:	00000a85 	.word	0x00000a85
     f94:	00002f31 	.word	0x00002f31
     f98:	00003041 	.word	0x00003041
     f9c:	00000ac5 	.word	0x00000ac5
     fa0:	00000e61 	.word	0x00000e61

00000fa4 <xQueueGenericReset>:
{
     fa4:	b538      	push	{r3, r4, r5, lr}
     fa6:	460d      	mov	r5, r1
	configASSERT(pxQueue);
     fa8:	4604      	mov	r4, r0
     faa:	b940      	cbnz	r0, fbe <xQueueGenericReset+0x1a>
     fac:	f04f 0380 	mov.w	r3, #128	@ 0x80
     fb0:	f383 8811 	msr	BASEPRI, r3
     fb4:	f3bf 8f6f 	isb	sy
     fb8:	f3bf 8f4f 	dsb	sy
     fbc:	e7fe      	b.n	fbc <xQueueGenericReset+0x18>
	taskENTER_CRITICAL();
     fbe:	4b18      	ldr	r3, [pc, #96]	@ (1020 <xQueueGenericReset+0x7c>)
     fc0:	4798      	blx	r3
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
     fc2:	e9d4 310f 	ldrd	r3, r1, [r4, #60]	@ 0x3c
     fc6:	6822      	ldr	r2, [r4, #0]
		pxQueue->pcWriteTo         = pxQueue->pcHead;
     fc8:	60a2      	str	r2, [r4, #8]
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
     fca:	434b      	muls	r3, r1
     fcc:	18d0      	adds	r0, r2, r3
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
     fce:	1a5b      	subs	r3, r3, r1
     fd0:	441a      	add	r2, r3
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
     fd2:	6060      	str	r0, [r4, #4]
		pxQueue->cRxLock           = queueUNLOCKED;
     fd4:	23ff      	movs	r3, #255	@ 0xff
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
     fd6:	2000      	movs	r0, #0
     fd8:	63a0      	str	r0, [r4, #56]	@ 0x38
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
     fda:	60e2      	str	r2, [r4, #12]
		pxQueue->cRxLock           = queueUNLOCKED;
     fdc:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
		pxQueue->cTxLock           = queueUNLOCKED;
     fe0:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
		if (xNewQueue == pdFALSE) {
     fe4:	b9a5      	cbnz	r5, 1010 <xQueueGenericReset+0x6c>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
     fe6:	6923      	ldr	r3, [r4, #16]
     fe8:	b173      	cbz	r3, 1008 <xQueueGenericReset+0x64>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
     fea:	4b0e      	ldr	r3, [pc, #56]	@ (1024 <xQueueGenericReset+0x80>)
     fec:	f104 0010 	add.w	r0, r4, #16
     ff0:	4798      	blx	r3
     ff2:	b148      	cbz	r0, 1008 <xQueueGenericReset+0x64>
					queueYIELD_IF_USING_PREEMPTION();
     ff4:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
     ff8:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
     ffc:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
    1000:	f3bf 8f4f 	dsb	sy
    1004:	f3bf 8f6f 	isb	sy
	taskEXIT_CRITICAL();
    1008:	4b07      	ldr	r3, [pc, #28]	@ (1028 <xQueueGenericReset+0x84>)
    100a:	4798      	blx	r3
}
    100c:	2001      	movs	r0, #1
    100e:	bd38      	pop	{r3, r4, r5, pc}
			vListInitialise(&(pxQueue->xTasksWaitingToSend));
    1010:	f104 0010 	add.w	r0, r4, #16
    1014:	4d05      	ldr	r5, [pc, #20]	@ (102c <xQueueGenericReset+0x88>)
    1016:	47a8      	blx	r5
			vListInitialise(&(pxQueue->xTasksWaitingToReceive));
    1018:	f104 0024 	add.w	r0, r4, #36	@ 0x24
    101c:	47a8      	blx	r5
    101e:	e7f3      	b.n	1008 <xQueueGenericReset+0x64>
    1020:	00000a85 	.word	0x00000a85
    1024:	00002f31 	.word	0x00002f31
    1028:	00000ac5 	.word	0x00000ac5
    102c:	00000929 	.word	0x00000929

00001030 <xQueueGenericCreate>:
{
    1030:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1032:	460d      	mov	r5, r1
    1034:	4617      	mov	r7, r2
	configASSERT(uxQueueLength > (UBaseType_t)0);
    1036:	4606      	mov	r6, r0
    1038:	b940      	cbnz	r0, 104c <xQueueGenericCreate+0x1c>
    103a:	f04f 0380 	mov.w	r3, #128	@ 0x80
    103e:	f383 8811 	msr	BASEPRI, r3
    1042:	f3bf 8f6f 	isb	sy
    1046:	f3bf 8f4f 	dsb	sy
    104a:	e7fe      	b.n	104a <xQueueGenericCreate+0x1a>
		xQueueSizeInBytes = (size_t)(
    104c:	4348      	muls	r0, r1
	pxNewQueue = (Queue_t *)pvPortMalloc(sizeof(Queue_t) + xQueueSizeInBytes);
    104e:	4b0b      	ldr	r3, [pc, #44]	@ (107c <xQueueGenericCreate+0x4c>)
    1050:	3054      	adds	r0, #84	@ 0x54
    1052:	4798      	blx	r3
	if (pxNewQueue != NULL) {
    1054:	4604      	mov	r4, r0
    1056:	b168      	cbz	r0, 1074 <xQueueGenericCreate+0x44>
	if (uxItemSize == (UBaseType_t)0) {
    1058:	b175      	cbz	r5, 1078 <xQueueGenericCreate+0x48>
		pucQueueStorage = ((uint8_t *)pxNewQueue) + sizeof(Queue_t);
    105a:	f100 0354 	add.w	r3, r0, #84	@ 0x54
		pxNewQueue->pcHead = (int8_t *)pucQueueStorage;
    105e:	6023      	str	r3, [r4, #0]
	pxNewQueue->uxItemSize = uxItemSize;
    1060:	e9c4 650f 	strd	r6, r5, [r4, #60]	@ 0x3c
	(void)xQueueGenericReset(pxNewQueue, pdTRUE);
    1064:	4b06      	ldr	r3, [pc, #24]	@ (1080 <xQueueGenericCreate+0x50>)
    1066:	2101      	movs	r1, #1
    1068:	4620      	mov	r0, r4
    106a:	4798      	blx	r3
		pxNewQueue->pxQueueSetContainer = NULL;
    106c:	2300      	movs	r3, #0
		pxNewQueue->ucQueueType = ucQueueType;
    106e:	f884 7050 	strb.w	r7, [r4, #80]	@ 0x50
		pxNewQueue->pxQueueSetContainer = NULL;
    1072:	64a3      	str	r3, [r4, #72]	@ 0x48
}
    1074:	4620      	mov	r0, r4
    1076:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		pxNewQueue->pcHead = (int8_t *)pxNewQueue;
    1078:	4603      	mov	r3, r0
    107a:	e7f0      	b.n	105e <xQueueGenericCreate+0x2e>
    107c:	00000d69 	.word	0x00000d69
    1080:	00000fa5 	.word	0x00000fa5

00001084 <xQueueGenericSend>:
{
    1084:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1088:	b085      	sub	sp, #20
    108a:	4688      	mov	r8, r1
    108c:	9201      	str	r2, [sp, #4]
    108e:	461d      	mov	r5, r3
	configASSERT(pxQueue);
    1090:	4604      	mov	r4, r0
    1092:	b940      	cbnz	r0, 10a6 <xQueueGenericSend+0x22>
    1094:	f04f 0380 	mov.w	r3, #128	@ 0x80
    1098:	f383 8811 	msr	BASEPRI, r3
    109c:	f3bf 8f6f 	isb	sy
    10a0:	f3bf 8f4f 	dsb	sy
    10a4:	e7fe      	b.n	10a4 <xQueueGenericSend+0x20>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    10a6:	b951      	cbnz	r1, 10be <xQueueGenericSend+0x3a>
    10a8:	6c03      	ldr	r3, [r0, #64]	@ 0x40
    10aa:	b143      	cbz	r3, 10be <xQueueGenericSend+0x3a>
    10ac:	f04f 0380 	mov.w	r3, #128	@ 0x80
    10b0:	f383 8811 	msr	BASEPRI, r3
    10b4:	f3bf 8f6f 	isb	sy
    10b8:	f3bf 8f4f 	dsb	sy
    10bc:	e7fe      	b.n	10bc <xQueueGenericSend+0x38>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    10be:	2d02      	cmp	r5, #2
    10c0:	d10b      	bne.n	10da <xQueueGenericSend+0x56>
    10c2:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
    10c4:	2b01      	cmp	r3, #1
    10c6:	d008      	beq.n	10da <xQueueGenericSend+0x56>
    10c8:	f04f 0380 	mov.w	r3, #128	@ 0x80
    10cc:	f383 8811 	msr	BASEPRI, r3
    10d0:	f3bf 8f6f 	isb	sy
    10d4:	f3bf 8f4f 	dsb	sy
    10d8:	e7fe      	b.n	10d8 <xQueueGenericSend+0x54>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    10da:	4b43      	ldr	r3, [pc, #268]	@ (11e8 <xQueueGenericSend+0x164>)
    10dc:	4798      	blx	r3
    10de:	4607      	mov	r7, r0
    10e0:	b1b8      	cbz	r0, 1112 <xQueueGenericSend+0x8e>
    10e2:	2700      	movs	r7, #0
		taskENTER_CRITICAL();
    10e4:	f8df 9128 	ldr.w	r9, [pc, #296]	@ 1210 <xQueueGenericSend+0x18c>
    10e8:	4e40      	ldr	r6, [pc, #256]	@ (11ec <xQueueGenericSend+0x168>)
    10ea:	46ca      	mov	sl, r9
    10ec:	47c8      	blx	r9
			if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    10ee:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
    10f0:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
    10f2:	429a      	cmp	r2, r3
    10f4:	d219      	bcs.n	112a <xQueueGenericSend+0xa6>
				xYieldRequired = prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    10f6:	4b3e      	ldr	r3, [pc, #248]	@ (11f0 <xQueueGenericSend+0x16c>)
    10f8:	462a      	mov	r2, r5
    10fa:	4641      	mov	r1, r8
    10fc:	4620      	mov	r0, r4
    10fe:	4798      	blx	r3
					if (pxQueue->pxQueueSetContainer != NULL) {
    1100:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
    1102:	b9cb      	cbnz	r3, 1138 <xQueueGenericSend+0xb4>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    1104:	6a63      	ldr	r3, [r4, #36]	@ 0x24
    1106:	b1db      	cbz	r3, 1140 <xQueueGenericSend+0xbc>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    1108:	4b3a      	ldr	r3, [pc, #232]	@ (11f4 <xQueueGenericSend+0x170>)
    110a:	f104 0024 	add.w	r0, r4, #36	@ 0x24
    110e:	4798      	blx	r3
    1110:	e016      	b.n	1140 <xQueueGenericSend+0xbc>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    1112:	9b01      	ldr	r3, [sp, #4]
    1114:	2b00      	cmp	r3, #0
    1116:	d0e5      	beq.n	10e4 <xQueueGenericSend+0x60>
    1118:	f04f 0380 	mov.w	r3, #128	@ 0x80
    111c:	f383 8811 	msr	BASEPRI, r3
    1120:	f3bf 8f6f 	isb	sy
    1124:	f3bf 8f4f 	dsb	sy
    1128:	e7fe      	b.n	1128 <xQueueGenericSend+0xa4>
			if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    112a:	2d02      	cmp	r5, #2
    112c:	d0e3      	beq.n	10f6 <xQueueGenericSend+0x72>
				if (xTicksToWait == (TickType_t)0) {
    112e:	9b01      	ldr	r3, [sp, #4]
    1130:	b9b3      	cbnz	r3, 1160 <xQueueGenericSend+0xdc>
					taskEXIT_CRITICAL();
    1132:	47b0      	blx	r6
					return errQUEUE_FULL;
    1134:	2000      	movs	r0, #0
    1136:	e010      	b.n	115a <xQueueGenericSend+0xd6>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    1138:	4b2f      	ldr	r3, [pc, #188]	@ (11f8 <xQueueGenericSend+0x174>)
    113a:	4629      	mov	r1, r5
    113c:	4620      	mov	r0, r4
    113e:	4798      	blx	r3
						} else if (xYieldRequired != pdFALSE) {
    1140:	b148      	cbz	r0, 1156 <xQueueGenericSend+0xd2>
							queueYIELD_IF_USING_PREEMPTION();
    1142:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
    1146:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
    114a:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
    114e:	f3bf 8f4f 	dsb	sy
    1152:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
    1156:	47b0      	blx	r6
				return pdPASS;
    1158:	2001      	movs	r0, #1
}
    115a:	b005      	add	sp, #20
    115c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				} else if (xEntryTimeSet == pdFALSE) {
    1160:	b917      	cbnz	r7, 1168 <xQueueGenericSend+0xe4>
					vTaskInternalSetTimeOutState(&xTimeOut);
    1162:	4b26      	ldr	r3, [pc, #152]	@ (11fc <xQueueGenericSend+0x178>)
    1164:	a802      	add	r0, sp, #8
    1166:	4798      	blx	r3
		taskEXIT_CRITICAL();
    1168:	47b0      	blx	r6
		vTaskSuspendAll();
    116a:	4b25      	ldr	r3, [pc, #148]	@ (1200 <xQueueGenericSend+0x17c>)
    116c:	f8df b0a4 	ldr.w	fp, [pc, #164]	@ 1214 <xQueueGenericSend+0x190>
    1170:	4f24      	ldr	r7, [pc, #144]	@ (1204 <xQueueGenericSend+0x180>)
    1172:	4798      	blx	r3
		prvLockQueue(pxQueue);
    1174:	47d0      	blx	sl
    1176:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
    117a:	2bff      	cmp	r3, #255	@ 0xff
    117c:	bf04      	itt	eq
    117e:	2300      	moveq	r3, #0
    1180:	f884 3044 	strbeq.w	r3, [r4, #68]	@ 0x44
    1184:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
    1188:	2bff      	cmp	r3, #255	@ 0xff
    118a:	bf04      	itt	eq
    118c:	2300      	moveq	r3, #0
    118e:	f884 3045 	strbeq.w	r3, [r4, #69]	@ 0x45
    1192:	47b0      	blx	r6
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    1194:	4b1c      	ldr	r3, [pc, #112]	@ (1208 <xQueueGenericSend+0x184>)
    1196:	a901      	add	r1, sp, #4
    1198:	a802      	add	r0, sp, #8
    119a:	4798      	blx	r3
    119c:	bb00      	cbnz	r0, 11e0 <xQueueGenericSend+0x15c>
	taskENTER_CRITICAL();
    119e:	47d0      	blx	sl
		if (pxQueue->uxMessagesWaiting == pxQueue->uxLength) {
    11a0:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
    11a2:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
    11a4:	429a      	cmp	r2, r3
    11a6:	d10b      	bne.n	11c0 <xQueueGenericSend+0x13c>
	taskEXIT_CRITICAL();
    11a8:	47b0      	blx	r6
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToSend), xTicksToWait);
    11aa:	9901      	ldr	r1, [sp, #4]
    11ac:	4b17      	ldr	r3, [pc, #92]	@ (120c <xQueueGenericSend+0x188>)
    11ae:	f104 0010 	add.w	r0, r4, #16
    11b2:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
    11b4:	4620      	mov	r0, r4
    11b6:	47d8      	blx	fp
				if (xTaskResumeAll() == pdFALSE) {
    11b8:	47b8      	blx	r7
    11ba:	b130      	cbz	r0, 11ca <xQueueGenericSend+0x146>
    11bc:	2701      	movs	r7, #1
    11be:	e795      	b.n	10ec <xQueueGenericSend+0x68>
	taskEXIT_CRITICAL();
    11c0:	47b0      	blx	r6
				prvUnlockQueue(pxQueue);
    11c2:	4620      	mov	r0, r4
    11c4:	47d8      	blx	fp
				(void)xTaskResumeAll();
    11c6:	47b8      	blx	r7
    11c8:	e7f8      	b.n	11bc <xQueueGenericSend+0x138>
					portYIELD_WITHIN_API();
    11ca:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
    11ce:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
    11d2:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
    11d6:	f3bf 8f4f 	dsb	sy
    11da:	f3bf 8f6f 	isb	sy
    11de:	e7ed      	b.n	11bc <xQueueGenericSend+0x138>
			prvUnlockQueue(pxQueue);
    11e0:	4620      	mov	r0, r4
    11e2:	47d8      	blx	fp
			(void)xTaskResumeAll();
    11e4:	47b8      	blx	r7
			return errQUEUE_FULL;
    11e6:	e7a5      	b.n	1134 <xQueueGenericSend+0xb0>
    11e8:	00003051 	.word	0x00003051
    11ec:	00000ac5 	.word	0x00000ac5
    11f0:	00000df5 	.word	0x00000df5
    11f4:	00002f31 	.word	0x00002f31
    11f8:	00000e61 	.word	0x00000e61
    11fc:	00002fad 	.word	0x00002fad
    1200:	00002be1 	.word	0x00002be1
    1204:	00002cfd 	.word	0x00002cfd
    1208:	00002fc1 	.word	0x00002fc1
    120c:	00002ead 	.word	0x00002ead
    1210:	00000a85 	.word	0x00000a85
    1214:	00000f11 	.word	0x00000f11

00001218 <xQueueGenericSendFromISR>:
{
    1218:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    121c:	4689      	mov	r9, r1
    121e:	4617      	mov	r7, r2
    1220:	461e      	mov	r6, r3
	configASSERT(pxQueue);
    1222:	4604      	mov	r4, r0
    1224:	b940      	cbnz	r0, 1238 <xQueueGenericSendFromISR+0x20>
    1226:	f04f 0380 	mov.w	r3, #128	@ 0x80
    122a:	f383 8811 	msr	BASEPRI, r3
    122e:	f3bf 8f6f 	isb	sy
    1232:	f3bf 8f4f 	dsb	sy
    1236:	e7fe      	b.n	1236 <xQueueGenericSendFromISR+0x1e>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    1238:	b951      	cbnz	r1, 1250 <xQueueGenericSendFromISR+0x38>
    123a:	6c03      	ldr	r3, [r0, #64]	@ 0x40
    123c:	b143      	cbz	r3, 1250 <xQueueGenericSendFromISR+0x38>
    123e:	f04f 0380 	mov.w	r3, #128	@ 0x80
    1242:	f383 8811 	msr	BASEPRI, r3
    1246:	f3bf 8f6f 	isb	sy
    124a:	f3bf 8f4f 	dsb	sy
    124e:	e7fe      	b.n	124e <xQueueGenericSendFromISR+0x36>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    1250:	2e02      	cmp	r6, #2
    1252:	d10b      	bne.n	126c <xQueueGenericSendFromISR+0x54>
    1254:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
    1256:	2b01      	cmp	r3, #1
    1258:	d008      	beq.n	126c <xQueueGenericSendFromISR+0x54>
    125a:	f04f 0380 	mov.w	r3, #128	@ 0x80
    125e:	f383 8811 	msr	BASEPRI, r3
    1262:	f3bf 8f6f 	isb	sy
    1266:	f3bf 8f4f 	dsb	sy
    126a:	e7fe      	b.n	126a <xQueueGenericSendFromISR+0x52>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    126c:	4b1d      	ldr	r3, [pc, #116]	@ (12e4 <xQueueGenericSendFromISR+0xcc>)
    126e:	4798      	blx	r3
	__asm volatile("	mrs %0, basepri											\n"
    1270:	f3ef 8811 	mrs	r8, BASEPRI
    1274:	f04f 0380 	mov.w	r3, #128	@ 0x80
    1278:	f383 8811 	msr	BASEPRI, r3
    127c:	f3bf 8f6f 	isb	sy
    1280:	f3bf 8f4f 	dsb	sy
		if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    1284:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
    1286:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
    1288:	429a      	cmp	r2, r3
    128a:	d301      	bcc.n	1290 <xQueueGenericSendFromISR+0x78>
    128c:	2e02      	cmp	r6, #2
    128e:	d127      	bne.n	12e0 <xQueueGenericSendFromISR+0xc8>
			const int8_t cTxLock = pxQueue->cTxLock;
    1290:	f894 5045 	ldrb.w	r5, [r4, #69]	@ 0x45
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    1294:	4b14      	ldr	r3, [pc, #80]	@ (12e8 <xQueueGenericSendFromISR+0xd0>)
			const int8_t cTxLock = pxQueue->cTxLock;
    1296:	b26d      	sxtb	r5, r5
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    1298:	4632      	mov	r2, r6
    129a:	4649      	mov	r1, r9
    129c:	4620      	mov	r0, r4
    129e:	4798      	blx	r3
			if (cTxLock == queueUNLOCKED) {
    12a0:	1c6b      	adds	r3, r5, #1
    12a2:	d118      	bne.n	12d6 <xQueueGenericSendFromISR+0xbe>
					if (pxQueue->pxQueueSetContainer != NULL) {
    12a4:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
    12a6:	b173      	cbz	r3, 12c6 <xQueueGenericSendFromISR+0xae>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    12a8:	4b10      	ldr	r3, [pc, #64]	@ (12ec <xQueueGenericSendFromISR+0xd4>)
    12aa:	4631      	mov	r1, r6
    12ac:	4620      	mov	r0, r4
    12ae:	4798      	blx	r3
    12b0:	b920      	cbnz	r0, 12bc <xQueueGenericSendFromISR+0xa4>
			xReturn = pdPASS;
    12b2:	2001      	movs	r0, #1
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
    12b4:	f388 8811 	msr	BASEPRI, r8
}
    12b8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
							if (pxHigherPriorityTaskWoken != NULL) {
    12bc:	2f00      	cmp	r7, #0
    12be:	d0f8      	beq.n	12b2 <xQueueGenericSendFromISR+0x9a>
								*pxHigherPriorityTaskWoken = pdTRUE;
    12c0:	2301      	movs	r3, #1
    12c2:	603b      	str	r3, [r7, #0]
    12c4:	e7f5      	b.n	12b2 <xQueueGenericSendFromISR+0x9a>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    12c6:	6a63      	ldr	r3, [r4, #36]	@ 0x24
    12c8:	2b00      	cmp	r3, #0
    12ca:	d0f2      	beq.n	12b2 <xQueueGenericSendFromISR+0x9a>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    12cc:	4b08      	ldr	r3, [pc, #32]	@ (12f0 <xQueueGenericSendFromISR+0xd8>)
    12ce:	f104 0024 	add.w	r0, r4, #36	@ 0x24
    12d2:	4798      	blx	r3
    12d4:	e7ec      	b.n	12b0 <xQueueGenericSendFromISR+0x98>
				pxQueue->cTxLock = (int8_t)(cTxLock + 1);
    12d6:	3501      	adds	r5, #1
    12d8:	b26d      	sxtb	r5, r5
    12da:	f884 5045 	strb.w	r5, [r4, #69]	@ 0x45
    12de:	e7e8      	b.n	12b2 <xQueueGenericSendFromISR+0x9a>
			xReturn = errQUEUE_FULL;
    12e0:	2000      	movs	r0, #0
    12e2:	e7e7      	b.n	12b4 <xQueueGenericSendFromISR+0x9c>
    12e4:	00000cb1 	.word	0x00000cb1
    12e8:	00000df5 	.word	0x00000df5
    12ec:	00000e61 	.word	0x00000e61
    12f0:	00002f31 	.word	0x00002f31

000012f4 <xQueueReceive>:
{
    12f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    12f8:	b085      	sub	sp, #20
    12fa:	460e      	mov	r6, r1
    12fc:	9201      	str	r2, [sp, #4]
	configASSERT((pxQueue));
    12fe:	4604      	mov	r4, r0
    1300:	b940      	cbnz	r0, 1314 <xQueueReceive+0x20>
	__asm volatile("	mov %0, %1												\n"
    1302:	f04f 0380 	mov.w	r3, #128	@ 0x80
    1306:	f383 8811 	msr	BASEPRI, r3
    130a:	f3bf 8f6f 	isb	sy
    130e:	f3bf 8f4f 	dsb	sy
    1312:	e7fe      	b.n	1312 <xQueueReceive+0x1e>
	configASSERT(!(((pvBuffer) == NULL) && ((pxQueue)->uxItemSize != (UBaseType_t)0U)));
    1314:	b951      	cbnz	r1, 132c <xQueueReceive+0x38>
    1316:	6c03      	ldr	r3, [r0, #64]	@ 0x40
    1318:	b143      	cbz	r3, 132c <xQueueReceive+0x38>
    131a:	f04f 0380 	mov.w	r3, #128	@ 0x80
    131e:	f383 8811 	msr	BASEPRI, r3
    1322:	f3bf 8f6f 	isb	sy
    1326:	f3bf 8f4f 	dsb	sy
    132a:	e7fe      	b.n	132a <xQueueReceive+0x36>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    132c:	4b40      	ldr	r3, [pc, #256]	@ (1430 <xQueueReceive+0x13c>)
    132e:	4798      	blx	r3
    1330:	4605      	mov	r5, r0
    1332:	b338      	cbz	r0, 1384 <xQueueReceive+0x90>
    1334:	2500      	movs	r5, #0
		taskENTER_CRITICAL();
    1336:	f8df 911c 	ldr.w	r9, [pc, #284]	@ 1454 <xQueueReceive+0x160>
    133a:	4f3e      	ldr	r7, [pc, #248]	@ (1434 <xQueueReceive+0x140>)
    133c:	46ca      	mov	sl, r9
    133e:	47c8      	blx	r9
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1340:	f8d4 8038 	ldr.w	r8, [r4, #56]	@ 0x38
			if (uxMessagesWaiting > (UBaseType_t)0) {
    1344:	f1b8 0f00 	cmp.w	r8, #0
    1348:	d028      	beq.n	139c <xQueueReceive+0xa8>
				prvCopyDataFromQueue(pxQueue, pvBuffer);
    134a:	4b3b      	ldr	r3, [pc, #236]	@ (1438 <xQueueReceive+0x144>)
    134c:	4631      	mov	r1, r6
    134e:	4620      	mov	r0, r4
    1350:	4798      	blx	r3
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - (UBaseType_t)1;
    1352:	f108 33ff 	add.w	r3, r8, #4294967295	@ 0xffffffff
    1356:	63a3      	str	r3, [r4, #56]	@ 0x38
				if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    1358:	6923      	ldr	r3, [r4, #16]
    135a:	b173      	cbz	r3, 137a <xQueueReceive+0x86>
					if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    135c:	4b37      	ldr	r3, [pc, #220]	@ (143c <xQueueReceive+0x148>)
    135e:	f104 0010 	add.w	r0, r4, #16
    1362:	4798      	blx	r3
    1364:	b148      	cbz	r0, 137a <xQueueReceive+0x86>
						queueYIELD_IF_USING_PREEMPTION();
    1366:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
    136a:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
    136e:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
    1372:	f3bf 8f4f 	dsb	sy
    1376:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
    137a:	47b8      	blx	r7
				return pdPASS;
    137c:	2001      	movs	r0, #1
}
    137e:	b005      	add	sp, #20
    1380:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    1384:	9b01      	ldr	r3, [sp, #4]
    1386:	2b00      	cmp	r3, #0
    1388:	d0d5      	beq.n	1336 <xQueueReceive+0x42>
    138a:	f04f 0380 	mov.w	r3, #128	@ 0x80
    138e:	f383 8811 	msr	BASEPRI, r3
    1392:	f3bf 8f6f 	isb	sy
    1396:	f3bf 8f4f 	dsb	sy
    139a:	e7fe      	b.n	139a <xQueueReceive+0xa6>
				if (xTicksToWait == (TickType_t)0) {
    139c:	9b01      	ldr	r3, [sp, #4]
    139e:	b913      	cbnz	r3, 13a6 <xQueueReceive+0xb2>
					taskEXIT_CRITICAL();
    13a0:	47b8      	blx	r7
					return errQUEUE_EMPTY;
    13a2:	2000      	movs	r0, #0
    13a4:	e7eb      	b.n	137e <xQueueReceive+0x8a>
				} else if (xEntryTimeSet == pdFALSE) {
    13a6:	b915      	cbnz	r5, 13ae <xQueueReceive+0xba>
					vTaskInternalSetTimeOutState(&xTimeOut);
    13a8:	4b25      	ldr	r3, [pc, #148]	@ (1440 <xQueueReceive+0x14c>)
    13aa:	a802      	add	r0, sp, #8
    13ac:	4798      	blx	r3
		taskEXIT_CRITICAL();
    13ae:	47b8      	blx	r7
		vTaskSuspendAll();
    13b0:	4b24      	ldr	r3, [pc, #144]	@ (1444 <xQueueReceive+0x150>)
    13b2:	f8df b0a4 	ldr.w	fp, [pc, #164]	@ 1458 <xQueueReceive+0x164>
    13b6:	f8df 80a4 	ldr.w	r8, [pc, #164]	@ 145c <xQueueReceive+0x168>
    13ba:	4d23      	ldr	r5, [pc, #140]	@ (1448 <xQueueReceive+0x154>)
    13bc:	4798      	blx	r3
		prvLockQueue(pxQueue);
    13be:	47d0      	blx	sl
    13c0:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
    13c4:	2bff      	cmp	r3, #255	@ 0xff
    13c6:	bf04      	itt	eq
    13c8:	2300      	moveq	r3, #0
    13ca:	f884 3044 	strbeq.w	r3, [r4, #68]	@ 0x44
    13ce:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
    13d2:	2bff      	cmp	r3, #255	@ 0xff
    13d4:	bf04      	itt	eq
    13d6:	2300      	moveq	r3, #0
    13d8:	f884 3045 	strbeq.w	r3, [r4, #69]	@ 0x45
    13dc:	47b8      	blx	r7
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    13de:	4b1b      	ldr	r3, [pc, #108]	@ (144c <xQueueReceive+0x158>)
    13e0:	a901      	add	r1, sp, #4
    13e2:	a802      	add	r0, sp, #8
    13e4:	4798      	blx	r3
    13e6:	b9d8      	cbnz	r0, 1420 <xQueueReceive+0x12c>
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    13e8:	4620      	mov	r0, r4
    13ea:	47d8      	blx	fp
    13ec:	b1a0      	cbz	r0, 1418 <xQueueReceive+0x124>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToReceive), xTicksToWait);
    13ee:	9901      	ldr	r1, [sp, #4]
    13f0:	4b17      	ldr	r3, [pc, #92]	@ (1450 <xQueueReceive+0x15c>)
    13f2:	f104 0024 	add.w	r0, r4, #36	@ 0x24
    13f6:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
    13f8:	4620      	mov	r0, r4
    13fa:	47c0      	blx	r8
				if (xTaskResumeAll() == pdFALSE) {
    13fc:	47a8      	blx	r5
    13fe:	b948      	cbnz	r0, 1414 <xQueueReceive+0x120>
					portYIELD_WITHIN_API();
    1400:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
    1404:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
    1408:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
    140c:	f3bf 8f4f 	dsb	sy
    1410:	f3bf 8f6f 	isb	sy
    1414:	2501      	movs	r5, #1
    1416:	e792      	b.n	133e <xQueueReceive+0x4a>
				prvUnlockQueue(pxQueue);
    1418:	4620      	mov	r0, r4
    141a:	47c0      	blx	r8
				(void)xTaskResumeAll();
    141c:	47a8      	blx	r5
    141e:	e7f9      	b.n	1414 <xQueueReceive+0x120>
			prvUnlockQueue(pxQueue);
    1420:	4620      	mov	r0, r4
    1422:	47c0      	blx	r8
			(void)xTaskResumeAll();
    1424:	47a8      	blx	r5
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    1426:	4620      	mov	r0, r4
    1428:	47d8      	blx	fp
    142a:	2800      	cmp	r0, #0
    142c:	d0f2      	beq.n	1414 <xQueueReceive+0x120>
    142e:	e7b8      	b.n	13a2 <xQueueReceive+0xae>
    1430:	00003051 	.word	0x00003051
    1434:	00000ac5 	.word	0x00000ac5
    1438:	00000ee1 	.word	0x00000ee1
    143c:	00002f31 	.word	0x00002f31
    1440:	00002fad 	.word	0x00002fad
    1444:	00002be1 	.word	0x00002be1
    1448:	00002cfd 	.word	0x00002cfd
    144c:	00002fc1 	.word	0x00002fc1
    1450:	00002ead 	.word	0x00002ead
    1454:	00000a85 	.word	0x00000a85
    1458:	00000dd5 	.word	0x00000dd5
    145c:	00000f11 	.word	0x00000f11

00001460 <vQueueWaitForMessageRestricted>:
{
    1460:	b570      	push	{r4, r5, r6, lr}
    1462:	4604      	mov	r4, r0
	prvLockQueue(pxQueue);
    1464:	4b10      	ldr	r3, [pc, #64]	@ (14a8 <vQueueWaitForMessageRestricted+0x48>)
{
    1466:	460d      	mov	r5, r1
    1468:	4616      	mov	r6, r2
	prvLockQueue(pxQueue);
    146a:	4798      	blx	r3
    146c:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
    1470:	2bff      	cmp	r3, #255	@ 0xff
    1472:	bf04      	itt	eq
    1474:	2300      	moveq	r3, #0
    1476:	f884 3044 	strbeq.w	r3, [r4, #68]	@ 0x44
    147a:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
    147e:	2bff      	cmp	r3, #255	@ 0xff
    1480:	bf04      	itt	eq
    1482:	2300      	moveq	r3, #0
    1484:	f884 3045 	strbeq.w	r3, [r4, #69]	@ 0x45
    1488:	4b08      	ldr	r3, [pc, #32]	@ (14ac <vQueueWaitForMessageRestricted+0x4c>)
    148a:	4798      	blx	r3
	if (pxQueue->uxMessagesWaiting == (UBaseType_t)0U) {
    148c:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
    148e:	b92b      	cbnz	r3, 149c <vQueueWaitForMessageRestricted+0x3c>
		vTaskPlaceOnEventListRestricted(&(pxQueue->xTasksWaitingToReceive), xTicksToWait, xWaitIndefinitely);
    1490:	4b07      	ldr	r3, [pc, #28]	@ (14b0 <vQueueWaitForMessageRestricted+0x50>)
    1492:	4632      	mov	r2, r6
    1494:	4629      	mov	r1, r5
    1496:	f104 0024 	add.w	r0, r4, #36	@ 0x24
    149a:	4798      	blx	r3
	prvUnlockQueue(pxQueue);
    149c:	4620      	mov	r0, r4
    149e:	4b05      	ldr	r3, [pc, #20]	@ (14b4 <vQueueWaitForMessageRestricted+0x54>)
}
    14a0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	prvUnlockQueue(pxQueue);
    14a4:	4718      	bx	r3
    14a6:	bf00      	nop
    14a8:	00000a85 	.word	0x00000a85
    14ac:	00000ac5 	.word	0x00000ac5
    14b0:	00002ee9 	.word	0x00002ee9
    14b4:	00000f11 	.word	0x00000f11

000014b8 <spi_m_sync_init>:
	ASSERT(spi);
	spi->func = (struct _spi_m_sync_hpl_interface *)func;
}

int32_t spi_m_sync_init(struct spi_m_sync_descriptor *spi, void *const hw)
{
    14b8:	b538      	push	{r3, r4, r5, lr}
    14ba:	460d      	mov	r5, r1
	int32_t rc = 0;
	ASSERT(spi && hw);
    14bc:	4604      	mov	r4, r0
    14be:	b110      	cbz	r0, 14c6 <spi_m_sync_init+0xe>
    14c0:	1e08      	subs	r0, r1, #0
    14c2:	bf18      	it	ne
    14c4:	2001      	movne	r0, #1
    14c6:	490a      	ldr	r1, [pc, #40]	@ (14f0 <spi_m_sync_init+0x38>)
    14c8:	4b0a      	ldr	r3, [pc, #40]	@ (14f4 <spi_m_sync_init+0x3c>)
    14ca:	2240      	movs	r2, #64	@ 0x40
    14cc:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
    14ce:	4620      	mov	r0, r4
	rc            = _spi_m_sync_init(&spi->dev, hw);
    14d0:	4b09      	ldr	r3, [pc, #36]	@ (14f8 <spi_m_sync_init+0x40>)
	spi->dev.prvt = (void *)hw;
    14d2:	f840 5f04 	str.w	r5, [r0, #4]!
	rc            = _spi_m_sync_init(&spi->dev, hw);
    14d6:	4629      	mov	r1, r5
    14d8:	4798      	blx	r3

	if (rc < 0) {
    14da:	2800      	cmp	r0, #0
    14dc:	db07      	blt.n	14ee <spi_m_sync_init+0x36>
		return rc;
	}

	spi->flags    = SPI_DEACTIVATE_NEXT;
    14de:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
    14e2:	82a3      	strh	r3, [r4, #20]
	spi->io.read  = _spi_m_sync_io_read;
    14e4:	4b05      	ldr	r3, [pc, #20]	@ (14fc <spi_m_sync_init+0x44>)
    14e6:	6123      	str	r3, [r4, #16]
	spi->io.write = _spi_m_sync_io_write;
    14e8:	4b05      	ldr	r3, [pc, #20]	@ (1500 <spi_m_sync_init+0x48>)
    14ea:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
    14ec:	2000      	movs	r0, #0
}
    14ee:	bd38      	pop	{r3, r4, r5, pc}
    14f0:	000033a6 	.word	0x000033a6
    14f4:	00001ab5 	.word	0x00001ab5
    14f8:	00002625 	.word	0x00002625
    14fc:	00001579 	.word	0x00001579
    1500:	00001541 	.word	0x00001541

00001504 <spi_m_sync_transfer>:

	return spi_m_sync_transfer(spi, &xfer);
}

int32_t spi_m_sync_transfer(struct spi_m_sync_descriptor *spi, const struct spi_xfer *p_xfer)
{
    1504:	b530      	push	{r4, r5, lr}
    1506:	460c      	mov	r4, r1
    1508:	b085      	sub	sp, #20
	struct spi_msg msg;

	ASSERT(spi && p_xfer);
    150a:	4605      	mov	r5, r0
    150c:	b110      	cbz	r0, 1514 <spi_m_sync_transfer+0x10>
    150e:	1e08      	subs	r0, r1, #0
    1510:	bf18      	it	ne
    1512:	2001      	movne	r0, #1
    1514:	22b3      	movs	r2, #179	@ 0xb3
    1516:	4907      	ldr	r1, [pc, #28]	@ (1534 <spi_m_sync_transfer+0x30>)
    1518:	4b07      	ldr	r3, [pc, #28]	@ (1538 <spi_m_sync_transfer+0x34>)
    151a:	4798      	blx	r3

	msg.txbuf = p_xfer->txbuf;
    151c:	6823      	ldr	r3, [r4, #0]
    151e:	9301      	str	r3, [sp, #4]
	msg.rxbuf = p_xfer->rxbuf;
    1520:	6863      	ldr	r3, [r4, #4]
    1522:	9302      	str	r3, [sp, #8]
	msg.size  = p_xfer->size;
    1524:	68a3      	ldr	r3, [r4, #8]
    1526:	9303      	str	r3, [sp, #12]
	return _spi_m_sync_trans(&spi->dev, &msg);
    1528:	a901      	add	r1, sp, #4
    152a:	4b04      	ldr	r3, [pc, #16]	@ (153c <spi_m_sync_transfer+0x38>)
    152c:	1d28      	adds	r0, r5, #4
    152e:	4798      	blx	r3
}
    1530:	b005      	add	sp, #20
    1532:	bd30      	pop	{r4, r5, pc}
    1534:	000033a6 	.word	0x000033a6
    1538:	00001ab5 	.word	0x00001ab5
    153c:	0000275d 	.word	0x0000275d

00001540 <_spi_m_sync_io_write>:
{
    1540:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	ASSERT(io);
    1542:	4604      	mov	r4, r0
    1544:	3800      	subs	r0, #0
    1546:	bf18      	it	ne
    1548:	2001      	movne	r0, #1
{
    154a:	460e      	mov	r6, r1
    154c:	4615      	mov	r5, r2
	ASSERT(io);
    154e:	4907      	ldr	r1, [pc, #28]	@ (156c <_spi_m_sync_io_write+0x2c>)
    1550:	4b07      	ldr	r3, [pc, #28]	@ (1570 <_spi_m_sync_io_write+0x30>)
    1552:	22a3      	movs	r2, #163	@ 0xa3
    1554:	4798      	blx	r3
	xfer.rxbuf = 0;
    1556:	2300      	movs	r3, #0
	xfer.txbuf = (uint8_t *)buf;
    1558:	e9cd 6301 	strd	r6, r3, [sp, #4]
	return spi_m_sync_transfer(spi, &xfer);
    155c:	a901      	add	r1, sp, #4
    155e:	4b05      	ldr	r3, [pc, #20]	@ (1574 <_spi_m_sync_io_write+0x34>)
	xfer.size  = length;
    1560:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
    1562:	f1a4 000c 	sub.w	r0, r4, #12
    1566:	4798      	blx	r3
}
    1568:	b004      	add	sp, #16
    156a:	bd70      	pop	{r4, r5, r6, pc}
    156c:	000033a6 	.word	0x000033a6
    1570:	00001ab5 	.word	0x00001ab5
    1574:	00001505 	.word	0x00001505

00001578 <_spi_m_sync_io_read>:
{
    1578:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	ASSERT(io);
    157a:	4604      	mov	r4, r0
    157c:	3800      	subs	r0, #0
    157e:	bf18      	it	ne
    1580:	2001      	movne	r0, #1
{
    1582:	460e      	mov	r6, r1
    1584:	4615      	mov	r5, r2
	ASSERT(io);
    1586:	4907      	ldr	r1, [pc, #28]	@ (15a4 <_spi_m_sync_io_read+0x2c>)
    1588:	4b07      	ldr	r3, [pc, #28]	@ (15a8 <_spi_m_sync_io_read+0x30>)
    158a:	2287      	movs	r2, #135	@ 0x87
    158c:	4798      	blx	r3
	xfer.txbuf = 0;
    158e:	2300      	movs	r3, #0
    1590:	9301      	str	r3, [sp, #4]
	return spi_m_sync_transfer(spi, &xfer);
    1592:	a901      	add	r1, sp, #4
    1594:	4b05      	ldr	r3, [pc, #20]	@ (15ac <_spi_m_sync_io_read+0x34>)
	xfer.rxbuf = buf;
    1596:	9602      	str	r6, [sp, #8]
	return spi_m_sync_transfer(spi, &xfer);
    1598:	f1a4 000c 	sub.w	r0, r4, #12
	xfer.size  = length;
    159c:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
    159e:	4798      	blx	r3
}
    15a0:	b004      	add	sp, #16
    15a2:	bd70      	pop	{r4, r5, r6, pc}
    15a4:	000033a6 	.word	0x000033a6
    15a8:	00001ab5 	.word	0x00001ab5
    15ac:	00001505 	.word	0x00001505

000015b0 <i2c_m_sync_write>:

/**
 * \brief Sync version of I2C I/O write
 */
static int32_t i2c_m_sync_write(struct io_descriptor *io, const uint8_t *buf, const uint16_t n)
{
    15b0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
    15b2:	8903      	ldrh	r3, [r0, #8]
    15b4:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.len    = n;
	msg.flags  = I2C_M_STOP;
    15b8:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
    15bc:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = (uint8_t *)buf;
    15c0:	9103      	str	r1, [sp, #12]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
    15c2:	4b05      	ldr	r3, [pc, #20]	@ (15d8 <i2c_m_sync_write+0x28>)
	msg.len    = n;
    15c4:	9202      	str	r2, [sp, #8]
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
    15c6:	a901      	add	r1, sp, #4
    15c8:	3814      	subs	r0, #20
{
    15ca:	4614      	mov	r4, r2
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
    15cc:	4798      	blx	r3
	if (ret) {
		return ret;
	}

	return n;
}
    15ce:	2800      	cmp	r0, #0
    15d0:	bf08      	it	eq
    15d2:	4620      	moveq	r0, r4
    15d4:	b004      	add	sp, #16
    15d6:	bd10      	pop	{r4, pc}
    15d8:	000024b5 	.word	0x000024b5

000015dc <i2c_m_sync_read>:
{
    15dc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	msg.addr   = i2c->slave_addr;
    15de:	8903      	ldrh	r3, [r0, #8]
    15e0:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
    15e4:	f248 0301 	movw	r3, #32769	@ 0x8001
    15e8:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = buf;
    15ec:	9103      	str	r1, [sp, #12]
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
    15ee:	4b05      	ldr	r3, [pc, #20]	@ (1604 <i2c_m_sync_read+0x28>)
	msg.len    = n;
    15f0:	9202      	str	r2, [sp, #8]
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
    15f2:	a901      	add	r1, sp, #4
    15f4:	3814      	subs	r0, #20
{
    15f6:	4614      	mov	r4, r2
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
    15f8:	4798      	blx	r3
}
    15fa:	2800      	cmp	r0, #0
    15fc:	bf08      	it	eq
    15fe:	4620      	moveq	r0, r4
    1600:	b004      	add	sp, #16
    1602:	bd10      	pop	{r4, pc}
    1604:	000024b5 	.word	0x000024b5

00001608 <i2c_m_sync_init>:

/**
 * \brief Sync version of i2c initialize
 */
int32_t i2c_m_sync_init(struct i2c_m_sync_desc *i2c, void *hw)
{
    1608:	b538      	push	{r3, r4, r5, lr}
	int32_t init_status;
	ASSERT(i2c);
    160a:	4604      	mov	r4, r0
    160c:	3800      	subs	r0, #0
    160e:	bf18      	it	ne
    1610:	2001      	movne	r0, #1
    1612:	4b07      	ldr	r3, [pc, #28]	@ (1630 <i2c_m_sync_init+0x28>)
{
    1614:	460d      	mov	r5, r1
	ASSERT(i2c);
    1616:	225e      	movs	r2, #94	@ 0x5e
    1618:	4906      	ldr	r1, [pc, #24]	@ (1634 <i2c_m_sync_init+0x2c>)
    161a:	4798      	blx	r3

	init_status = _i2c_m_sync_init(&i2c->device, hw);
    161c:	4b06      	ldr	r3, [pc, #24]	@ (1638 <i2c_m_sync_init+0x30>)
    161e:	4629      	mov	r1, r5
    1620:	4620      	mov	r0, r4
    1622:	4798      	blx	r3
	if (init_status) {
    1624:	b918      	cbnz	r0, 162e <i2c_m_sync_init+0x26>
		return init_status;
	}

	/* Init I/O */
	i2c->io.read  = i2c_m_sync_read;
    1626:	4b05      	ldr	r3, [pc, #20]	@ (163c <i2c_m_sync_init+0x34>)
    1628:	61a3      	str	r3, [r4, #24]
	i2c->io.write = i2c_m_sync_write;
    162a:	4b05      	ldr	r3, [pc, #20]	@ (1640 <i2c_m_sync_init+0x38>)
    162c:	6163      	str	r3, [r4, #20]

	return ERR_NONE;
}
    162e:	bd38      	pop	{r3, r4, r5, pc}
    1630:	00001ab5 	.word	0x00001ab5
    1634:	000033c2 	.word	0x000033c2
    1638:	00002485 	.word	0x00002485
    163c:	000015dd 	.word	0x000015dd
    1640:	000015b1 	.word	0x000015b1

00001644 <prvInsertTimerInActiveList>:
	BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xNextExpiryTime);
	listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);

	if (xNextExpiryTime <= xTimeNow) {
    1644:	4291      	cmp	r1, r2
{
    1646:	b508      	push	{r3, lr}
	listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xNextExpiryTime);
    1648:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    164a:	6100      	str	r0, [r0, #16]
	if (xNextExpiryTime <= xTimeNow) {
    164c:	d80a      	bhi.n	1664 <prvInsertTimerInActiveList+0x20>
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if (((TickType_t)(xTimeNow - xCommandTime))
    164e:	1ad2      	subs	r2, r2, r3
    1650:	6983      	ldr	r3, [r0, #24]
    1652:	429a      	cmp	r2, r3
    1654:	d20e      	bcs.n	1674 <prvInsertTimerInActiveList+0x30>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		} else {
			vListInsert(pxOverflowTimerList, &(pxTimer->xTimerListItem));
    1656:	4b08      	ldr	r3, [pc, #32]	@ (1678 <prvInsertTimerInActiveList+0x34>)
    1658:	1d01      	adds	r1, r0, #4
    165a:	6818      	ldr	r0, [r3, #0]
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		} else {
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    165c:	4b07      	ldr	r3, [pc, #28]	@ (167c <prvInsertTimerInActiveList+0x38>)
    165e:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
    1660:	2000      	movs	r0, #0
		}
	}

	return xProcessTimerNow;
}
    1662:	bd08      	pop	{r3, pc}
		if ((xTimeNow < xCommandTime) && (xNextExpiryTime >= xCommandTime)) {
    1664:	429a      	cmp	r2, r3
    1666:	d201      	bcs.n	166c <prvInsertTimerInActiveList+0x28>
    1668:	4299      	cmp	r1, r3
    166a:	d203      	bcs.n	1674 <prvInsertTimerInActiveList+0x30>
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    166c:	4b02      	ldr	r3, [pc, #8]	@ (1678 <prvInsertTimerInActiveList+0x34>)
    166e:	1d01      	adds	r1, r0, #4
    1670:	6858      	ldr	r0, [r3, #4]
    1672:	e7f3      	b.n	165c <prvInsertTimerInActiveList+0x18>
			xProcessTimerNow = pdTRUE;
    1674:	2001      	movs	r0, #1
	return xProcessTimerNow;
    1676:	e7f4      	b.n	1662 <prvInsertTimerInActiveList+0x1e>
    1678:	200204ec 	.word	0x200204ec
    167c:	0000095b 	.word	0x0000095b

00001680 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue(void)
{
    1680:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if (xTimerQueue == NULL) {
    1684:	4c0d      	ldr	r4, [pc, #52]	@ (16bc <prvCheckForValidListAndQueue+0x3c>)
	taskENTER_CRITICAL();
    1686:	4b0e      	ldr	r3, [pc, #56]	@ (16c0 <prvCheckForValidListAndQueue+0x40>)
    1688:	4798      	blx	r3
		if (xTimerQueue == NULL) {
    168a:	68a5      	ldr	r5, [r4, #8]
    168c:	b98d      	cbnz	r5, 16b2 <prvCheckForValidListAndQueue+0x32>
			vListInitialise(&xActiveTimerList1);
    168e:	f104 070c 	add.w	r7, r4, #12
    1692:	f8df 8038 	ldr.w	r8, [pc, #56]	@ 16cc <prvCheckForValidListAndQueue+0x4c>
    1696:	4638      	mov	r0, r7
			vListInitialise(&xActiveTimerList2);
    1698:	f104 0620 	add.w	r6, r4, #32
			vListInitialise(&xActiveTimerList1);
    169c:	47c0      	blx	r8
			vListInitialise(&xActiveTimerList2);
    169e:	4630      	mov	r0, r6
    16a0:	47c0      	blx	r8
				                                 &(ucStaticTimerQueueStorage[0]),
				                                 &xStaticTimerQueue);
			}
#else
			{
				xTimerQueue = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    16a2:	4b08      	ldr	r3, [pc, #32]	@ (16c4 <prvCheckForValidListAndQueue+0x44>)
    16a4:	462a      	mov	r2, r5
    16a6:	210c      	movs	r1, #12
    16a8:	2002      	movs	r0, #2
			pxOverflowTimerList = &xActiveTimerList2;
    16aa:	e9c4 6700 	strd	r6, r7, [r4]
				xTimerQueue = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    16ae:	4798      	blx	r3
    16b0:	60a0      	str	r0, [r4, #8]
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
}
    16b2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	taskEXIT_CRITICAL();
    16b6:	4b04      	ldr	r3, [pc, #16]	@ (16c8 <prvCheckForValidListAndQueue+0x48>)
    16b8:	4718      	bx	r3
    16ba:	bf00      	nop
    16bc:	200204ec 	.word	0x200204ec
    16c0:	00000a85 	.word	0x00000a85
    16c4:	00001031 	.word	0x00001031
    16c8:	00000ac5 	.word	0x00000ac5
    16cc:	00000929 	.word	0x00000929

000016d0 <xTimerCreateTimerTask>:
	prvCheckForValidListAndQueue();
    16d0:	4b0e      	ldr	r3, [pc, #56]	@ (170c <xTimerCreateTimerTask+0x3c>)
{
    16d2:	b513      	push	{r0, r1, r4, lr}
	prvCheckForValidListAndQueue();
    16d4:	4798      	blx	r3
	if (xTimerQueue != NULL) {
    16d6:	4b0e      	ldr	r3, [pc, #56]	@ (1710 <xTimerCreateTimerTask+0x40>)
    16d8:	689a      	ldr	r2, [r3, #8]
    16da:	b942      	cbnz	r2, 16ee <xTimerCreateTimerTask+0x1e>
    16dc:	f04f 0380 	mov.w	r3, #128	@ 0x80
    16e0:	f383 8811 	msr	BASEPRI, r3
    16e4:	f3bf 8f6f 	isb	sy
    16e8:	f3bf 8f4f 	dsb	sy
	configASSERT(xReturn);
    16ec:	e7fe      	b.n	16ec <xTimerCreateTimerTask+0x1c>
			xReturn = xTaskCreate(prvTimerTask,
    16ee:	3334      	adds	r3, #52	@ 0x34
    16f0:	9301      	str	r3, [sp, #4]
    16f2:	2302      	movs	r3, #2
    16f4:	9300      	str	r3, [sp, #0]
    16f6:	4907      	ldr	r1, [pc, #28]	@ (1714 <xTimerCreateTimerTask+0x44>)
    16f8:	4807      	ldr	r0, [pc, #28]	@ (1718 <xTimerCreateTimerTask+0x48>)
    16fa:	4c08      	ldr	r4, [pc, #32]	@ (171c <xTimerCreateTimerTask+0x4c>)
    16fc:	2300      	movs	r3, #0
    16fe:	2240      	movs	r2, #64	@ 0x40
    1700:	47a0      	blx	r4
	configASSERT(xReturn);
    1702:	2800      	cmp	r0, #0
    1704:	d0ea      	beq.n	16dc <xTimerCreateTimerTask+0xc>
}
    1706:	b002      	add	sp, #8
    1708:	bd10      	pop	{r4, pc}
    170a:	bf00      	nop
    170c:	00001681 	.word	0x00001681
    1710:	200204ec 	.word	0x200204ec
    1714:	000033de 	.word	0x000033de
    1718:	00001825 	.word	0x00001825
    171c:	000029c9 	.word	0x000029c9

00001720 <xTimerGenericCommand>:
{
    1720:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    1722:	4616      	mov	r6, r2
	configASSERT(xTimer);
    1724:	4604      	mov	r4, r0
{
    1726:	461a      	mov	r2, r3
	configASSERT(xTimer);
    1728:	b940      	cbnz	r0, 173c <xTimerGenericCommand+0x1c>
    172a:	f04f 0380 	mov.w	r3, #128	@ 0x80
    172e:	f383 8811 	msr	BASEPRI, r3
    1732:	f3bf 8f6f 	isb	sy
    1736:	f3bf 8f4f 	dsb	sy
    173a:	e7fe      	b.n	173a <xTimerGenericCommand+0x1a>
	if (xTimerQueue != NULL) {
    173c:	4d0d      	ldr	r5, [pc, #52]	@ (1774 <xTimerGenericCommand+0x54>)
    173e:	68a8      	ldr	r0, [r5, #8]
    1740:	b188      	cbz	r0, 1766 <xTimerGenericCommand+0x46>
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    1742:	2905      	cmp	r1, #5
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    1744:	e9cd 1601 	strd	r1, r6, [sp, #4]
		xMessage.u.xTimerParameters.pxTimer       = (Timer_t *)xTimer;
    1748:	9403      	str	r4, [sp, #12]
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    174a:	dc0e      	bgt.n	176a <xTimerGenericCommand+0x4a>
			if (xTaskGetSchedulerState() == taskSCHEDULER_RUNNING) {
    174c:	4b0a      	ldr	r3, [pc, #40]	@ (1778 <xTimerGenericCommand+0x58>)
    174e:	4c0b      	ldr	r4, [pc, #44]	@ (177c <xTimerGenericCommand+0x5c>)
    1750:	4798      	blx	r3
    1752:	2802      	cmp	r0, #2
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, xTicksToWait);
    1754:	f04f 0300 	mov.w	r3, #0
    1758:	bf08      	it	eq
    175a:	9a08      	ldreq	r2, [sp, #32]
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, tmrNO_DELAY);
    175c:	68a8      	ldr	r0, [r5, #8]
    175e:	bf18      	it	ne
    1760:	461a      	movne	r2, r3
    1762:	a901      	add	r1, sp, #4
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    1764:	47a0      	blx	r4
}
    1766:	b004      	add	sp, #16
    1768:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    176a:	4c05      	ldr	r4, [pc, #20]	@ (1780 <xTimerGenericCommand+0x60>)
    176c:	2300      	movs	r3, #0
    176e:	a901      	add	r1, sp, #4
    1770:	e7f8      	b.n	1764 <xTimerGenericCommand+0x44>
    1772:	bf00      	nop
    1774:	200204ec 	.word	0x200204ec
    1778:	00003051 	.word	0x00003051
    177c:	00001085 	.word	0x00001085
    1780:	00001219 	.word	0x00001219

00001784 <prvSampleTimeNow>:
{
    1784:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	xTimeNow = xTaskGetTickCount();
    1788:	4b21      	ldr	r3, [pc, #132]	@ (1810 <prvSampleTimeNow+0x8c>)
	if (xTimeNow < xLastTime) {
    178a:	4d22      	ldr	r5, [pc, #136]	@ (1814 <prvSampleTimeNow+0x90>)
{
    178c:	4607      	mov	r7, r0
	xTimeNow = xTaskGetTickCount();
    178e:	4798      	blx	r3
	if (xTimeNow < xLastTime) {
    1790:	6bab      	ldr	r3, [r5, #56]	@ 0x38
    1792:	4283      	cmp	r3, r0
	xTimeNow = xTaskGetTickCount();
    1794:	4606      	mov	r6, r0
	if (xTimeNow < xLastTime) {
    1796:	d909      	bls.n	17ac <prvSampleTimeNow+0x28>
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    1798:	f8df 8084 	ldr.w	r8, [pc, #132]	@ 1820 <prvSampleTimeNow+0x9c>
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    179c:	686b      	ldr	r3, [r5, #4]
    179e:	681a      	ldr	r2, [r3, #0]
    17a0:	b95a      	cbnz	r2, 17ba <prvSampleTimeNow+0x36>
	pxCurrentTimerList  = pxOverflowTimerList;
    17a2:	682a      	ldr	r2, [r5, #0]
	pxOverflowTimerList = pxTemp;
    17a4:	e9c5 3200 	strd	r3, r2, [r5]
		*pxTimerListsWereSwitched = pdTRUE;
    17a8:	2301      	movs	r3, #1
    17aa:	e000      	b.n	17ae <prvSampleTimeNow+0x2a>
    17ac:	2300      	movs	r3, #0
}
    17ae:	4630      	mov	r0, r6
		*pxTimerListsWereSwitched = pdTRUE;
    17b0:	603b      	str	r3, [r7, #0]
	xLastTime = xTimeNow;
    17b2:	63ae      	str	r6, [r5, #56]	@ 0x38
}
    17b4:	b002      	add	sp, #8
    17b6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    17ba:	68db      	ldr	r3, [r3, #12]
		pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    17bc:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    17be:	f8d3 9000 	ldr.w	r9, [r3]
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    17c2:	f104 0a04 	add.w	sl, r4, #4
    17c6:	4650      	mov	r0, sl
    17c8:	47c0      	blx	r8
		pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    17ca:	6a63      	ldr	r3, [r4, #36]	@ 0x24
    17cc:	4620      	mov	r0, r4
    17ce:	4798      	blx	r3
		if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    17d0:	69e3      	ldr	r3, [r4, #28]
    17d2:	2b01      	cmp	r3, #1
    17d4:	d1e2      	bne.n	179c <prvSampleTimeNow+0x18>
			xReloadTime = (xNextExpireTime + pxTimer->xTimerPeriodInTicks);
    17d6:	69a3      	ldr	r3, [r4, #24]
    17d8:	444b      	add	r3, r9
			if (xReloadTime > xNextExpireTime) {
    17da:	4599      	cmp	r9, r3
    17dc:	d206      	bcs.n	17ec <prvSampleTimeNow+0x68>
				listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xReloadTime);
    17de:	6063      	str	r3, [r4, #4]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    17e0:	6868      	ldr	r0, [r5, #4]
    17e2:	4b0d      	ldr	r3, [pc, #52]	@ (1818 <prvSampleTimeNow+0x94>)
				listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    17e4:	6124      	str	r4, [r4, #16]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    17e6:	4651      	mov	r1, sl
    17e8:	4798      	blx	r3
    17ea:	e7d7      	b.n	179c <prvSampleTimeNow+0x18>
				    = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    17ec:	2300      	movs	r3, #0
    17ee:	4620      	mov	r0, r4
    17f0:	9300      	str	r3, [sp, #0]
    17f2:	4c0a      	ldr	r4, [pc, #40]	@ (181c <prvSampleTimeNow+0x98>)
    17f4:	464a      	mov	r2, r9
    17f6:	4619      	mov	r1, r3
    17f8:	47a0      	blx	r4
				configASSERT(xResult);
    17fa:	2800      	cmp	r0, #0
    17fc:	d1ce      	bne.n	179c <prvSampleTimeNow+0x18>
    17fe:	f04f 0380 	mov.w	r3, #128	@ 0x80
    1802:	f383 8811 	msr	BASEPRI, r3
    1806:	f3bf 8f6f 	isb	sy
    180a:	f3bf 8f4f 	dsb	sy
    180e:	e7fe      	b.n	180e <prvSampleTimeNow+0x8a>
    1810:	00002bf5 	.word	0x00002bf5
    1814:	200204ec 	.word	0x200204ec
    1818:	0000095b 	.word	0x0000095b
    181c:	00001721 	.word	0x00001721
    1820:	00000989 	.word	0x00000989

00001824 <prvTimerTask>:
{
    1824:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	*pxListWasEmpty = listLIST_IS_EMPTY(pxCurrentTimerList);
    1828:	4f62      	ldr	r7, [pc, #392]	@ (19b4 <prvTimerTask+0x190>)
	vTaskSuspendAll();
    182a:	f8df a1a8 	ldr.w	sl, [pc, #424]	@ 19d4 <prvTimerTask+0x1b0>
{
    182e:	b087      	sub	sp, #28
	*pxListWasEmpty = listLIST_IS_EMPTY(pxCurrentTimerList);
    1830:	687b      	ldr	r3, [r7, #4]
    1832:	f8d3 b000 	ldr.w	fp, [r3]
	if (*pxListWasEmpty == pdFALSE) {
    1836:	f1bb 0f00 	cmp.w	fp, #0
    183a:	d034      	beq.n	18a6 <prvTimerTask+0x82>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    183c:	68db      	ldr	r3, [r3, #12]
    183e:	681e      	ldr	r6, [r3, #0]
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    1840:	f8df 9194 	ldr.w	r9, [pc, #404]	@ 19d8 <prvTimerTask+0x1b4>
    1844:	4d5c      	ldr	r5, [pc, #368]	@ (19b8 <prvTimerTask+0x194>)
	vTaskSuspendAll();
    1846:	47d0      	blx	sl
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    1848:	a803      	add	r0, sp, #12
    184a:	47c8      	blx	r9
		if (xTimerListsWereSwitched == pdFALSE) {
    184c:	9c03      	ldr	r4, [sp, #12]
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    184e:	4680      	mov	r8, r0
		if (xTimerListsWereSwitched == pdFALSE) {
    1850:	2c00      	cmp	r4, #0
    1852:	d174      	bne.n	193e <prvTimerTask+0x11a>
			if ((xListWasEmpty == pdFALSE) && (xNextExpireTime <= xTimeNow)) {
    1854:	f1bb 0f00 	cmp.w	fp, #0
    1858:	d058      	beq.n	190c <prvTimerTask+0xe8>
    185a:	42b0      	cmp	r0, r6
    185c:	d35b      	bcc.n	1916 <prvTimerTask+0xf2>
				(void)xTaskResumeAll();
    185e:	47a8      	blx	r5
	Timer_t *const pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    1860:	687b      	ldr	r3, [r7, #4]
    1862:	68db      	ldr	r3, [r3, #12]
    1864:	68dd      	ldr	r5, [r3, #12]
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    1866:	4b55      	ldr	r3, [pc, #340]	@ (19bc <prvTimerTask+0x198>)
    1868:	1d28      	adds	r0, r5, #4
    186a:	4798      	blx	r3
	if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    186c:	69eb      	ldr	r3, [r5, #28]
    186e:	2b01      	cmp	r3, #1
    1870:	d11b      	bne.n	18aa <prvTimerTask+0x86>
		if (prvInsertTimerInActiveList(
    1872:	69a9      	ldr	r1, [r5, #24]
    1874:	4642      	mov	r2, r8
    1876:	4633      	mov	r3, r6
    1878:	f8df 8150 	ldr.w	r8, [pc, #336]	@ 19cc <prvTimerTask+0x1a8>
    187c:	4431      	add	r1, r6
    187e:	4628      	mov	r0, r5
    1880:	47c0      	blx	r8
    1882:	b190      	cbz	r0, 18aa <prvTimerTask+0x86>
			xResult = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    1884:	9400      	str	r4, [sp, #0]
    1886:	4623      	mov	r3, r4
    1888:	4621      	mov	r1, r4
    188a:	4632      	mov	r2, r6
    188c:	4c4c      	ldr	r4, [pc, #304]	@ (19c0 <prvTimerTask+0x19c>)
    188e:	4628      	mov	r0, r5
    1890:	47a0      	blx	r4
			configASSERT(xResult);
    1892:	b950      	cbnz	r0, 18aa <prvTimerTask+0x86>
    1894:	f04f 0380 	mov.w	r3, #128	@ 0x80
    1898:	f383 8811 	msr	BASEPRI, r3
    189c:	f3bf 8f6f 	isb	sy
    18a0:	f3bf 8f4f 	dsb	sy
    18a4:	e7fe      	b.n	18a4 <prvTimerTask+0x80>
		xNextExpireTime = (TickType_t)0U;
    18a6:	465e      	mov	r6, fp
    18a8:	e7ca      	b.n	1840 <prvTimerTask+0x1c>
	pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    18aa:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
    18ac:	4628      	mov	r0, r5
    18ae:	4798      	blx	r3
	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
    18b0:	4d44      	ldr	r5, [pc, #272]	@ (19c4 <prvTimerTask+0x1a0>)
    18b2:	68b8      	ldr	r0, [r7, #8]
    18b4:	2200      	movs	r2, #0
    18b6:	a903      	add	r1, sp, #12
    18b8:	47a8      	blx	r5
	       != pdFAIL) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not
    18ba:	2800      	cmp	r0, #0
    18bc:	d0b8      	beq.n	1830 <prvTimerTask+0xc>
		if (xMessage.xMessageID >= (BaseType_t)0) {
    18be:	9b03      	ldr	r3, [sp, #12]
    18c0:	2b00      	cmp	r3, #0
    18c2:	dbf6      	blt.n	18b2 <prvTimerTask+0x8e>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    18c4:	9c05      	ldr	r4, [sp, #20]
			if (listIS_CONTAINED_WITHIN(NULL, &(pxTimer->xTimerListItem))
    18c6:	6963      	ldr	r3, [r4, #20]
    18c8:	b113      	cbz	r3, 18d0 <prvTimerTask+0xac>
				(void)uxListRemove(&(pxTimer->xTimerListItem));
    18ca:	4b3c      	ldr	r3, [pc, #240]	@ (19bc <prvTimerTask+0x198>)
    18cc:	1d20      	adds	r0, r4, #4
    18ce:	4798      	blx	r3
			xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    18d0:	a802      	add	r0, sp, #8
    18d2:	47c8      	blx	r9
			switch (xMessage.xMessageID) {
    18d4:	9b03      	ldr	r3, [sp, #12]
			xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    18d6:	4602      	mov	r2, r0
			switch (xMessage.xMessageID) {
    18d8:	2b09      	cmp	r3, #9
    18da:	d8ea      	bhi.n	18b2 <prvTimerTask+0x8e>
    18dc:	a101      	add	r1, pc, #4	@ (adr r1, 18e4 <prvTimerTask+0xc0>)
    18de:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
    18e2:	bf00      	nop
    18e4:	00001943 	.word	0x00001943
    18e8:	00001943 	.word	0x00001943
    18ec:	00001943 	.word	0x00001943
    18f0:	000018b3 	.word	0x000018b3
    18f4:	00001987 	.word	0x00001987
    18f8:	000019ab 	.word	0x000019ab
    18fc:	00001943 	.word	0x00001943
    1900:	00001943 	.word	0x00001943
    1904:	000018b3 	.word	0x000018b3
    1908:	00001987 	.word	0x00001987
					xListWasEmpty = listLIST_IS_EMPTY(pxOverflowTimerList);
    190c:	683b      	ldr	r3, [r7, #0]
    190e:	681c      	ldr	r4, [r3, #0]
    1910:	fab4 f484 	clz	r4, r4
    1914:	0964      	lsrs	r4, r4, #5
				vQueueWaitForMessageRestricted(xTimerQueue, (xNextExpireTime - xTimeNow), xListWasEmpty);
    1916:	68b8      	ldr	r0, [r7, #8]
    1918:	4b2b      	ldr	r3, [pc, #172]	@ (19c8 <prvTimerTask+0x1a4>)
    191a:	4622      	mov	r2, r4
    191c:	eba6 0108 	sub.w	r1, r6, r8
    1920:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    1922:	47a8      	blx	r5
    1924:	2800      	cmp	r0, #0
    1926:	d1c3      	bne.n	18b0 <prvTimerTask+0x8c>
					portYIELD_WITHIN_API();
    1928:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
    192c:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
    1930:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
    1934:	f3bf 8f4f 	dsb	sy
    1938:	f3bf 8f6f 	isb	sy
    193c:	e7b8      	b.n	18b0 <prvTimerTask+0x8c>
			(void)xTaskResumeAll();
    193e:	47a8      	blx	r5
    1940:	e7b6      	b.n	18b0 <prvTimerTask+0x8c>
				if (prvInsertTimerInActiveList(pxTimer,
    1942:	69a1      	ldr	r1, [r4, #24]
    1944:	9b04      	ldr	r3, [sp, #16]
    1946:	4e21      	ldr	r6, [pc, #132]	@ (19cc <prvTimerTask+0x1a8>)
    1948:	4419      	add	r1, r3
    194a:	4620      	mov	r0, r4
    194c:	47b0      	blx	r6
    194e:	2800      	cmp	r0, #0
    1950:	d0af      	beq.n	18b2 <prvTimerTask+0x8e>
					pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    1952:	6a63      	ldr	r3, [r4, #36]	@ 0x24
    1954:	4620      	mov	r0, r4
    1956:	4798      	blx	r3
					if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    1958:	69e3      	ldr	r3, [r4, #28]
    195a:	2b01      	cmp	r3, #1
    195c:	d1a9      	bne.n	18b2 <prvTimerTask+0x8e>
						xResult = xTimerGenericCommand(pxTimer,
    195e:	69a2      	ldr	r2, [r4, #24]
    1960:	9904      	ldr	r1, [sp, #16]
    1962:	2300      	movs	r3, #0
    1964:	440a      	add	r2, r1
    1966:	4620      	mov	r0, r4
    1968:	9300      	str	r3, [sp, #0]
    196a:	4c15      	ldr	r4, [pc, #84]	@ (19c0 <prvTimerTask+0x19c>)
    196c:	4619      	mov	r1, r3
    196e:	47a0      	blx	r4
						configASSERT(xResult);
    1970:	2800      	cmp	r0, #0
    1972:	d19e      	bne.n	18b2 <prvTimerTask+0x8e>
    1974:	f04f 0380 	mov.w	r3, #128	@ 0x80
    1978:	f383 8811 	msr	BASEPRI, r3
    197c:	f3bf 8f6f 	isb	sy
    1980:	f3bf 8f4f 	dsb	sy
    1984:	e7fe      	b.n	1984 <prvTimerTask+0x160>
				pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    1986:	9904      	ldr	r1, [sp, #16]
    1988:	61a1      	str	r1, [r4, #24]
				configASSERT((pxTimer->xTimerPeriodInTicks > 0));
    198a:	b941      	cbnz	r1, 199e <prvTimerTask+0x17a>
    198c:	f04f 0380 	mov.w	r3, #128	@ 0x80
    1990:	f383 8811 	msr	BASEPRI, r3
    1994:	f3bf 8f6f 	isb	sy
    1998:	f3bf 8f4f 	dsb	sy
    199c:	e7fe      	b.n	199c <prvTimerTask+0x178>
				(void)prvInsertTimerInActiveList(
    199e:	4603      	mov	r3, r0
    19a0:	4401      	add	r1, r0
    19a2:	4620      	mov	r0, r4
    19a4:	4c09      	ldr	r4, [pc, #36]	@ (19cc <prvTimerTask+0x1a8>)
    19a6:	47a0      	blx	r4
				break;
    19a8:	e783      	b.n	18b2 <prvTimerTask+0x8e>
				vPortFree(pxTimer);
    19aa:	4b09      	ldr	r3, [pc, #36]	@ (19d0 <prvTimerTask+0x1ac>)
    19ac:	4620      	mov	r0, r4
    19ae:	4798      	blx	r3
			break;
    19b0:	e77f      	b.n	18b2 <prvTimerTask+0x8e>
    19b2:	bf00      	nop
    19b4:	200204ec 	.word	0x200204ec
    19b8:	00002cfd 	.word	0x00002cfd
    19bc:	00000989 	.word	0x00000989
    19c0:	00001721 	.word	0x00001721
    19c4:	000012f5 	.word	0x000012f5
    19c8:	00001461 	.word	0x00001461
    19cc:	00001645 	.word	0x00001645
    19d0:	00000dbd 	.word	0x00000dbd
    19d4:	00002be1 	.word	0x00002be1
    19d8:	00001785 	.word	0x00001785

000019dc <delay_init>:
/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
	_delay_init(hardware = hw);
    19dc:	4b01      	ldr	r3, [pc, #4]	@ (19e4 <delay_init+0x8>)
    19de:	6018      	str	r0, [r3, #0]
    19e0:	4b01      	ldr	r3, [pc, #4]	@ (19e8 <delay_init+0xc>)
    19e2:	4718      	bx	r3
    19e4:	20020528 	.word	0x20020528
    19e8:	000009a9 	.word	0x000009a9

000019ec <_init_chip>:
}

static inline void hri_nvmctrl_set_CTRLA_RWS_bf(const void *const hw, hri_nvmctrl_ctrla_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLA.reg |= NVMCTRL_CTRLA_RWS(mask);
    19ec:	4a0b      	ldr	r2, [pc, #44]	@ (1a1c <_init_chip+0x30>)
    19ee:	8813      	ldrh	r3, [r2, #0]
    19f0:	b29b      	uxth	r3, r3

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    19f2:	b510      	push	{r4, lr}
    19f4:	8013      	strh	r3, [r2, #0]
	hri_nvmctrl_set_CTRLA_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
    19f6:	4b0a      	ldr	r3, [pc, #40]	@ (1a20 <_init_chip+0x34>)
	_oscctrl_init_sources();
	_mclk_init();
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    19f8:	4c0a      	ldr	r4, [pc, #40]	@ (1a24 <_init_chip+0x38>)
	_osc32kctrl_init_sources();
    19fa:	4798      	blx	r3
	_oscctrl_init_sources();
    19fc:	4b0a      	ldr	r3, [pc, #40]	@ (1a28 <_init_chip+0x3c>)
    19fe:	4798      	blx	r3
	_mclk_init();
    1a00:	4b0a      	ldr	r3, [pc, #40]	@ (1a2c <_init_chip+0x40>)
    1a02:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    1a04:	2008      	movs	r0, #8
    1a06:	47a0      	blx	r4
#endif
	_oscctrl_init_referenced_generators();
    1a08:	4b09      	ldr	r3, [pc, #36]	@ (1a30 <_init_chip+0x44>)
    1a0a:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    1a0c:	f640 70f7 	movw	r0, #4087	@ 0xff7
    1a10:	47a0      	blx	r4
#endif

#if CONF_CMCC_ENABLE
	cache_init();
#endif
}
    1a12:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	cache_init();
    1a16:	4b07      	ldr	r3, [pc, #28]	@ (1a34 <_init_chip+0x48>)
    1a18:	4718      	bx	r3
    1a1a:	bf00      	nop
    1a1c:	41004000 	.word	0x41004000
    1a20:	00001cd5 	.word	0x00001cd5
    1a24:	00001a4d 	.word	0x00001a4d
    1a28:	00001abb 	.word	0x00001abb
    1a2c:	00001c91 	.word	0x00001c91
    1a30:	00001abd 	.word	0x00001abd
    1a34:	00002819 	.word	0x00002819

00001a38 <hri_gclk_wait_for_sync.constprop.0>:
typedef uint32_t hri_gclk_syncbusy_reg_t;
typedef uint8_t  hri_gclk_ctrla_reg_t;

static inline void hri_gclk_wait_for_sync(const void *const hw, hri_gclk_syncbusy_reg_t reg)
{
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    1a38:	4903      	ldr	r1, [pc, #12]	@ (1a48 <hri_gclk_wait_for_sync.constprop.0+0x10>)
    1a3a:	f643 73fd 	movw	r3, #16381	@ 0x3ffd
    1a3e:	684a      	ldr	r2, [r1, #4]
    1a40:	421a      	tst	r2, r3
    1a42:	d1fc      	bne.n	1a3e <hri_gclk_wait_for_sync.constprop.0+0x6>
	};
}
    1a44:	4770      	bx	lr
    1a46:	bf00      	nop
    1a48:	40001c00 	.word	0x40001c00

00001a4c <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
    1a4c:	07c3      	lsls	r3, r0, #31
{
    1a4e:	b510      	push	{r4, lr}
	if (bm & (1ul << 0)) {
    1a50:	d504      	bpl.n	1a5c <_gclk_init_generators_by_fref+0x10>
}

static inline void hri_gclk_write_GENCTRL_reg(const void *const hw, uint8_t index, hri_gclk_genctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENCTRL[index].reg = data;
    1a52:	4b12      	ldr	r3, [pc, #72]	@ (1a9c <_gclk_init_generators_by_fref+0x50>)
    1a54:	4a12      	ldr	r2, [pc, #72]	@ (1aa0 <_gclk_init_generators_by_fref+0x54>)
    1a56:	621a      	str	r2, [r3, #32]
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    1a58:	4b12      	ldr	r3, [pc, #72]	@ (1aa4 <_gclk_init_generators_by_fref+0x58>)
    1a5a:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_0_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_0_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_1_CONFIG == 1
	if (bm & (1ul << 1)) {
    1a5c:	0784      	lsls	r4, r0, #30
    1a5e:	d504      	bpl.n	1a6a <_gclk_init_generators_by_fref+0x1e>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    1a60:	4b0e      	ldr	r3, [pc, #56]	@ (1a9c <_gclk_init_generators_by_fref+0x50>)
    1a62:	4a11      	ldr	r2, [pc, #68]	@ (1aa8 <_gclk_init_generators_by_fref+0x5c>)
    1a64:	625a      	str	r2, [r3, #36]	@ 0x24
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    1a66:	4b0f      	ldr	r3, [pc, #60]	@ (1aa4 <_gclk_init_generators_by_fref+0x58>)
    1a68:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_1_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_1_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_2_CONFIG == 1
	if (bm & (1ul << 2)) {
    1a6a:	0741      	lsls	r1, r0, #29
    1a6c:	d504      	bpl.n	1a78 <_gclk_init_generators_by_fref+0x2c>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    1a6e:	4b0b      	ldr	r3, [pc, #44]	@ (1a9c <_gclk_init_generators_by_fref+0x50>)
    1a70:	4a0e      	ldr	r2, [pc, #56]	@ (1aac <_gclk_init_generators_by_fref+0x60>)
    1a72:	629a      	str	r2, [r3, #40]	@ 0x28
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    1a74:	4b0b      	ldr	r3, [pc, #44]	@ (1aa4 <_gclk_init_generators_by_fref+0x58>)
    1a76:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_2_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_2_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_3_CONFIG == 1
	if (bm & (1ul << 3)) {
    1a78:	0702      	lsls	r2, r0, #28
    1a7a:	d504      	bpl.n	1a86 <_gclk_init_generators_by_fref+0x3a>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    1a7c:	4b07      	ldr	r3, [pc, #28]	@ (1a9c <_gclk_init_generators_by_fref+0x50>)
    1a7e:	4a0c      	ldr	r2, [pc, #48]	@ (1ab0 <_gclk_init_generators_by_fref+0x64>)
    1a80:	62da      	str	r2, [r3, #44]	@ 0x2c
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    1a82:	4b08      	ldr	r3, [pc, #32]	@ (1aa4 <_gclk_init_generators_by_fref+0x58>)
    1a84:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_3_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_3_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_4_CONFIG == 1
	if (bm & (1ul << 4)) {
    1a86:	06c3      	lsls	r3, r0, #27
    1a88:	d506      	bpl.n	1a98 <_gclk_init_generators_by_fref+0x4c>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    1a8a:	4b04      	ldr	r3, [pc, #16]	@ (1a9c <_gclk_init_generators_by_fref+0x50>)
    1a8c:	4a08      	ldr	r2, [pc, #32]	@ (1ab0 <_gclk_init_generators_by_fref+0x64>)
    1a8e:	631a      	str	r2, [r3, #48]	@ 0x30
		        | (CONF_GCLK_GEN_11_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_11_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_11_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_11_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_11_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_11_SOURCE);
	}
#endif
}
    1a90:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    1a94:	4b03      	ldr	r3, [pc, #12]	@ (1aa4 <_gclk_init_generators_by_fref+0x58>)
    1a96:	4718      	bx	r3
    1a98:	bd10      	pop	{r4, pc}
    1a9a:	bf00      	nop
    1a9c:	40001c00 	.word	0x40001c00
    1aa0:	00200106 	.word	0x00200106
    1aa4:	00001a39 	.word	0x00001a39
    1aa8:	00082106 	.word	0x00082106
    1aac:	00011106 	.word	0x00011106
    1ab0:	00010104 	.word	0x00010104

00001ab4 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
    1ab4:	b900      	cbnz	r0, 1ab8 <assert+0x4>
		__asm("BKPT #0");
    1ab6:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
    1ab8:	4770      	bx	lr

00001aba <_oscctrl_init_sources>:
	hri_oscctrl_set_XOSCCTRL_ONDEMAND_bit(hw, 1);
#endif
#endif

	(void)hw;
}
    1aba:	4770      	bx	lr

00001abc <_oscctrl_init_referenced_generators>:
	tmp = ((Gclk *)hw)->GENCTRL[index].reg;
    1abc:	492c      	ldr	r1, [pc, #176]	@ (1b70 <_oscctrl_init_referenced_generators+0xb4>)
    1abe:	6a0b      	ldr	r3, [r1, #32]
	tmp &= ~GCLK_GENCTRL_SRC_Msk;
    1ac0:	f023 030f 	bic.w	r3, r3, #15
	tmp |= GCLK_GENCTRL_SRC(data);
    1ac4:	f043 0304 	orr.w	r3, r3, #4
	((Gclk *)hw)->GENCTRL[index].reg = tmp;
    1ac8:	620b      	str	r3, [r1, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    1aca:	f643 73fd 	movw	r3, #16381	@ 0x3ffd
    1ace:	684a      	ldr	r2, [r1, #4]
    1ad0:	421a      	tst	r2, r3
    1ad2:	d1fc      	bne.n	1ace <_oscctrl_init_referenced_generators+0x12>
	return (((Gclk *)hw)->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL0) >> GCLK_SYNCBUSY_GENCTRL0_Pos;
    1ad4:	684a      	ldr	r2, [r1, #4]
{
	void *hw = (void *)OSCCTRL;

#if CONF_DFLL_CONFIG == 1
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, GCLK_GENCTRL_SRC_OSCULP32K);
	while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
    1ad6:	f012 0204 	ands.w	r2, r2, #4
    1ada:	d1fb      	bne.n	1ad4 <_oscctrl_init_referenced_generators+0x18>
}

static inline void hri_oscctrl_write_DFLLCTRLA_reg(const void *const hw, hri_oscctrl_dfllctrla_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->DFLLCTRLA.reg = data;
    1adc:	4b25      	ldr	r3, [pc, #148]	@ (1b74 <_oscctrl_init_referenced_generators+0xb8>)
    1ade:	771a      	strb	r2, [r3, #28]
}

static inline void hri_oscctrl_write_DFLLMUL_reg(const void *const hw, hri_oscctrl_dfllmul_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->DFLLMUL.reg = data;
    1ae0:	4a25      	ldr	r2, [pc, #148]	@ (1b78 <_oscctrl_init_referenced_generators+0xbc>)
    1ae2:	629a      	str	r2, [r3, #40]	@ 0x28
}

static inline bool hri_oscctrl_get_DFLLSYNC_DFLLMUL_bit(const void *const hw)
{
	uint8_t tmp;
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    1ae4:	f893 202c 	ldrb.w	r2, [r3, #44]	@ 0x2c
#endif

	hri_oscctrl_write_DFLLMUL_reg(hw,
	                              OSCCTRL_DFLLMUL_CSTEP(CONF_DFLL_CSTEP) | OSCCTRL_DFLLMUL_FSTEP(CONF_DFLL_FSTEP)
	                                  | OSCCTRL_DFLLMUL_MUL(CONF_DFLL_MUL));
	while (hri_oscctrl_get_DFLLSYNC_DFLLMUL_bit(hw))
    1ae8:	f3c2 1100 	ubfx	r1, r2, #4, #1
    1aec:	06d2      	lsls	r2, r2, #27
    1aee:	d4f9      	bmi.n	1ae4 <_oscctrl_init_referenced_generators+0x28>
	((Oscctrl *)hw)->DFLLCTRLB.reg = data;
    1af0:	f883 1020 	strb.w	r1, [r3, #32]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    1af4:	4b1f      	ldr	r3, [pc, #124]	@ (1b74 <_oscctrl_init_referenced_generators+0xb8>)
    1af6:	f893 202c 	ldrb.w	r2, [r3, #44]	@ 0x2c
		;

	hri_oscctrl_write_DFLLCTRLB_reg(hw, 0);
	while (hri_oscctrl_get_DFLLSYNC_DFLLCTRLB_bit(hw))
    1afa:	0750      	lsls	r0, r2, #29
    1afc:	d4fb      	bmi.n	1af6 <_oscctrl_init_referenced_generators+0x3a>
	((Oscctrl *)hw)->DFLLCTRLA.reg = data;
    1afe:	2202      	movs	r2, #2
    1b00:	771a      	strb	r2, [r3, #28]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    1b02:	4b1c      	ldr	r3, [pc, #112]	@ (1b74 <_oscctrl_init_referenced_generators+0xb8>)
    1b04:	f893 202c 	ldrb.w	r2, [r3, #44]	@ 0x2c
		;

	tmp = (CONF_DFLL_RUNSTDBY << OSCCTRL_DFLLCTRLA_RUNSTDBY_Pos) | OSCCTRL_DFLLCTRLA_ENABLE;
	hri_oscctrl_write_DFLLCTRLA_reg(hw, tmp);
	while (hri_oscctrl_get_DFLLSYNC_ENABLE_bit(hw))
    1b08:	0791      	lsls	r1, r2, #30
    1b0a:	d4fb      	bmi.n	1b04 <_oscctrl_init_referenced_generators+0x48>
	return ((Oscctrl *)hw)->DFLLVAL.reg;
    1b0c:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
	((Oscctrl *)hw)->DFLLVAL.reg = data;
    1b0e:	625a      	str	r2, [r3, #36]	@ 0x24
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    1b10:	4b18      	ldr	r3, [pc, #96]	@ (1b74 <_oscctrl_init_referenced_generators+0xb8>)
    1b12:	f893 202c 	ldrb.w	r2, [r3, #44]	@ 0x2c

#if CONF_DFLL_OVERWRITE_CALIBRATION == 1
	hri_oscctrl_write_DFLLVAL_reg(hw, OSCCTRL_DFLLVAL_COARSE(CONF_DFLL_COARSE) | OSCCTRL_DFLLVAL_FINE(CONF_DFLL_FINE));
#endif
	hri_oscctrl_write_DFLLVAL_reg(hw, hri_oscctrl_read_DFLLVAL_reg(hw));
	while (hri_oscctrl_get_DFLLSYNC_DFLLVAL_bit(hw))
    1b16:	0712      	lsls	r2, r2, #28
    1b18:	d4fb      	bmi.n	1b12 <_oscctrl_init_referenced_generators+0x56>
	((Oscctrl *)hw)->DFLLCTRLB.reg = data;
    1b1a:	2280      	movs	r2, #128	@ 0x80
    1b1c:	f883 2020 	strb.w	r2, [r3, #32]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    1b20:	4b14      	ldr	r3, [pc, #80]	@ (1b74 <_oscctrl_init_referenced_generators+0xb8>)
    1b22:	f893 202c 	ldrb.w	r2, [r3, #44]	@ 0x2c
	tmp = (CONF_DFLL_WAITLOCK << OSCCTRL_DFLLCTRLB_WAITLOCK_Pos) | (CONF_DFLL_BPLCKC << OSCCTRL_DFLLCTRLB_BPLCKC_Pos)
	      | (CONF_DFLL_QLDIS << OSCCTRL_DFLLCTRLB_QLDIS_Pos) | (CONF_DFLL_CCDIS << OSCCTRL_DFLLCTRLB_CCDIS_Pos)
	      | (CONF_DFLL_USBCRM << OSCCTRL_DFLLCTRLB_USBCRM_Pos) | (CONF_DFLL_LLAW << OSCCTRL_DFLLCTRLB_LLAW_Pos)
	      | (CONF_DFLL_STABLE << OSCCTRL_DFLLCTRLB_STABLE_Pos) | (CONF_DFLL_MODE << OSCCTRL_DFLLCTRLB_MODE_Pos) | 0;
	hri_oscctrl_write_DFLLCTRLB_reg(hw, tmp);
	while (hri_oscctrl_get_DFLLSYNC_DFLLCTRLB_bit(hw))
    1b26:	0750      	lsls	r0, r2, #29
    1b28:	d4fb      	bmi.n	1b22 <_oscctrl_init_referenced_generators+0x66>
	tmp = ((Oscctrl *)hw)->DFLLCTRLB.reg;
    1b2a:	f893 2020 	ldrb.w	r2, [r3, #32]
	                                (CONF_FDPLL1_RUNSTDBY << OSCCTRL_DPLLCTRLA_RUNSTDBY_Pos)
	                                    | (CONF_FDPLL1_ENABLE << OSCCTRL_DPLLCTRLA_ENABLE_Pos));
#endif

#if CONF_DFLL_CONFIG == 1
	if (hri_oscctrl_get_DFLLCTRLB_MODE_bit(hw)) {
    1b2e:	07d1      	lsls	r1, r2, #31
    1b30:	d519      	bpl.n	1b66 <_oscctrl_init_referenced_generators+0xaa>
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    1b32:	691a      	ldr	r2, [r3, #16]
	tmp &= mask;
    1b34:	f402 6210 	and.w	r2, r2, #2304	@ 0x900
		hri_oscctrl_status_reg_t status_mask = OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC;

		while (hri_oscctrl_get_STATUS_reg(hw, status_mask) != status_mask)
    1b38:	f5b2 6f10 	cmp.w	r2, #2304	@ 0x900
    1b3c:	d1f9      	bne.n	1b32 <_oscctrl_init_referenced_generators+0x76>
	return ((Gclk *)hw)->SYNCBUSY.reg;
    1b3e:	4a0c      	ldr	r2, [pc, #48]	@ (1b70 <_oscctrl_init_referenced_generators+0xb4>)
    1b40:	6853      	ldr	r3, [r2, #4]
	hri_oscctrl_set_DPLLCTRLA_ONDEMAND_bit(hw, 1);
#endif
#endif

#if CONF_DFLL_CONFIG == 1
	while (hri_gclk_read_SYNCBUSY_reg(GCLK))
    1b42:	2b00      	cmp	r3, #0
    1b44:	d1fc      	bne.n	1b40 <_oscctrl_init_referenced_generators+0x84>
	tmp = ((Gclk *)hw)->GENCTRL[index].reg;
    1b46:	6a13      	ldr	r3, [r2, #32]
	tmp &= ~GCLK_GENCTRL_SRC_Msk;
    1b48:	f023 030f 	bic.w	r3, r3, #15
	tmp |= GCLK_GENCTRL_SRC(data);
    1b4c:	f043 0306 	orr.w	r3, r3, #6
	((Gclk *)hw)->GENCTRL[index].reg = tmp;
    1b50:	6213      	str	r3, [r2, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    1b52:	f643 73fd 	movw	r3, #16381	@ 0x3ffd
    1b56:	6851      	ldr	r1, [r2, #4]
    1b58:	4219      	tst	r1, r3
    1b5a:	d1fc      	bne.n	1b56 <_oscctrl_init_referenced_generators+0x9a>
	return (((Gclk *)hw)->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL0) >> GCLK_SYNCBUSY_GENCTRL0_Pos;
    1b5c:	4a04      	ldr	r2, [pc, #16]	@ (1b70 <_oscctrl_init_referenced_generators+0xb4>)
    1b5e:	6853      	ldr	r3, [r2, #4]
		;
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, CONF_GCLK_GEN_0_SOURCE);
	while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
    1b60:	075b      	lsls	r3, r3, #29
    1b62:	d4fc      	bmi.n	1b5e <_oscctrl_init_referenced_generators+0xa2>
		;
#endif
	(void)hw;
}
    1b64:	4770      	bx	lr
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_DFLLRDY) >> OSCCTRL_STATUS_DFLLRDY_Pos;
    1b66:	691a      	ldr	r2, [r3, #16]
		while (!hri_oscctrl_get_STATUS_DFLLRDY_bit(hw))
    1b68:	05d2      	lsls	r2, r2, #23
    1b6a:	d5fc      	bpl.n	1b66 <_oscctrl_init_referenced_generators+0xaa>
    1b6c:	e7e7      	b.n	1b3e <_oscctrl_init_referenced_generators+0x82>
    1b6e:	bf00      	nop
    1b70:	40001c00 	.word	0x40001c00
    1b74:	40001000 	.word	0x40001000
    1b78:	04010000 	.word	0x04010000

00001b7c <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    1b7c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    1b80:	460e      	mov	r6, r1
    1b82:	4615      	mov	r5, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    1b84:	4604      	mov	r4, r0
    1b86:	b118      	cbz	r0, 1b90 <usart_sync_write+0x14>
    1b88:	b329      	cbz	r1, 1bd6 <usart_sync_write+0x5a>
    1b8a:	1e10      	subs	r0, r2, #0
    1b8c:	bf18      	it	ne
    1b8e:	2001      	movne	r0, #1
    1b90:	4912      	ldr	r1, [pc, #72]	@ (1bdc <usart_sync_write+0x60>)
    1b92:	4b13      	ldr	r3, [pc, #76]	@ (1be0 <usart_sync_write+0x64>)
	while (!_usart_sync_is_ready_to_send(&descr->device))
    1b94:	f8df 8050 	ldr.w	r8, [pc, #80]	@ 1be8 <usart_sync_write+0x6c>
	ASSERT(io_descr && buf && length);
    1b98:	22f1      	movs	r2, #241	@ 0xf1
    1b9a:	4798      	blx	r3
	while (!_usart_sync_is_ready_to_send(&descr->device))
    1b9c:	3408      	adds	r4, #8
    1b9e:	4620      	mov	r0, r4
    1ba0:	47c0      	blx	r8
    1ba2:	2800      	cmp	r0, #0
    1ba4:	d0fb      	beq.n	1b9e <usart_sync_write+0x22>
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
    1ba6:	f8df 9044 	ldr.w	r9, [pc, #68]	@ 1bec <usart_sync_write+0x70>
	uint32_t                      offset = 0;
    1baa:	2700      	movs	r7, #0
		_usart_sync_write_byte(&descr->device, buf[offset]);
    1bac:	5df1      	ldrb	r1, [r6, r7]
    1bae:	4620      	mov	r0, r4
    1bb0:	47c8      	blx	r9
		while (!_usart_sync_is_ready_to_send(&descr->device))
    1bb2:	4620      	mov	r0, r4
    1bb4:	47c0      	blx	r8
    1bb6:	2800      	cmp	r0, #0
    1bb8:	d0fb      	beq.n	1bb2 <usart_sync_write+0x36>
			;
	} while (++offset < length);
    1bba:	3701      	adds	r7, #1
    1bbc:	42bd      	cmp	r5, r7
    1bbe:	d8f5      	bhi.n	1bac <usart_sync_write+0x30>
    1bc0:	2d00      	cmp	r5, #0
	while (!_usart_sync_is_transmit_done(&descr->device))
    1bc2:	4e08      	ldr	r6, [pc, #32]	@ (1be4 <usart_sync_write+0x68>)
    1bc4:	bf08      	it	eq
    1bc6:	2501      	moveq	r5, #1
    1bc8:	4620      	mov	r0, r4
    1bca:	47b0      	blx	r6
    1bcc:	2800      	cmp	r0, #0
    1bce:	d0fb      	beq.n	1bc8 <usart_sync_write+0x4c>
		;
	return (int32_t)offset;
}
    1bd0:	4628      	mov	r0, r5
    1bd2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
    1bd6:	4608      	mov	r0, r1
    1bd8:	e7da      	b.n	1b90 <usart_sync_write+0x14>
    1bda:	bf00      	nop
    1bdc:	000033e6 	.word	0x000033e6
    1be0:	00001ab5 	.word	0x00001ab5
    1be4:	00002471 	.word	0x00002471
    1be8:	00002467 	.word	0x00002467
    1bec:	00002459 	.word	0x00002459

00001bf0 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    1bf0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    1bf4:	460e      	mov	r6, r1
    1bf6:	4615      	mov	r5, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    1bf8:	4604      	mov	r4, r0
    1bfa:	b118      	cbz	r0, 1c04 <usart_sync_read+0x14>
    1bfc:	b1e9      	cbz	r1, 1c3a <usart_sync_read+0x4a>
    1bfe:	1e10      	subs	r0, r2, #0
    1c00:	bf18      	it	ne
    1c02:	2001      	movne	r0, #1
    1c04:	490e      	ldr	r1, [pc, #56]	@ (1c40 <usart_sync_read+0x50>)
    1c06:	4b0f      	ldr	r3, [pc, #60]	@ (1c44 <usart_sync_read+0x54>)
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
    1c08:	f8df 903c 	ldr.w	r9, [pc, #60]	@ 1c48 <usart_sync_read+0x58>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
    1c0c:	f8df 803c 	ldr.w	r8, [pc, #60]	@ 1c4c <usart_sync_read+0x5c>
	ASSERT(io_descr && buf && length);
    1c10:	f44f 7286 	mov.w	r2, #268	@ 0x10c
    1c14:	4798      	blx	r3
	uint32_t                      offset = 0;
    1c16:	2700      	movs	r7, #0
		while (!_usart_sync_is_byte_received(&descr->device))
    1c18:	3408      	adds	r4, #8
    1c1a:	4620      	mov	r0, r4
    1c1c:	47c8      	blx	r9
    1c1e:	2800      	cmp	r0, #0
    1c20:	d0fb      	beq.n	1c1a <usart_sync_read+0x2a>
		buf[offset] = _usart_sync_read_byte(&descr->device);
    1c22:	4620      	mov	r0, r4
    1c24:	47c0      	blx	r8
    1c26:	55f0      	strb	r0, [r6, r7]
	} while (++offset < length);
    1c28:	3701      	adds	r7, #1
    1c2a:	42bd      	cmp	r5, r7
    1c2c:	d8f5      	bhi.n	1c1a <usart_sync_read+0x2a>

	return (int32_t)offset;
    1c2e:	2d00      	cmp	r5, #0
}
    1c30:	bf14      	ite	ne
    1c32:	4628      	movne	r0, r5
    1c34:	2001      	moveq	r0, #1
    1c36:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
    1c3a:	4608      	mov	r0, r1
    1c3c:	e7e2      	b.n	1c04 <usart_sync_read+0x14>
    1c3e:	bf00      	nop
    1c40:	000033e6 	.word	0x000033e6
    1c44:	00001ab5 	.word	0x00001ab5
    1c48:	0000247b 	.word	0x0000247b
    1c4c:	0000245f 	.word	0x0000245f

00001c50 <usart_sync_init>:
{
    1c50:	b538      	push	{r3, r4, r5, lr}
    1c52:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    1c54:	4604      	mov	r4, r0
    1c56:	b110      	cbz	r0, 1c5e <usart_sync_init+0xe>
    1c58:	1e08      	subs	r0, r1, #0
    1c5a:	bf18      	it	ne
    1c5c:	2001      	movne	r0, #1
    1c5e:	4907      	ldr	r1, [pc, #28]	@ (1c7c <usart_sync_init+0x2c>)
    1c60:	4b07      	ldr	r3, [pc, #28]	@ (1c80 <usart_sync_init+0x30>)
    1c62:	2234      	movs	r2, #52	@ 0x34
    1c64:	4798      	blx	r3
	init_status = _usart_sync_init(&descr->device, hw);
    1c66:	4b07      	ldr	r3, [pc, #28]	@ (1c84 <usart_sync_init+0x34>)
    1c68:	4629      	mov	r1, r5
    1c6a:	f104 0008 	add.w	r0, r4, #8
    1c6e:	4798      	blx	r3
	if (init_status) {
    1c70:	b918      	cbnz	r0, 1c7a <usart_sync_init+0x2a>
	descr->io.read  = usart_sync_read;
    1c72:	4b05      	ldr	r3, [pc, #20]	@ (1c88 <usart_sync_init+0x38>)
    1c74:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_sync_write;
    1c76:	4b05      	ldr	r3, [pc, #20]	@ (1c8c <usart_sync_init+0x3c>)
    1c78:	6023      	str	r3, [r4, #0]
}
    1c7a:	bd38      	pop	{r3, r4, r5, pc}
    1c7c:	000033e6 	.word	0x000033e6
    1c80:	00001ab5 	.word	0x00001ab5
    1c84:	0000242d 	.word	0x0000242d
    1c88:	00001bf1 	.word	0x00001bf1
    1c8c:	00001b7d 	.word	0x00001b7d

00001c90 <_mclk_init>:
}

static inline void hri_mclk_write_CPUDIV_reg(const void *const hw, hri_mclk_cpudiv_reg_t data)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->CPUDIV.reg = data;
    1c90:	4b01      	ldr	r3, [pc, #4]	@ (1c98 <_mclk_init+0x8>)
    1c92:	2201      	movs	r2, #1
    1c94:	715a      	strb	r2, [r3, #5]
 */
void _mclk_init(void)
{
	void *hw = (void *)MCLK;
	hri_mclk_write_CPUDIV_reg(hw, MCLK_CPUDIV_DIV(CONF_MCLK_CPUDIV));
}
    1c96:	4770      	bx	lr
    1c98:	40000800 	.word	0x40000800

00001c9c <RAMECC_Handler>:
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
	return ((Ramecc *)hw)->INTFLAG.reg;
    1c9c:	4a0b      	ldr	r2, [pc, #44]	@ (1ccc <RAMECC_Handler+0x30>)
    1c9e:	7893      	ldrb	r3, [r2, #2]

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
    1ca0:	b082      	sub	sp, #8
    1ca2:	b2db      	uxtb	r3, r3
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
    1ca4:	9301      	str	r3, [sp, #4]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
    1ca6:	9b01      	ldr	r3, [sp, #4]
    1ca8:	0799      	lsls	r1, r3, #30
    1caa:	d505      	bpl.n	1cb8 <RAMECC_Handler+0x1c>
    1cac:	4b08      	ldr	r3, [pc, #32]	@ (1cd0 <RAMECC_Handler+0x34>)
    1cae:	681b      	ldr	r3, [r3, #0]
    1cb0:	b113      	cbz	r3, 1cb8 <RAMECC_Handler+0x1c>
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
	return ((Ramecc *)hw)->ERRADDR.reg;
    1cb2:	6850      	ldr	r0, [r2, #4]
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
	} else {
		return;
	}
}
    1cb4:	b002      	add	sp, #8
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    1cb6:	4718      	bx	r3
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
    1cb8:	9b01      	ldr	r3, [sp, #4]
    1cba:	07db      	lsls	r3, r3, #31
    1cbc:	d504      	bpl.n	1cc8 <RAMECC_Handler+0x2c>
    1cbe:	4b04      	ldr	r3, [pc, #16]	@ (1cd0 <RAMECC_Handler+0x34>)
    1cc0:	685b      	ldr	r3, [r3, #4]
    1cc2:	b10b      	cbz	r3, 1cc8 <RAMECC_Handler+0x2c>
    1cc4:	4a01      	ldr	r2, [pc, #4]	@ (1ccc <RAMECC_Handler+0x30>)
    1cc6:	e7f4      	b.n	1cb2 <RAMECC_Handler+0x16>
}
    1cc8:	b002      	add	sp, #8
    1cca:	4770      	bx	lr
    1ccc:	41020000 	.word	0x41020000
    1cd0:	2002052c 	.word	0x2002052c

00001cd4 <_osc32kctrl_init_sources>:
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
    1cd4:	4b03      	ldr	r3, [pc, #12]	@ (1ce4 <_osc32kctrl_init_sources+0x10>)
    1cd6:	69da      	ldr	r2, [r3, #28]
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSCULP32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSCULP32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
    1cd8:	f402 527c 	and.w	r2, r2, #16128	@ 0x3f00
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
    1cdc:	61da      	str	r2, [r3, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
    1cde:	2201      	movs	r2, #1
    1ce0:	741a      	strb	r2, [r3, #16]
#endif
#endif

	hri_osc32kctrl_write_RTCCTRL_reg(hw, OSC32KCTRL_RTCCTRL_RTCSEL(CONF_RTCCTRL));
	(void)calib;
}
    1ce2:	4770      	bx	lr
    1ce4:	40001400 	.word	0x40001400

00001ce8 <_gpio_set_pin_function>:

/**
 * \brief Set gpio pin function
 */
static inline void _gpio_set_pin_function(const uint32_t gpio, const uint32_t function)
{
    1ce8:	b530      	push	{r4, r5, lr}
	uint8_t port = GPIO_PORT(gpio);
	uint8_t pin  = GPIO_PIN(gpio);

	if (function == GPIO_PIN_FUNCTION_OFF) {
    1cea:	1c4b      	adds	r3, r1, #1
	uint8_t pin  = GPIO_PIN(gpio);
    1cec:	b2c5      	uxtb	r5, r0
    1cee:	4b18      	ldr	r3, [pc, #96]	@ (1d50 <_gpio_set_pin_function+0x68>)
    1cf0:	f000 041f 	and.w	r4, r0, #31
	uint8_t port = GPIO_PORT(gpio);
    1cf4:	ea4f 1050 	mov.w	r0, r0, lsr #5
    1cf8:	ea4f 10c0 	mov.w	r0, r0, lsl #7
static inline void hri_port_write_PINCFG_PMUXEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                    bool value)
{
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1cfc:	4403      	add	r3, r0
	if (function == GPIO_PIN_FUNCTION_OFF) {
    1cfe:	d107      	bne.n	1d10 <_gpio_set_pin_function+0x28>
    1d00:	4423      	add	r3, r4
    1d02:	f893 2040 	ldrb.w	r2, [r3, #64]	@ 0x40
	tmp &= ~PORT_PINCFG_PMUXEN;
    1d06:	f002 02fe 	and.w	r2, r2, #254	@ 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1d0a:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
		} else {
			// Even numbered pin
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
		}
	}
}
    1d0e:	bd30      	pop	{r4, r5, pc}
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    1d10:	1918      	adds	r0, r3, r4
    1d12:	eb03 0354 	add.w	r3, r3, r4, lsr #1
    1d16:	f890 2040 	ldrb.w	r2, [r0, #64]	@ 0x40
	tmp &= ~PORT_PINCFG_PMUXEN;
    1d1a:	f002 02fe 	and.w	r2, r2, #254	@ 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    1d1e:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    1d22:	f880 2040 	strb.w	r2, [r0, #64]	@ 0x40
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    1d26:	f893 2030 	ldrb.w	r2, [r3, #48]	@ 0x30
		if (pin & 1) {
    1d2a:	f015 0f01 	tst.w	r5, #1
			hri_port_write_PMUX_PMUXO_bf(PORT, port, pin >> 1, function & 0xffff);
    1d2e:	b2c9      	uxtb	r1, r1
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    1d30:	bf19      	ittee	ne
    1d32:	f002 020f 	andne.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
    1d36:	ea42 1201 	orrne.w	r2, r2, r1, lsl #4
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    1d3a:	f002 02f0 	andeq.w	r2, r2, #240	@ 0xf0
	tmp |= PORT_PMUX_PMUXE(data);
    1d3e:	f001 010f 	andeq.w	r1, r1, #15
	tmp |= PORT_PMUX_PMUXO(data);
    1d42:	bf14      	ite	ne
    1d44:	b2d2      	uxtbne	r2, r2
	tmp |= PORT_PMUX_PMUXE(data);
    1d46:	430a      	orreq	r2, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    1d48:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
}
    1d4c:	e7df      	b.n	1d0e <_gpio_set_pin_function+0x26>
    1d4e:	bf00      	nop
    1d50:	41008000 	.word	0x41008000

00001d54 <ADC_0_CLOCK_init>:
}

static inline void hri_mclk_set_APBDMASK_ADC0_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_ADC0;
    1d54:	4a04      	ldr	r2, [pc, #16]	@ (1d68 <ADC_0_CLOCK_init+0x14>)
    1d56:	6a13      	ldr	r3, [r2, #32]
    1d58:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
    1d5c:	6213      	str	r3, [r2, #32]
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
    1d5e:	4b03      	ldr	r3, [pc, #12]	@ (1d6c <ADC_0_CLOCK_init+0x18>)
    1d60:	2241      	movs	r2, #65	@ 0x41
    1d62:	f8c3 2120 	str.w	r2, [r3, #288]	@ 0x120

void ADC_0_CLOCK_init(void)
{
	hri_mclk_set_APBDMASK_ADC0_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, ADC0_GCLK_ID, CONF_GCLK_ADC0_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
}
    1d66:	4770      	bx	lr
    1d68:	40000800 	.word	0x40000800
    1d6c:	40001c00 	.word	0x40001c00

00001d70 <ADC_0_init>:

void ADC_0_init(void)
{
    1d70:	b510      	push	{r4, lr}
	ADC_0_CLOCK_init();
    1d72:	4b04      	ldr	r3, [pc, #16]	@ (1d84 <ADC_0_init+0x14>)
	ADC_0_PORT_init();
	adc_sync_init(&ADC_0, ADC0, (void *)NULL);
    1d74:	4904      	ldr	r1, [pc, #16]	@ (1d88 <ADC_0_init+0x18>)
    1d76:	4805      	ldr	r0, [pc, #20]	@ (1d8c <ADC_0_init+0x1c>)
	ADC_0_CLOCK_init();
    1d78:	4798      	blx	r3
}
    1d7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	adc_sync_init(&ADC_0, ADC0, (void *)NULL);
    1d7e:	4b04      	ldr	r3, [pc, #16]	@ (1d90 <ADC_0_init+0x20>)
    1d80:	2200      	movs	r2, #0
    1d82:	4718      	bx	r3
    1d84:	00001d55 	.word	0x00001d55
    1d88:	43001c00 	.word	0x43001c00
    1d8c:	2002053c 	.word	0x2002053c
    1d90:	000020cd 	.word	0x000020cd

00001d94 <ADC_1_CLOCK_init>:
}

static inline void hri_mclk_set_APBDMASK_ADC1_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_ADC1;
    1d94:	4a04      	ldr	r2, [pc, #16]	@ (1da8 <ADC_1_CLOCK_init+0x14>)
    1d96:	6a13      	ldr	r3, [r2, #32]
    1d98:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
    1d9c:	6213      	str	r3, [r2, #32]
    1d9e:	4b03      	ldr	r3, [pc, #12]	@ (1dac <ADC_1_CLOCK_init+0x18>)
    1da0:	2240      	movs	r2, #64	@ 0x40
    1da2:	f8c3 2124 	str.w	r2, [r3, #292]	@ 0x124

void ADC_1_CLOCK_init(void)
{
	hri_mclk_set_APBDMASK_ADC1_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, ADC1_GCLK_ID, CONF_GCLK_ADC1_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
}
    1da6:	4770      	bx	lr
    1da8:	40000800 	.word	0x40000800
    1dac:	40001c00 	.word	0x40001c00

00001db0 <ADC_1_init>:

void ADC_1_init(void)
{
    1db0:	b510      	push	{r4, lr}
	ADC_1_CLOCK_init();
    1db2:	4b04      	ldr	r3, [pc, #16]	@ (1dc4 <ADC_1_init+0x14>)
	ADC_1_PORT_init();
	adc_sync_init(&ADC_1, ADC1, (void *)NULL);
    1db4:	4904      	ldr	r1, [pc, #16]	@ (1dc8 <ADC_1_init+0x18>)
    1db6:	4805      	ldr	r0, [pc, #20]	@ (1dcc <ADC_1_init+0x1c>)
	ADC_1_CLOCK_init();
    1db8:	4798      	blx	r3
}
    1dba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	adc_sync_init(&ADC_1, ADC1, (void *)NULL);
    1dbe:	4b04      	ldr	r3, [pc, #16]	@ (1dd0 <ADC_1_init+0x20>)
    1dc0:	2200      	movs	r2, #0
    1dc2:	4718      	bx	r3
    1dc4:	00001d95 	.word	0x00001d95
    1dc8:	43002000 	.word	0x43002000
    1dcc:	20020540 	.word	0x20020540
    1dd0:	000020cd 	.word	0x000020cd

00001dd4 <USART_0_PORT_init>:

void USART_0_PORT_init(void)
{
    1dd4:	b510      	push	{r4, lr}
 *                      found in the header files for the device
 *
 */
static inline void gpio_set_pin_function(const uint32_t pin, uint32_t function)
{
	_gpio_set_pin_function(pin, function);
    1dd6:	4c05      	ldr	r4, [pc, #20]	@ (1dec <USART_0_PORT_init+0x18>)
    1dd8:	4905      	ldr	r1, [pc, #20]	@ (1df0 <USART_0_PORT_init+0x1c>)
    1dda:	2004      	movs	r0, #4
    1ddc:	47a0      	blx	r4
    1dde:	4623      	mov	r3, r4
    1de0:	4904      	ldr	r1, [pc, #16]	@ (1df4 <USART_0_PORT_init+0x20>)

	gpio_set_pin_function(PA04, PINMUX_PA04D_SERCOM0_PAD0);

	gpio_set_pin_function(PA05, PINMUX_PA05D_SERCOM0_PAD1);
}
    1de2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    1de6:	2005      	movs	r0, #5
    1de8:	4718      	bx	r3
    1dea:	bf00      	nop
    1dec:	00001ce9 	.word	0x00001ce9
    1df0:	00040003 	.word	0x00040003
    1df4:	00050003 	.word	0x00050003

00001df8 <USART_0_CLOCK_init>:
    1df8:	4b06      	ldr	r3, [pc, #24]	@ (1e14 <USART_0_CLOCK_init+0x1c>)
    1dfa:	2240      	movs	r2, #64	@ 0x40
    1dfc:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
    1e00:	2243      	movs	r2, #67	@ 0x43
    1e02:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_SERCOM0;
    1e06:	4a04      	ldr	r2, [pc, #16]	@ (1e18 <USART_0_CLOCK_init+0x20>)
    1e08:	6953      	ldr	r3, [r2, #20]
    1e0a:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
    1e0e:	6153      	str	r3, [r2, #20]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM0_GCLK_ID_CORE, CONF_GCLK_SERCOM0_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM0_GCLK_ID_SLOW, CONF_GCLK_SERCOM0_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBAMASK_SERCOM0_bit(MCLK);
}
    1e10:	4770      	bx	lr
    1e12:	bf00      	nop
    1e14:	40001c00 	.word	0x40001c00
    1e18:	40000800 	.word	0x40000800

00001e1c <USART_0_init>:

void USART_0_init(void)
{
    1e1c:	b510      	push	{r4, lr}
	USART_0_CLOCK_init();
    1e1e:	4b05      	ldr	r3, [pc, #20]	@ (1e34 <USART_0_init+0x18>)
	usart_sync_init(&USART_0, SERCOM0, (void *)NULL);
    1e20:	4905      	ldr	r1, [pc, #20]	@ (1e38 <USART_0_init+0x1c>)
    1e22:	4806      	ldr	r0, [pc, #24]	@ (1e3c <USART_0_init+0x20>)
	USART_0_CLOCK_init();
    1e24:	4798      	blx	r3
	usart_sync_init(&USART_0, SERCOM0, (void *)NULL);
    1e26:	4b06      	ldr	r3, [pc, #24]	@ (1e40 <USART_0_init+0x24>)
    1e28:	2200      	movs	r2, #0
    1e2a:	4798      	blx	r3
	USART_0_PORT_init();
}
    1e2c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USART_0_PORT_init();
    1e30:	4b04      	ldr	r3, [pc, #16]	@ (1e44 <USART_0_init+0x28>)
    1e32:	4718      	bx	r3
    1e34:	00001df9 	.word	0x00001df9
    1e38:	40003000 	.word	0x40003000
    1e3c:	20020544 	.word	0x20020544
    1e40:	00001c51 	.word	0x00001c51
    1e44:	00001dd5 	.word	0x00001dd5

00001e48 <I2C_0_PORT_init>:

void I2C_0_PORT_init(void)
{
    1e48:	b570      	push	{r4, r5, r6, lr}
}

static inline void hri_port_clear_PINCFG_PULLEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    1e4a:	4c0b      	ldr	r4, [pc, #44]	@ (1e78 <I2C_0_PORT_init+0x30>)
    1e4c:	4d0b      	ldr	r5, [pc, #44]	@ (1e7c <I2C_0_PORT_init+0x34>)
    1e4e:	f894 3050 	ldrb.w	r3, [r4, #80]	@ 0x50
    1e52:	490b      	ldr	r1, [pc, #44]	@ (1e80 <I2C_0_PORT_init+0x38>)
    1e54:	f003 03fb 	and.w	r3, r3, #251	@ 0xfb
    1e58:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
    1e5c:	2010      	movs	r0, #16
    1e5e:	47a8      	blx	r5
    1e60:	f894 3051 	ldrb.w	r3, [r4, #81]	@ 0x51
    1e64:	4907      	ldr	r1, [pc, #28]	@ (1e84 <I2C_0_PORT_init+0x3c>)
    1e66:	f003 03fb 	and.w	r3, r3, #251	@ 0xfb
    1e6a:	f884 3051 	strb.w	r3, [r4, #81]	@ 0x51
    1e6e:	2011      	movs	r0, #17
    1e70:	462b      	mov	r3, r5
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA17, PINMUX_PA17C_SERCOM1_PAD1);
}
    1e72:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    1e76:	4718      	bx	r3
    1e78:	41008000 	.word	0x41008000
    1e7c:	00001ce9 	.word	0x00001ce9
    1e80:	00100002 	.word	0x00100002
    1e84:	00110002 	.word	0x00110002

00001e88 <I2C_0_CLOCK_init>:
    1e88:	4b06      	ldr	r3, [pc, #24]	@ (1ea4 <I2C_0_CLOCK_init+0x1c>)
    1e8a:	2240      	movs	r2, #64	@ 0x40
    1e8c:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
    1e90:	2243      	movs	r2, #67	@ 0x43
    1e92:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_SERCOM1;
    1e96:	4a04      	ldr	r2, [pc, #16]	@ (1ea8 <I2C_0_CLOCK_init+0x20>)
    1e98:	6953      	ldr	r3, [r2, #20]
    1e9a:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
    1e9e:	6153      	str	r3, [r2, #20]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM1_GCLK_ID_CORE, CONF_GCLK_SERCOM1_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM1_GCLK_ID_SLOW, CONF_GCLK_SERCOM1_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBAMASK_SERCOM1_bit(MCLK);
}
    1ea0:	4770      	bx	lr
    1ea2:	bf00      	nop
    1ea4:	40001c00 	.word	0x40001c00
    1ea8:	40000800 	.word	0x40000800

00001eac <I2C_0_init>:

void I2C_0_init(void)
{
    1eac:	b510      	push	{r4, lr}
	I2C_0_CLOCK_init();
    1eae:	4b05      	ldr	r3, [pc, #20]	@ (1ec4 <I2C_0_init+0x18>)
	i2c_m_sync_init(&I2C_0, SERCOM1);
    1eb0:	4905      	ldr	r1, [pc, #20]	@ (1ec8 <I2C_0_init+0x1c>)
    1eb2:	4806      	ldr	r0, [pc, #24]	@ (1ecc <I2C_0_init+0x20>)
	I2C_0_CLOCK_init();
    1eb4:	4798      	blx	r3
	i2c_m_sync_init(&I2C_0, SERCOM1);
    1eb6:	4b06      	ldr	r3, [pc, #24]	@ (1ed0 <I2C_0_init+0x24>)
    1eb8:	4798      	blx	r3
	I2C_0_PORT_init();
}
    1eba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	I2C_0_PORT_init();
    1ebe:	4b05      	ldr	r3, [pc, #20]	@ (1ed4 <I2C_0_init+0x28>)
    1ec0:	4718      	bx	r3
    1ec2:	bf00      	nop
    1ec4:	00001e89 	.word	0x00001e89
    1ec8:	40003400 	.word	0x40003400
    1ecc:	20020550 	.word	0x20020550
    1ed0:	00001609 	.word	0x00001609
    1ed4:	00001e49 	.word	0x00001e49

00001ed8 <SPI_0_PORT_init>:

void SPI_0_PORT_init(void)
{
    1ed8:	b570      	push	{r4, r5, r6, lr}
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    1eda:	4c1b      	ldr	r4, [pc, #108]	@ (1f48 <SPI_0_PORT_init+0x70>)
    1edc:	4d1b      	ldr	r5, [pc, #108]	@ (1f4c <SPI_0_PORT_init+0x74>)
    1ede:	491c      	ldr	r1, [pc, #112]	@ (1f50 <SPI_0_PORT_init+0x78>)
    1ee0:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
    1ee4:	f8c4 3094 	str.w	r3, [r4, #148]	@ 0x94

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1ee8:	f04f 4680 	mov.w	r6, #1073741824	@ 0x40000000
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1eec:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1ef0:	4b18      	ldr	r3, [pc, #96]	@ (1f54 <SPI_0_PORT_init+0x7c>)
    1ef2:	f8c4 60a8 	str.w	r6, [r4, #168]	@ 0xa8
    1ef6:	203a      	movs	r0, #58	@ 0x3a
    1ef8:	f8c4 30a8 	str.w	r3, [r4, #168]	@ 0xa8
    1efc:	47a8      	blx	r5
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    1efe:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
    1f02:	f8c4 3094 	str.w	r3, [r4, #148]	@ 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    1f06:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1f0a:	4b13      	ldr	r3, [pc, #76]	@ (1f58 <SPI_0_PORT_init+0x80>)
    1f0c:	f8c4 60a8 	str.w	r6, [r4, #168]	@ 0xa8
    1f10:	4912      	ldr	r1, [pc, #72]	@ (1f5c <SPI_0_PORT_init+0x84>)
    1f12:	f8c4 30a8 	str.w	r3, [r4, #168]	@ 0xa8
    1f16:	203b      	movs	r0, #59	@ 0x3b
    1f18:	47a8      	blx	r5
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    1f1a:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
    1f1e:	f8c4 3084 	str.w	r3, [r4, #132]	@ 0x84
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    1f22:	4b0f      	ldr	r3, [pc, #60]	@ (1f60 <SPI_0_PORT_init+0x88>)
    1f24:	f8c4 30a8 	str.w	r3, [r4, #168]	@ 0xa8
    1f28:	4b0e      	ldr	r3, [pc, #56]	@ (1f64 <SPI_0_PORT_init+0x8c>)
    1f2a:	f8c4 30a8 	str.w	r3, [r4, #168]	@ 0xa8
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    1f2e:	f894 30dd 	ldrb.w	r3, [r4, #221]	@ 0xdd
    1f32:	490d      	ldr	r1, [pc, #52]	@ (1f68 <SPI_0_PORT_init+0x90>)
    1f34:	f003 03fb 	and.w	r3, r3, #251	@ 0xfb
    1f38:	f884 30dd 	strb.w	r3, [r4, #221]	@ 0xdd
    1f3c:	203d      	movs	r0, #61	@ 0x3d
    1f3e:	462b      	mov	r3, r5
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PB29, PINMUX_PB29C_SERCOM2_PAD3);
}
    1f40:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    1f44:	4718      	bx	r3
    1f46:	bf00      	nop
    1f48:	41008000 	.word	0x41008000
    1f4c:	00001ce9 	.word	0x00001ce9
    1f50:	003a0002 	.word	0x003a0002
    1f54:	c0000400 	.word	0xc0000400
    1f58:	c0000800 	.word	0xc0000800
    1f5c:	003b0002 	.word	0x003b0002
    1f60:	40020000 	.word	0x40020000
    1f64:	c0022000 	.word	0xc0022000
    1f68:	003d0002 	.word	0x003d0002

00001f6c <SPI_0_CLOCK_init>:
    1f6c:	4b06      	ldr	r3, [pc, #24]	@ (1f88 <SPI_0_CLOCK_init+0x1c>)
    1f6e:	2242      	movs	r2, #66	@ 0x42
    1f70:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
    1f74:	2243      	movs	r2, #67	@ 0x43
    1f76:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_SERCOM2;
    1f7a:	4a04      	ldr	r2, [pc, #16]	@ (1f8c <SPI_0_CLOCK_init+0x20>)
    1f7c:	6993      	ldr	r3, [r2, #24]
    1f7e:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
    1f82:	6193      	str	r3, [r2, #24]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM2_GCLK_ID_CORE, CONF_GCLK_SERCOM2_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM2_GCLK_ID_SLOW, CONF_GCLK_SERCOM2_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBBMASK_SERCOM2_bit(MCLK);
}
    1f84:	4770      	bx	lr
    1f86:	bf00      	nop
    1f88:	40001c00 	.word	0x40001c00
    1f8c:	40000800 	.word	0x40000800

00001f90 <SPI_0_init>:

void SPI_0_init(void)
{
    1f90:	b510      	push	{r4, lr}
	SPI_0_CLOCK_init();
    1f92:	4b05      	ldr	r3, [pc, #20]	@ (1fa8 <SPI_0_init+0x18>)
	spi_m_sync_init(&SPI_0, SERCOM2);
    1f94:	4905      	ldr	r1, [pc, #20]	@ (1fac <SPI_0_init+0x1c>)
    1f96:	4806      	ldr	r0, [pc, #24]	@ (1fb0 <SPI_0_init+0x20>)
	SPI_0_CLOCK_init();
    1f98:	4798      	blx	r3
	spi_m_sync_init(&SPI_0, SERCOM2);
    1f9a:	4b06      	ldr	r3, [pc, #24]	@ (1fb4 <SPI_0_init+0x24>)
    1f9c:	4798      	blx	r3
	SPI_0_PORT_init();
}
    1f9e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	SPI_0_PORT_init();
    1fa2:	4b05      	ldr	r3, [pc, #20]	@ (1fb8 <SPI_0_init+0x28>)
    1fa4:	4718      	bx	r3
    1fa6:	bf00      	nop
    1fa8:	00001f6d 	.word	0x00001f6d
    1fac:	41012000 	.word	0x41012000
    1fb0:	20020570 	.word	0x20020570
    1fb4:	000014b9 	.word	0x000014b9
    1fb8:	00001ed9 	.word	0x00001ed9

00001fbc <delay_driver_init>:

void delay_driver_init(void)
{
	delay_init(SysTick);
    1fbc:	4801      	ldr	r0, [pc, #4]	@ (1fc4 <delay_driver_init+0x8>)
    1fbe:	4b02      	ldr	r3, [pc, #8]	@ (1fc8 <delay_driver_init+0xc>)
    1fc0:	4718      	bx	r3
    1fc2:	bf00      	nop
    1fc4:	e000e010 	.word	0xe000e010
    1fc8:	000019dd 	.word	0x000019dd

00001fcc <WDT_0_CLOCK_init>:
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_WDT;
    1fcc:	4a02      	ldr	r2, [pc, #8]	@ (1fd8 <WDT_0_CLOCK_init+0xc>)
    1fce:	6953      	ldr	r3, [r2, #20]
    1fd0:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
    1fd4:	6153      	str	r3, [r2, #20]
}

void WDT_0_CLOCK_init(void)
{
	hri_mclk_set_APBAMASK_WDT_bit(MCLK);
}
    1fd6:	4770      	bx	lr
    1fd8:	40000800 	.word	0x40000800

00001fdc <WDT_0_init>:

void WDT_0_init(void)
{
    1fdc:	b510      	push	{r4, lr}
	WDT_0_CLOCK_init();
    1fde:	4b07      	ldr	r3, [pc, #28]	@ (1ffc <WDT_0_init+0x20>)
 * \retval 0 Completed sucessfully.
 * \retval -1 Always on or enabled, don't need init again.
 */
static inline int32_t wdt_init(struct wdt_descriptor *const wdt, const void *hw)
{
	ASSERT(wdt && hw);
    1fe0:	4907      	ldr	r1, [pc, #28]	@ (2000 <WDT_0_init+0x24>)
    1fe2:	4798      	blx	r3
    1fe4:	2001      	movs	r0, #1
    1fe6:	4b07      	ldr	r3, [pc, #28]	@ (2004 <WDT_0_init+0x28>)
    1fe8:	2248      	movs	r2, #72	@ 0x48
    1fea:	4798      	blx	r3

	wdt->dev.hw = (void *)hw;
    1fec:	4806      	ldr	r0, [pc, #24]	@ (2008 <WDT_0_init+0x2c>)
    1fee:	4b07      	ldr	r3, [pc, #28]	@ (200c <WDT_0_init+0x30>)
    1ff0:	f840 3f4c 	str.w	r3, [r0, #76]!
	wdt_init(&WDT_0, WDT);
}
    1ff4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

	return _wdt_init(&wdt->dev);
    1ff8:	4b05      	ldr	r3, [pc, #20]	@ (2010 <WDT_0_init+0x34>)
    1ffa:	4718      	bx	r3
    1ffc:	00001fcd 	.word	0x00001fcd
    2000:	00003402 	.word	0x00003402
    2004:	00001ab5 	.word	0x00001ab5
    2008:	2002053c 	.word	0x2002053c
    200c:	40002000 	.word	0x40002000
    2010:	00000d0d 	.word	0x00000d0d

00002014 <system_init>:

void system_init(void)
{
    2014:	b570      	push	{r4, r5, r6, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
    2016:	4b21      	ldr	r3, [pc, #132]	@ (209c <system_init+0x88>)
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    2018:	4c21      	ldr	r4, [pc, #132]	@ (20a0 <system_init+0x8c>)
    201a:	4e22      	ldr	r6, [pc, #136]	@ (20a4 <system_init+0x90>)
    201c:	4798      	blx	r3
    201e:	2302      	movs	r3, #2
    2020:	f8c4 3094 	str.w	r3, [r4, #148]	@ 0x94
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    2024:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    2028:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
    202c:	f8c4 30a8 	str.w	r3, [r4, #168]	@ 0xa8
    2030:	f04f 4340 	mov.w	r3, #3221225472	@ 0xc0000000
    2034:	f8c4 30a8 	str.w	r3, [r4, #168]	@ 0xa8
    2038:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
    203c:	2021      	movs	r0, #33	@ 0x21
    203e:	47b0      	blx	r6
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    2040:	f04f 4580 	mov.w	r5, #1073741824	@ 0x40000000
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    2044:	4b18      	ldr	r3, [pc, #96]	@ (20a8 <system_init+0x94>)
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    2046:	f8c4 5118 	str.w	r5, [r4, #280]	@ 0x118
    204a:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    204e:	f8c4 5108 	str.w	r5, [r4, #264]	@ 0x108
    2052:	205e      	movs	r0, #94	@ 0x5e
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    2054:	f8c4 5128 	str.w	r5, [r4, #296]	@ 0x128
    2058:	f8c4 3128 	str.w	r3, [r4, #296]	@ 0x128
    205c:	47b0      	blx	r6
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    205e:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
    2062:	f8c4 3118 	str.w	r3, [r4, #280]	@ 0x118
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    2066:	f8c4 3108 	str.w	r3, [r4, #264]	@ 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    206a:	4b10      	ldr	r3, [pc, #64]	@ (20ac <system_init+0x98>)
    206c:	f8c4 5128 	str.w	r5, [r4, #296]	@ 0x128
    2070:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
    2074:	205f      	movs	r0, #95	@ 0x5f
    2076:	f8c4 3128 	str.w	r3, [r4, #296]	@ 0x128
    207a:	47b0      	blx	r6
	// Set pin direction to output
	gpio_set_pin_direction(LED_Orange2, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(LED_Orange2, GPIO_PIN_FUNCTION_OFF);

	ADC_0_init();
    207c:	4b0c      	ldr	r3, [pc, #48]	@ (20b0 <system_init+0x9c>)
    207e:	4798      	blx	r3

	ADC_1_init();
    2080:	4b0c      	ldr	r3, [pc, #48]	@ (20b4 <system_init+0xa0>)
    2082:	4798      	blx	r3

	USART_0_init();
    2084:	4b0c      	ldr	r3, [pc, #48]	@ (20b8 <system_init+0xa4>)
    2086:	4798      	blx	r3

	I2C_0_init();
    2088:	4b0c      	ldr	r3, [pc, #48]	@ (20bc <system_init+0xa8>)
    208a:	4798      	blx	r3

	SPI_0_init();
    208c:	4b0c      	ldr	r3, [pc, #48]	@ (20c0 <system_init+0xac>)
    208e:	4798      	blx	r3

	delay_driver_init();
    2090:	4b0c      	ldr	r3, [pc, #48]	@ (20c4 <system_init+0xb0>)
    2092:	4798      	blx	r3

	WDT_0_init();
}
    2094:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	WDT_0_init();
    2098:	4b0b      	ldr	r3, [pc, #44]	@ (20c8 <system_init+0xb4>)
    209a:	4718      	bx	r3
    209c:	000019ed 	.word	0x000019ed
    20a0:	41008000 	.word	0x41008000
    20a4:	00001ce9 	.word	0x00001ce9
    20a8:	c0004000 	.word	0xc0004000
    20ac:	c0008000 	.word	0xc0008000
    20b0:	00001d71 	.word	0x00001d71
    20b4:	00001db1 	.word	0x00001db1
    20b8:	00001e1d 	.word	0x00001e1d
    20bc:	00001ead 	.word	0x00001ead
    20c0:	00001f91 	.word	0x00001f91
    20c4:	00001fbd 	.word	0x00001fbd
    20c8:	00001fdd 	.word	0x00001fdd

000020cc <adc_sync_init>:

/**
 * \brief Initialize ADC
 */
int32_t adc_sync_init(struct adc_sync_descriptor *const descr, void *const hw, void *const func)
{
    20cc:	b570      	push	{r4, r5, r6, lr}
    20ce:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    20d0:	4604      	mov	r4, r0
    20d2:	b110      	cbz	r0, 20da <adc_sync_init+0xe>
    20d4:	1e08      	subs	r0, r1, #0
    20d6:	bf18      	it	ne
    20d8:	2001      	movne	r0, #1
    20da:	4905      	ldr	r1, [pc, #20]	@ (20f0 <adc_sync_init+0x24>)
    20dc:	4b05      	ldr	r3, [pc, #20]	@ (20f4 <adc_sync_init+0x28>)
    20de:	2239      	movs	r2, #57	@ 0x39
    20e0:	4798      	blx	r3

	return _adc_sync_init(&descr->device, hw);
    20e2:	4629      	mov	r1, r5
    20e4:	4620      	mov	r0, r4
    20e6:	4b04      	ldr	r3, [pc, #16]	@ (20f8 <adc_sync_init+0x2c>)
}
    20e8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _adc_sync_init(&descr->device, hw);
    20ec:	4718      	bx	r3
    20ee:	bf00      	nop
    20f0:	0000341b 	.word	0x0000341b
    20f4:	00001ab5 	.word	0x00001ab5
    20f8:	0000323d 	.word	0x0000323d

000020fc <hri_sercomi2cm_wait_for_sync>:
typedef uint8_t  hri_sercomusart_rxerrcnt_reg_t;
typedef uint8_t  hri_sercomusart_rxpl_reg_t;

static inline void hri_sercomi2cm_wait_for_sync(const void *const hw, hri_sercomi2cm_syncbusy_reg_t reg)
{
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    20fc:	69c3      	ldr	r3, [r0, #28]
    20fe:	420b      	tst	r3, r1
    2100:	d1fc      	bne.n	20fc <hri_sercomi2cm_wait_for_sync>
	};
}
    2102:	4770      	bx	lr

00002104 <hri_sercomi2cm_get_CTRLA_ENABLE_bit>:
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_sercomi2cm_get_CTRLA_ENABLE_bit(const void *const hw)
{
    2104:	b508      	push	{r3, lr}
	uint32_t tmp;
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
    2106:	2103      	movs	r1, #3
    2108:	4b02      	ldr	r3, [pc, #8]	@ (2114 <hri_sercomi2cm_get_CTRLA_ENABLE_bit+0x10>)
    210a:	4798      	blx	r3
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    210c:	6800      	ldr	r0, [r0, #0]
	tmp = (tmp & SERCOM_I2CM_CTRLA_ENABLE) >> SERCOM_I2CM_CTRLA_ENABLE_Pos;
	return (bool)tmp;
}
    210e:	f3c0 0040 	ubfx	r0, r0, #1, #1
    2112:	bd08      	pop	{r3, pc}
    2114:	000020fd 	.word	0x000020fd

00002118 <hri_sercomi2cm_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_sercomi2cm_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
    2118:	6802      	ldr	r2, [r0, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
    211a:	4b03      	ldr	r3, [pc, #12]	@ (2128 <hri_sercomi2cm_clear_CTRLA_ENABLE_bit+0x10>)
	((Sercom *)hw)->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
    211c:	f022 0202 	bic.w	r2, r2, #2
    2120:	6002      	str	r2, [r0, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
    2122:	2103      	movs	r1, #3
    2124:	4718      	bx	r3
    2126:	bf00      	nop
    2128:	000020fd 	.word	0x000020fd

0000212c <hri_sercomi2cm_write_CTRLA_reg>:
}

static inline void hri_sercomi2cm_write_CTRLA_reg(const void *const hw, hri_sercomi2cm_ctrla_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
    212c:	6001      	str	r1, [r0, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
    212e:	4b01      	ldr	r3, [pc, #4]	@ (2134 <hri_sercomi2cm_write_CTRLA_reg+0x8>)
    2130:	2103      	movs	r1, #3
    2132:	4718      	bx	r3
    2134:	000020fd 	.word	0x000020fd

00002138 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
    2138:	b570      	push	{r4, r5, r6, lr}
	Sercom *const sercom_modules[] = SERCOM_INSTS;
    213a:	4d0c      	ldr	r5, [pc, #48]	@ (216c <_sercom_get_hardware_index+0x34>)
{
    213c:	4606      	mov	r6, r0
	Sercom *const sercom_modules[] = SERCOM_INSTS;
    213e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
    2140:	b088      	sub	sp, #32
	Sercom *const sercom_modules[] = SERCOM_INSTS;
    2142:	466c      	mov	r4, sp
    2144:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    2146:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    214a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	/* Find index for SERCOM instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    214e:	466a      	mov	r2, sp
    2150:	2300      	movs	r3, #0
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
    2152:	f852 1b04 	ldr.w	r1, [r2], #4
    2156:	42b1      	cmp	r1, r6
    2158:	d102      	bne.n	2160 <_sercom_get_hardware_index+0x28>
			return i;
    215a:	b2d8      	uxtb	r0, r3
		}
	}
	return 0;
}
    215c:	b008      	add	sp, #32
    215e:	bd70      	pop	{r4, r5, r6, pc}
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    2160:	3301      	adds	r3, #1
    2162:	2b08      	cmp	r3, #8
    2164:	d1f5      	bne.n	2152 <_sercom_get_hardware_index+0x1a>
	return 0;
    2166:	2000      	movs	r0, #0
    2168:	e7f8      	b.n	215c <_sercom_get_hardware_index+0x24>
    216a:	bf00      	nop
    216c:	000034ac 	.word	0x000034ac

00002170 <_get_i2cm_index>:
 * \param[in] hw The pointer to hardware instance

 * \return The ordinal number of the given sercom hardware instance
 */
static int8_t _get_i2cm_index(const void *const hw)
{
    2170:	b508      	push	{r3, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    2172:	4b07      	ldr	r3, [pc, #28]	@ (2190 <_get_i2cm_index+0x20>)
    2174:	4798      	blx	r3
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_i2cms); i++) {
		if (_i2cms[i].number == sercom_offset) {
    2176:	2801      	cmp	r0, #1
    2178:	d008      	beq.n	218c <_get_i2cm_index+0x1c>
			return i;
		}
	}

	ASSERT(false);
    217a:	2000      	movs	r0, #0
    217c:	4905      	ldr	r1, [pc, #20]	@ (2194 <_get_i2cm_index+0x24>)
    217e:	4b06      	ldr	r3, [pc, #24]	@ (2198 <_get_i2cm_index+0x28>)
    2180:	f240 32a6 	movw	r2, #934	@ 0x3a6
    2184:	4798      	blx	r3
    2186:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
	return -1;
}
    218a:	bd08      	pop	{r3, pc}
			return i;
    218c:	2000      	movs	r0, #0
    218e:	e7fc      	b.n	218a <_get_i2cm_index+0x1a>
    2190:	00002139 	.word	0x00002139
    2194:	00003435 	.word	0x00003435
    2198:	00001ab5 	.word	0x00001ab5

0000219c <_sercom_i2c_send_stop>:
}

static inline void hri_sercomi2cm_set_CTRLB_CMD_bf(const void *const hw, hri_sercomi2cm_ctrlb_reg_t mask)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    219c:	6842      	ldr	r2, [r0, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    219e:	4b03      	ldr	r3, [pc, #12]	@ (21ac <_sercom_i2c_send_stop+0x10>)
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    21a0:	f442 3240 	orr.w	r2, r2, #196608	@ 0x30000
    21a4:	6042      	str	r2, [r0, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    21a6:	2104      	movs	r1, #4
    21a8:	4718      	bx	r3
    21aa:	bf00      	nop
    21ac:	000020fd 	.word	0x000020fd

000021b0 <_sercom_i2c_sync_analyse_flags>:

/**
 * \brief SERCOM I2CM analyze hardware status and transfer next byte
 */
static inline int32_t _sercom_i2c_sync_analyse_flags(void *const hw, uint32_t flags, struct _i2c_m_msg *const msg)
{
    21b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    21b4:	4688      	mov	r8, r1
    21b6:	4614      	mov	r4, r2
	((Sercom *)hw)->I2CM.STATUS.reg |= mask;
}

static inline hri_sercomi2cm_status_reg_t hri_sercomi2cm_read_STATUS_reg(const void *const hw)
{
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    21b8:	2104      	movs	r1, #4
    21ba:	4a4f      	ldr	r2, [pc, #316]	@ (22f8 <_sercom_i2c_sync_analyse_flags+0x148>)
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    21bc:	6807      	ldr	r7, [r0, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    21be:	4790      	blx	r2
	return ((Sercom *)hw)->I2CM.STATUS.reg;
    21c0:	8b43      	ldrh	r3, [r0, #26]
	int      sclsm  = hri_sercomi2cm_get_CTRLA_SCLSM_bit(hw);
	uint16_t status = hri_sercomi2cm_read_STATUS_reg(hw);

	if (flags & MB_FLAG) {
    21c2:	f018 0f01 	tst.w	r8, #1
{
    21c6:	4605      	mov	r5, r0
    21c8:	b29b      	uxth	r3, r3
	if (flags & MB_FLAG) {
    21ca:	4616      	mov	r6, r2
    21cc:	d059      	beq.n	2282 <_sercom_i2c_sync_analyse_flags+0xd2>
		/* tx error */
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
    21ce:	079e      	lsls	r6, r3, #30
    21d0:	d513      	bpl.n	21fa <_sercom_i2c_sync_analyse_flags+0x4a>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
    21d2:	2201      	movs	r2, #1
    21d4:	7602      	strb	r2, [r0, #24]
			hri_sercomi2cm_clear_interrupt_MB_bit(hw);
			msg->flags |= I2C_M_FAIL;
    21d6:	8862      	ldrh	r2, [r4, #2]
    21d8:	b292      	uxth	r2, r2
    21da:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
    21de:	8062      	strh	r2, [r4, #2]
			msg->flags &= ~I2C_M_BUSY;
    21e0:	8862      	ldrh	r2, [r4, #2]
    21e2:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
    21e6:	0412      	lsls	r2, r2, #16
    21e8:	0c12      	lsrs	r2, r2, #16
    21ea:	f003 0301 	and.w	r3, r3, #1
    21ee:	f06f 0003 	mvn.w	r0, #3
    21f2:	8062      	strh	r2, [r4, #2]

			if (status & SERCOM_I2CM_STATUS_BUSERR) {
    21f4:	1ac0      	subs	r0, r0, r3

		hri_sercomi2cm_clear_interrupt_SB_bit(hw);
	}

	return I2C_OK;
}
    21f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
    21fa:	075b      	lsls	r3, r3, #29
    21fc:	d515      	bpl.n	222a <_sercom_i2c_sync_analyse_flags+0x7a>
				if (msg->len > 0) {
    21fe:	6863      	ldr	r3, [r4, #4]
    2200:	2b00      	cmp	r3, #0
					msg->flags |= I2C_M_FAIL;
    2202:	bfc1      	itttt	gt
    2204:	8863      	ldrhgt	r3, [r4, #2]
    2206:	b29b      	uxthgt	r3, r3
    2208:	f443 5380 	orrgt.w	r3, r3, #4096	@ 0x1000
    220c:	8063      	strhgt	r3, [r4, #2]
				if (msg->flags & I2C_M_STOP) {
    220e:	8863      	ldrh	r3, [r4, #2]
    2210:	041f      	lsls	r7, r3, #16
    2212:	d501      	bpl.n	2218 <_sercom_i2c_sync_analyse_flags+0x68>
					_sercom_i2c_send_stop(hw);
    2214:	4b39      	ldr	r3, [pc, #228]	@ (22fc <_sercom_i2c_sync_analyse_flags+0x14c>)
    2216:	4798      	blx	r3
				msg->flags &= ~I2C_M_BUSY;
    2218:	8863      	ldrh	r3, [r4, #2]
    221a:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
    221e:	041b      	lsls	r3, r3, #16
    2220:	0c1b      	lsrs	r3, r3, #16
    2222:	8063      	strh	r3, [r4, #2]
				return I2C_NACK;
    2224:	f06f 0001 	mvn.w	r0, #1
    2228:	e7e5      	b.n	21f6 <_sercom_i2c_sync_analyse_flags+0x46>
			if (msg->flags & I2C_M_TEN) {
    222a:	8863      	ldrh	r3, [r4, #2]
    222c:	055e      	lsls	r6, r3, #21
    222e:	d514      	bpl.n	225a <_sercom_i2c_sync_analyse_flags+0xaa>
				                              ((((msg->addr & TEN_ADDR_MASK) >> 8) | TEN_ADDR_FRAME) << 1) | I2C_M_RD
    2230:	8826      	ldrh	r6, [r4, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    2232:	4790      	blx	r2
	return ((Sercom *)hw)->I2CM.ADDR.reg;
    2234:	6a43      	ldr	r3, [r0, #36]	@ 0x24
				                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    2236:	09f6      	lsrs	r6, r6, #7
    2238:	f006 0606 	and.w	r6, r6, #6
    223c:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
    2240:	4333      	orrs	r3, r6
				hri_sercomi2cm_write_ADDR_reg(hw,
    2242:	f043 03f1 	orr.w	r3, r3, #241	@ 0xf1
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    2246:	6243      	str	r3, [r0, #36]	@ 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    2248:	4790      	blx	r2
				msg->flags &= ~I2C_M_TEN;
    224a:	8863      	ldrh	r3, [r4, #2]
    224c:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
				msg->flags &= ~I2C_M_BUSY;
    2250:	041b      	lsls	r3, r3, #16
    2252:	0c1b      	lsrs	r3, r3, #16
    2254:	8063      	strh	r3, [r4, #2]
				return I2C_OK;
    2256:	2000      	movs	r0, #0
    2258:	e7cd      	b.n	21f6 <_sercom_i2c_sync_analyse_flags+0x46>
			if (msg->len == 0) {
    225a:	6866      	ldr	r6, [r4, #4]
    225c:	b946      	cbnz	r6, 2270 <_sercom_i2c_sync_analyse_flags+0xc0>
				if (msg->flags & I2C_M_STOP) {
    225e:	8863      	ldrh	r3, [r4, #2]
    2260:	041d      	lsls	r5, r3, #16
    2262:	d501      	bpl.n	2268 <_sercom_i2c_sync_analyse_flags+0xb8>
					_sercom_i2c_send_stop(hw);
    2264:	4b25      	ldr	r3, [pc, #148]	@ (22fc <_sercom_i2c_sync_analyse_flags+0x14c>)
    2266:	4798      	blx	r3
				msg->flags &= ~I2C_M_BUSY;
    2268:	8863      	ldrh	r3, [r4, #2]
    226a:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
    226e:	e7ef      	b.n	2250 <_sercom_i2c_sync_analyse_flags+0xa0>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
    2270:	68a7      	ldr	r7, [r4, #8]
    2272:	f817 3b01 	ldrb.w	r3, [r7], #1
	((Sercom *)hw)->I2CM.DATA.reg = data;
    2276:	6283      	str	r3, [r0, #40]	@ 0x28
				msg->len--;
    2278:	3e01      	subs	r6, #1
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    227a:	4790      	blx	r2
				msg->buffer++;
    227c:	60a7      	str	r7, [r4, #8]
				msg->len--;
    227e:	6066      	str	r6, [r4, #4]
    2280:	e7e9      	b.n	2256 <_sercom_i2c_sync_analyse_flags+0xa6>
	} else if (flags & SB_FLAG) {
    2282:	f018 0f02 	tst.w	r8, #2
    2286:	d0e6      	beq.n	2256 <_sercom_i2c_sync_analyse_flags+0xa6>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
    2288:	6862      	ldr	r2, [r4, #4]
    228a:	2a00      	cmp	r2, #0
    228c:	d031      	beq.n	22f2 <_sercom_i2c_sync_analyse_flags+0x142>
    228e:	0759      	lsls	r1, r3, #29
    2290:	d42f      	bmi.n	22f2 <_sercom_i2c_sync_analyse_flags+0x142>
			msg->len--;
    2292:	3a01      	subs	r2, #1
    2294:	f007 6700 	and.w	r7, r7, #134217728	@ 0x8000000
    2298:	6062      	str	r2, [r4, #4]
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
    229a:	b99a      	cbnz	r2, 22c4 <_sercom_i2c_sync_analyse_flags+0x114>
    229c:	b1af      	cbz	r7, 22ca <_sercom_i2c_sync_analyse_flags+0x11a>
				if (msg->flags & I2C_M_STOP) {
    229e:	8863      	ldrh	r3, [r4, #2]
    22a0:	041b      	lsls	r3, r3, #16
    22a2:	d508      	bpl.n	22b6 <_sercom_i2c_sync_analyse_flags+0x106>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
    22a4:	686b      	ldr	r3, [r5, #4]
    22a6:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
    22aa:	606b      	str	r3, [r5, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    22ac:	2104      	movs	r1, #4
    22ae:	4628      	mov	r0, r5
    22b0:	47b0      	blx	r6
					_sercom_i2c_send_stop(hw);
    22b2:	4b12      	ldr	r3, [pc, #72]	@ (22fc <_sercom_i2c_sync_analyse_flags+0x14c>)
    22b4:	4798      	blx	r3
				msg->flags &= ~I2C_M_BUSY;
    22b6:	8863      	ldrh	r3, [r4, #2]
    22b8:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
    22bc:	041b      	lsls	r3, r3, #16
    22be:	0c1b      	lsrs	r3, r3, #16
    22c0:	8063      	strh	r3, [r4, #2]
    22c2:	e00b      	b.n	22dc <_sercom_i2c_sync_analyse_flags+0x12c>
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
    22c4:	2a01      	cmp	r2, #1
    22c6:	d109      	bne.n	22dc <_sercom_i2c_sync_analyse_flags+0x12c>
    22c8:	b147      	cbz	r7, 22dc <_sercom_i2c_sync_analyse_flags+0x12c>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    22ca:	686b      	ldr	r3, [r5, #4]
    22cc:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
    22d0:	606b      	str	r3, [r5, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    22d2:	2104      	movs	r1, #4
    22d4:	4628      	mov	r0, r5
    22d6:	47b0      	blx	r6
			if (msg->len == 0) {
    22d8:	2a00      	cmp	r2, #0
    22da:	d0e0      	beq.n	229e <_sercom_i2c_sync_analyse_flags+0xee>
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    22dc:	2104      	movs	r1, #4
    22de:	4628      	mov	r0, r5
    22e0:	47b0      	blx	r6
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
    22e2:	68a3      	ldr	r3, [r4, #8]
	return ((Sercom *)hw)->I2CM.DATA.reg;
    22e4:	6aaa      	ldr	r2, [r5, #40]	@ 0x28
    22e6:	1c59      	adds	r1, r3, #1
    22e8:	60a1      	str	r1, [r4, #8]
    22ea:	701a      	strb	r2, [r3, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    22ec:	2302      	movs	r3, #2
    22ee:	762b      	strb	r3, [r5, #24]
}
    22f0:	e7b1      	b.n	2256 <_sercom_i2c_sync_analyse_flags+0xa6>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    22f2:	2302      	movs	r3, #2
    22f4:	762b      	strb	r3, [r5, #24]
			return I2C_NACK;
    22f6:	e795      	b.n	2224 <_sercom_i2c_sync_analyse_flags+0x74>
    22f8:	000020fd 	.word	0x000020fd
    22fc:	0000219d 	.word	0x0000219d

00002300 <_i2c_m_sync_init_impl>:
	}
	return ERR_NONE;
}

static int32_t _i2c_m_sync_init_impl(struct _i2c_m_service *const service, void *const hw)
{
    2300:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2304:	460c      	mov	r4, r1
	uint8_t i = _get_i2cm_index(hw);
    2306:	4b21      	ldr	r3, [pc, #132]	@ (238c <_i2c_m_sync_init_impl+0x8c>)
    2308:	f8df a08c 	ldr.w	sl, [pc, #140]	@ 2398 <_i2c_m_sync_init_impl+0x98>
    230c:	4d20      	ldr	r5, [pc, #128]	@ (2390 <_i2c_m_sync_init_impl+0x90>)
    230e:	f8df 908c 	ldr.w	r9, [pc, #140]	@ 239c <_i2c_m_sync_init_impl+0x9c>
{
    2312:	4606      	mov	r6, r0
	uint8_t i = _get_i2cm_index(hw);
    2314:	4608      	mov	r0, r1
    2316:	4798      	blx	r3
	return ((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg;
    2318:	69e3      	ldr	r3, [r4, #28]

	if (!hri_sercomi2cm_is_syncing(hw, SERCOM_I2CM_SYNCBUSY_SWRST)) {
    231a:	f013 0f01 	tst.w	r3, #1
	uint8_t i = _get_i2cm_index(hw);
    231e:	b2c7      	uxtb	r7, r0
	if (!hri_sercomi2cm_is_syncing(hw, SERCOM_I2CM_SYNCBUSY_SWRST)) {
    2320:	d113      	bne.n	234a <_i2c_m_sync_init_impl+0x4a>
		uint32_t mode = _i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_MODE_Msk;
    2322:	2318      	movs	r3, #24
    2324:	fb03 a307 	mla	r3, r3, r7, sl
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
    2328:	2103      	movs	r1, #3
    232a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
    232c:	4620      	mov	r0, r4
    232e:	f003 081c 	and.w	r8, r3, #28
    2332:	47a8      	blx	r5
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    2334:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
    2336:	079b      	lsls	r3, r3, #30
    2338:	d503      	bpl.n	2342 <_i2c_m_sync_init_impl+0x42>
			hri_sercomi2cm_clear_CTRLA_ENABLE_bit(hw);
    233a:	4b16      	ldr	r3, [pc, #88]	@ (2394 <_i2c_m_sync_init_impl+0x94>)
    233c:	4798      	blx	r3
			hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_ENABLE);
    233e:	2102      	movs	r1, #2
    2340:	47a8      	blx	r5
		}
		hri_sercomi2cm_write_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_SWRST | mode);
    2342:	f048 0101 	orr.w	r1, r8, #1
    2346:	4620      	mov	r0, r4
    2348:	47c8      	blx	r9
	}
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST);

	hri_sercomi2cm_write_CTRLA_reg(hw, _i2cms[i].ctrl_a);
    234a:	2218      	movs	r2, #24
    234c:	fb02 a207 	mla	r2, r2, r7, sl
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST);
    2350:	4620      	mov	r0, r4
    2352:	2101      	movs	r1, #1
    2354:	47a8      	blx	r5
	hri_sercomi2cm_write_CTRLA_reg(hw, _i2cms[i].ctrl_a);
    2356:	6a54      	ldr	r4, [r2, #36]	@ 0x24
    2358:	4621      	mov	r1, r4
    235a:	47c8      	blx	r9
	hri_sercomi2cm_write_CTRLB_reg(hw, _i2cms[i].ctrl_b);
    235c:	6a93      	ldr	r3, [r2, #40]	@ 0x28
	((Sercom *)hw)->I2CM.CTRLB.reg = data;
    235e:	6043      	str	r3, [r0, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    2360:	2104      	movs	r1, #4
    2362:	47a8      	blx	r5
	hri_sercomi2cm_write_BAUD_reg(hw, _i2cms[i].baud);
    2364:	6ad3      	ldr	r3, [r2, #44]	@ 0x2c
	((Sercom *)hw)->I2CM.BAUD.reg = data;
    2366:	60c3      	str	r3, [r0, #12]

	service->mode = (_i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_SPEED_Msk) >> SERCOM_I2CM_CTRLA_SPEED_Pos;
    2368:	f3c4 6301 	ubfx	r3, r4, #24, #2
    236c:	81b3      	strh	r3, [r6, #12]
	tmp = ((Sercom *)hw)->I2CM.ADDR.reg;
    236e:	6a43      	ldr	r3, [r0, #36]	@ 0x24
	hri_sercomi2cm_write_ADDR_HS_bit(hw, service->mode < I2C_HS ? 0 : 1);
    2370:	f3c4 6440 	ubfx	r4, r4, #25, #1
	tmp &= ~SERCOM_I2CM_ADDR_HS;
    2374:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
	tmp |= value << SERCOM_I2CM_ADDR_HS_Pos;
    2378:	ea43 3384 	orr.w	r3, r3, r4, lsl #14
	((Sercom *)hw)->I2CM.ADDR.reg = tmp;
    237c:	6243      	str	r3, [r0, #36]	@ 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    237e:	47a8      	blx	r5

	service->trise = _i2cms[i].trise;
    2380:	8e53      	ldrh	r3, [r2, #50]	@ 0x32
    2382:	81f3      	strh	r3, [r6, #14]

	return ERR_NONE;
}
    2384:	2000      	movs	r0, #0
    2386:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    238a:	bf00      	nop
    238c:	00002171 	.word	0x00002171
    2390:	000020fd 	.word	0x000020fd
    2394:	00002119 	.word	0x00002119
    2398:	000034ac 	.word	0x000034ac
    239c:	0000212d 	.word	0x0000212d

000023a0 <_usart_init>:
{
    23a0:	b570      	push	{r4, r5, r6, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    23a2:	4b19      	ldr	r3, [pc, #100]	@ (2408 <_usart_init+0x68>)
{
    23a4:	4604      	mov	r4, r0
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    23a6:	4798      	blx	r3
		if (_usarts[i].number == sercom_offset) {
    23a8:	b128      	cbz	r0, 23b6 <_usart_init+0x16>
	ASSERT(false);
    23aa:	4918      	ldr	r1, [pc, #96]	@ (240c <_usart_init+0x6c>)
    23ac:	4b18      	ldr	r3, [pc, #96]	@ (2410 <_usart_init+0x70>)
    23ae:	f240 2247 	movw	r2, #583	@ 0x247
    23b2:	2000      	movs	r0, #0
    23b4:	4798      	blx	r3
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
    23b6:	69e3      	ldr	r3, [r4, #28]
    23b8:	4d16      	ldr	r5, [pc, #88]	@ (2414 <_usart_init+0x74>)
    23ba:	4e17      	ldr	r6, [pc, #92]	@ (2418 <_usart_init+0x78>)
	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
    23bc:	f013 0f01 	tst.w	r3, #1
    23c0:	d10d      	bne.n	23de <_usart_init+0x3e>
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
    23c2:	4b16      	ldr	r3, [pc, #88]	@ (241c <_usart_init+0x7c>)
    23c4:	2103      	movs	r1, #3
    23c6:	4620      	mov	r0, r4
    23c8:	4798      	blx	r3
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    23ca:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
    23cc:	079b      	lsls	r3, r3, #30
    23ce:	d503      	bpl.n	23d8 <_usart_init+0x38>
			hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
    23d0:	4b13      	ldr	r3, [pc, #76]	@ (2420 <_usart_init+0x80>)
    23d2:	4798      	blx	r3
			hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_ENABLE);
    23d4:	2102      	movs	r1, #2
    23d6:	47a8      	blx	r5
		hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST | mode);
    23d8:	2105      	movs	r1, #5
    23da:	4620      	mov	r0, r4
    23dc:	47b0      	blx	r6
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST);
    23de:	4620      	mov	r0, r4
    23e0:	2101      	movs	r1, #1
    23e2:	47a8      	blx	r5
	hri_sercomusart_write_CTRLA_reg(hw, _usarts[i].ctrl_a);
    23e4:	490f      	ldr	r1, [pc, #60]	@ (2424 <_usart_init+0x84>)
    23e6:	47b0      	blx	r6
	((Sercom *)hw)->USART.CTRLB.reg = data;
    23e8:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
    23ec:	6063      	str	r3, [r4, #4]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
    23ee:	211f      	movs	r1, #31
    23f0:	47a8      	blx	r5
	((Sercom *)hw)->USART.CTRLC.reg = data;
    23f2:	4b0d      	ldr	r3, [pc, #52]	@ (2428 <_usart_init+0x88>)
    23f4:	60a3      	str	r3, [r4, #8]
	((Sercom *)hw)->USART.BAUD.reg = data;
    23f6:	f24e 53c9 	movw	r3, #58825	@ 0xe5c9
    23fa:	81a3      	strh	r3, [r4, #12]
	((Sercom *)hw)->USART.RXPL.reg = data;
    23fc:	2300      	movs	r3, #0
    23fe:	73a3      	strb	r3, [r4, #14]
}
    2400:	4618      	mov	r0, r3
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
    2402:	f884 3030 	strb.w	r3, [r4, #48]	@ 0x30
    2406:	bd70      	pop	{r4, r5, r6, pc}
    2408:	00002139 	.word	0x00002139
    240c:	00003435 	.word	0x00003435
    2410:	00001ab5 	.word	0x00001ab5
    2414:	000020fd 	.word	0x000020fd
    2418:	0000212d 	.word	0x0000212d
    241c:	000020fd 	.word	0x000020fd
    2420:	00002119 	.word	0x00002119
    2424:	40100004 	.word	0x40100004
    2428:	00700002 	.word	0x00700002

0000242c <_usart_sync_init>:
{
    242c:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
    242e:	4605      	mov	r5, r0
    2430:	3800      	subs	r0, #0
{
    2432:	460c      	mov	r4, r1
	ASSERT(device);
    2434:	4b05      	ldr	r3, [pc, #20]	@ (244c <_usart_sync_init+0x20>)
    2436:	4906      	ldr	r1, [pc, #24]	@ (2450 <_usart_sync_init+0x24>)
    2438:	bf18      	it	ne
    243a:	2001      	movne	r0, #1
    243c:	22bb      	movs	r2, #187	@ 0xbb
    243e:	4798      	blx	r3
	device->hw = hw;
    2440:	602c      	str	r4, [r5, #0]
	return _usart_init(hw);
    2442:	4620      	mov	r0, r4
    2444:	4b03      	ldr	r3, [pc, #12]	@ (2454 <_usart_sync_init+0x28>)
}
    2446:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _usart_init(hw);
    244a:	4718      	bx	r3
    244c:	00001ab5 	.word	0x00001ab5
    2450:	00003435 	.word	0x00003435
    2454:	000023a1 	.word	0x000023a1

00002458 <_usart_sync_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
    2458:	6803      	ldr	r3, [r0, #0]
	((Sercom *)hw)->USART.DATA.reg = data;
    245a:	6299      	str	r1, [r3, #40]	@ 0x28
}
    245c:	4770      	bx	lr

0000245e <_usart_sync_read_byte>:
	return hri_sercomusart_read_DATA_reg(device->hw);
    245e:	6803      	ldr	r3, [r0, #0]
	return ((Sercom *)hw)->USART.DATA.reg;
    2460:	6a98      	ldr	r0, [r3, #40]	@ 0x28
}
    2462:	b2c0      	uxtb	r0, r0
    2464:	4770      	bx	lr

00002466 <_usart_sync_is_ready_to_send>:
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
    2466:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    2468:	7e18      	ldrb	r0, [r3, #24]
}
    246a:	f000 0001 	and.w	r0, r0, #1
    246e:	4770      	bx	lr

00002470 <_usart_sync_is_transmit_done>:
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
    2470:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    2472:	7e18      	ldrb	r0, [r3, #24]
}
    2474:	f3c0 0040 	ubfx	r0, r0, #1, #1
    2478:	4770      	bx	lr

0000247a <_usart_sync_is_byte_received>:
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
    247a:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    247c:	7e18      	ldrb	r0, [r3, #24]
}
    247e:	f3c0 0080 	ubfx	r0, r0, #2, #1
    2482:	4770      	bx	lr

00002484 <_i2c_m_sync_init>:
{
    2484:	b570      	push	{r4, r5, r6, lr}
	ASSERT(i2c_dev);
    2486:	4604      	mov	r4, r0
    2488:	3800      	subs	r0, #0
{
    248a:	460d      	mov	r5, r1
	ASSERT(i2c_dev);
    248c:	4b06      	ldr	r3, [pc, #24]	@ (24a8 <_i2c_m_sync_init+0x24>)
    248e:	4907      	ldr	r1, [pc, #28]	@ (24ac <_i2c_m_sync_init+0x28>)
    2490:	bf18      	it	ne
    2492:	2001      	movne	r0, #1
    2494:	f44f 62a3 	mov.w	r2, #1304	@ 0x518
    2498:	4798      	blx	r3
	i2c_dev->hw = hw;
    249a:	6125      	str	r5, [r4, #16]
	return _i2c_m_sync_init_impl(&i2c_dev->service, hw);
    249c:	4629      	mov	r1, r5
    249e:	4620      	mov	r0, r4
    24a0:	4b03      	ldr	r3, [pc, #12]	@ (24b0 <_i2c_m_sync_init+0x2c>)
}
    24a2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _i2c_m_sync_init_impl(&i2c_dev->service, hw);
    24a6:	4718      	bx	r3
    24a8:	00001ab5 	.word	0x00001ab5
    24ac:	00003435 	.word	0x00003435
    24b0:	00002301 	.word	0x00002301

000024b4 <_i2c_m_sync_transfer>:
{
    24b4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    24b8:	4604      	mov	r4, r0
	ASSERT(i2c_dev);
    24ba:	f8df 9160 	ldr.w	r9, [pc, #352]	@ 261c <_i2c_m_sync_transfer+0x168>
	void *   hw = i2c_dev->hw;
    24be:	6906      	ldr	r6, [r0, #16]
{
    24c0:	460d      	mov	r5, r1
	ASSERT(i2c_dev);
    24c2:	f44f 62ba 	mov.w	r2, #1488	@ 0x5d0
    24c6:	4952      	ldr	r1, [pc, #328]	@ (2610 <_i2c_m_sync_transfer+0x15c>)
    24c8:	2001      	movs	r0, #1
    24ca:	47c8      	blx	r9
	ASSERT(i2c_dev->hw);
    24cc:	6920      	ldr	r0, [r4, #16]
    24ce:	4950      	ldr	r1, [pc, #320]	@ (2610 <_i2c_m_sync_transfer+0x15c>)
    24d0:	3800      	subs	r0, #0
    24d2:	f240 52d1 	movw	r2, #1489	@ 0x5d1
    24d6:	bf18      	it	ne
    24d8:	2001      	movne	r0, #1
    24da:	47c8      	blx	r9
	ASSERT(msg);
    24dc:	1e28      	subs	r0, r5, #0
    24de:	f240 52d2 	movw	r2, #1490	@ 0x5d2
    24e2:	bf18      	it	ne
    24e4:	2001      	movne	r0, #1
    24e6:	494a      	ldr	r1, [pc, #296]	@ (2610 <_i2c_m_sync_transfer+0x15c>)
    24e8:	47c8      	blx	r9
	if (i2c_dev->service.msg.flags & I2C_M_BUSY) {
    24ea:	8863      	ldrh	r3, [r4, #2]
    24ec:	05da      	lsls	r2, r3, #23
    24ee:	f100 808b 	bmi.w	2608 <_i2c_m_sync_transfer+0x154>
	msg->flags |= I2C_M_BUSY;
    24f2:	886b      	ldrh	r3, [r5, #2]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    24f4:	f8df 8128 	ldr.w	r8, [pc, #296]	@ 2620 <_i2c_m_sync_transfer+0x16c>
    24f8:	b29b      	uxth	r3, r3
    24fa:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
    24fe:	806b      	strh	r3, [r5, #2]
	i2c_dev->service.msg = *msg;
    2500:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_SMEN;
    2504:	6873      	ldr	r3, [r6, #4]
    2506:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
    250a:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    250e:	6073      	str	r3, [r6, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    2510:	2104      	movs	r1, #4
    2512:	4630      	mov	r0, r6
    2514:	47c0      	blx	r8
	void *             hw    = i2c_dev->hw;
    2516:	6927      	ldr	r7, [r4, #16]
	ASSERT(i2c_dev);
    2518:	493d      	ldr	r1, [pc, #244]	@ (2610 <_i2c_m_sync_transfer+0x15c>)
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    251a:	f8d7 a000 	ldr.w	sl, [r7]
    251e:	f240 52a5 	movw	r2, #1445	@ 0x5a5
    2522:	2001      	movs	r0, #1
    2524:	47c8      	blx	r9
	if (msg->len == 1 && sclsm) {
    2526:	6863      	ldr	r3, [r4, #4]
    2528:	2b01      	cmp	r3, #1
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    252a:	687b      	ldr	r3, [r7, #4]
    252c:	d13a      	bne.n	25a4 <_i2c_m_sync_transfer+0xf0>
    252e:	f01a 6f00 	tst.w	sl, #134217728	@ 0x8000000
    2532:	d037      	beq.n	25a4 <_i2c_m_sync_transfer+0xf0>
    2534:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    2538:	607b      	str	r3, [r7, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    253a:	2104      	movs	r1, #4
    253c:	4638      	mov	r0, r7
    253e:	47c0      	blx	r8
	if (msg->addr & I2C_M_TEN) {
    2540:	8822      	ldrh	r2, [r4, #0]
    2542:	f412 6f80 	tst.w	r2, #1024	@ 0x400
    2546:	ea4f 0242 	mov.w	r2, r2, lsl #1
    254a:	d02e      	beq.n	25aa <_i2c_m_sync_transfer+0xf6>
		if (msg->flags & I2C_M_RD) {
    254c:	8863      	ldrh	r3, [r4, #2]
    254e:	07db      	lsls	r3, r3, #31
			msg->flags |= I2C_M_TEN;
    2550:	bf41      	itttt	mi
    2552:	8863      	ldrhmi	r3, [r4, #2]
    2554:	b29b      	uxthmi	r3, r3
    2556:	f443 6380 	orrmi.w	r3, r3, #1024	@ 0x400
    255a:	8063      	strhmi	r3, [r4, #2]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    255c:	2104      	movs	r1, #4
    255e:	47c0      	blx	r8
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    2560:	f022 0201 	bic.w	r2, r2, #1
	return ((Sercom *)hw)->I2CM.ADDR.reg;
    2564:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    2566:	0552      	lsls	r2, r2, #21
    2568:	0d52      	lsrs	r2, r2, #21
    256a:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
    256e:	431a      	orrs	r2, r3
		hri_sercomi2cm_write_ADDR_reg(hw,
    2570:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    2574:	627a      	str	r2, [r7, #36]	@ 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    2576:	47c0      	blx	r8
	void *   hw      = i2c_dev->hw;
    2578:	6922      	ldr	r2, [r4, #16]
    257a:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
    257e:	7e11      	ldrb	r1, [r2, #24]
		if (timeout-- == 0) {
    2580:	3b01      	subs	r3, #1
    2582:	b2c9      	uxtb	r1, r1
    2584:	d001      	beq.n	258a <_i2c_m_sync_transfer+0xd6>
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
    2586:	0788      	lsls	r0, r1, #30
    2588:	d0f9      	beq.n	257e <_i2c_m_sync_transfer+0xca>
	return _sercom_i2c_sync_analyse_flags(hw, flags, msg);
    258a:	4638      	mov	r0, r7
    258c:	4622      	mov	r2, r4
    258e:	4f21      	ldr	r7, [pc, #132]	@ (2614 <_i2c_m_sync_transfer+0x160>)
    2590:	47b8      	blx	r7
	if (ret) {
    2592:	b330      	cbz	r0, 25e2 <_i2c_m_sync_transfer+0x12e>
		i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
    2594:	8863      	ldrh	r3, [r4, #2]
    2596:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
    259a:	041b      	lsls	r3, r3, #16
    259c:	0c1b      	lsrs	r3, r3, #16
    259e:	8063      	strh	r3, [r4, #2]
}
    25a0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    25a4:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
    25a8:	e7c6      	b.n	2538 <_i2c_m_sync_transfer+0x84>
		                              ((msg->addr & SEVEN_ADDR_MASK) << 1) | (msg->flags & I2C_M_RD ? I2C_M_RD : 0x0)
    25aa:	f8b4 9002 	ldrh.w	r9, [r4, #2]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    25ae:	2104      	movs	r1, #4
    25b0:	47c0      	blx	r8
    25b2:	fa1f f989 	uxth.w	r9, r9
	return ((Sercom *)hw)->I2CM.ADDR.reg;
    25b6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    25b8:	b2d2      	uxtb	r2, r2
    25ba:	f009 0901 	and.w	r9, r9, #1
    25be:	ea42 0209 	orr.w	r2, r2, r9
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    25c2:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
		hri_sercomi2cm_write_ADDR_reg(hw,
    25c6:	431a      	orrs	r2, r3
    25c8:	e7d4      	b.n	2574 <_i2c_m_sync_transfer+0xc0>
	void *   hw      = i2c_dev->hw;
    25ca:	6922      	ldr	r2, [r4, #16]
    25cc:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
    25d0:	7e11      	ldrb	r1, [r2, #24]
		if (timeout-- == 0) {
    25d2:	3b01      	subs	r3, #1
    25d4:	b2c9      	uxtb	r1, r1
    25d6:	d008      	beq.n	25ea <_i2c_m_sync_transfer+0x136>
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
    25d8:	0788      	lsls	r0, r1, #30
    25da:	d0f9      	beq.n	25d0 <_i2c_m_sync_transfer+0x11c>
		ret = _sercom_i2c_sync_analyse_flags(hw, flags, &i2c_dev->service.msg);
    25dc:	4622      	mov	r2, r4
    25de:	4630      	mov	r0, r6
    25e0:	47b8      	blx	r7
	while (i2c_dev->service.msg.flags & I2C_M_BUSY) {
    25e2:	8863      	ldrh	r3, [r4, #2]
    25e4:	05db      	lsls	r3, r3, #23
    25e6:	d4f0      	bmi.n	25ca <_i2c_m_sync_transfer+0x116>
    25e8:	e7da      	b.n	25a0 <_i2c_m_sync_transfer+0xec>
			if (msg->flags & I2C_M_STOP) {
    25ea:	886b      	ldrh	r3, [r5, #2]
    25ec:	041a      	lsls	r2, r3, #16
    25ee:	d502      	bpl.n	25f6 <_i2c_m_sync_transfer+0x142>
				_sercom_i2c_send_stop(hw);
    25f0:	4b09      	ldr	r3, [pc, #36]	@ (2618 <_i2c_m_sync_transfer+0x164>)
    25f2:	4630      	mov	r0, r6
    25f4:	4798      	blx	r3
			i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
    25f6:	8863      	ldrh	r3, [r4, #2]
    25f8:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
    25fc:	041b      	lsls	r3, r3, #16
    25fe:	0c1b      	lsrs	r3, r3, #16
    2600:	8063      	strh	r3, [r4, #2]
			return ret;
    2602:	f06f 0004 	mvn.w	r0, #4
    2606:	e7cb      	b.n	25a0 <_i2c_m_sync_transfer+0xec>
		return I2C_ERR_BUSY;
    2608:	f06f 0005 	mvn.w	r0, #5
    260c:	e7c8      	b.n	25a0 <_i2c_m_sync_transfer+0xec>
    260e:	bf00      	nop
    2610:	00003435 	.word	0x00003435
    2614:	000021b1 	.word	0x000021b1
    2618:	0000219d 	.word	0x0000219d
    261c:	00001ab5 	.word	0x00001ab5
    2620:	000020fd 	.word	0x000020fd

00002624 <_spi_m_sync_init>:

	return NULL;
}

int32_t _spi_m_sync_init(struct _spi_m_sync_dev *dev, void *const hw)
{
    2624:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
    2628:	4b43      	ldr	r3, [pc, #268]	@ (2738 <_spi_m_sync_init+0x114>)
	return NULL;
    262a:	4c44      	ldr	r4, [pc, #272]	@ (273c <_spi_m_sync_init+0x118>)
{
    262c:	4606      	mov	r6, r0
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
    262e:	4608      	mov	r0, r1
{
    2630:	460d      	mov	r5, r1
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
    2632:	4798      	blx	r3
	return NULL;
    2634:	2802      	cmp	r0, #2
    2636:	bf18      	it	ne
    2638:	2400      	movne	r4, #0
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);

	ASSERT(dev && hw);
    263a:	2e00      	cmp	r6, #0
    263c:	d05c      	beq.n	26f8 <_spi_m_sync_init+0xd4>
    263e:	1e28      	subs	r0, r5, #0
    2640:	bf18      	it	ne
    2642:	2001      	movne	r0, #1
    2644:	4f3e      	ldr	r7, [pc, #248]	@ (2740 <_spi_m_sync_init+0x11c>)
    2646:	493f      	ldr	r1, [pc, #252]	@ (2744 <_spi_m_sync_init+0x120>)
    2648:	f640 123f 	movw	r2, #2367	@ 0x93f
    264c:	47b8      	blx	r7

	if (regs == NULL) {
    264e:	46b8      	mov	r8, r7
    2650:	2c00      	cmp	r4, #0
    2652:	d06d      	beq.n	2730 <_spi_m_sync_init+0x10c>
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
    2654:	69eb      	ldr	r3, [r5, #28]
    2656:	4f3c      	ldr	r7, [pc, #240]	@ (2748 <_spi_m_sync_init+0x124>)
    2658:	f8df 90f8 	ldr.w	r9, [pc, #248]	@ 2754 <_spi_m_sync_init+0x130>
		return ERR_INVALID_ARG;
	}

	if (!hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
    265c:	f013 0f01 	tst.w	r3, #1
    2660:	d112      	bne.n	2688 <_spi_m_sync_init+0x64>
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
    2662:	4b3a      	ldr	r3, [pc, #232]	@ (274c <_spi_m_sync_init+0x128>)
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
    2664:	f8d4 a000 	ldr.w	sl, [r4]
    2668:	2103      	movs	r1, #3
    266a:	4628      	mov	r0, r5
    266c:	4798      	blx	r3
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    266e:	682b      	ldr	r3, [r5, #0]
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
    2670:	079b      	lsls	r3, r3, #30
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
    2672:	f00a 0a1c 	and.w	sl, sl, #28
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
    2676:	d503      	bpl.n	2680 <_spi_m_sync_init+0x5c>
			hri_sercomspi_clear_CTRLA_ENABLE_bit(hw);
    2678:	4b35      	ldr	r3, [pc, #212]	@ (2750 <_spi_m_sync_init+0x12c>)
    267a:	4798      	blx	r3
			hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_ENABLE);
    267c:	2102      	movs	r1, #2
    267e:	47b8      	blx	r7
		}
		hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST | mode);
    2680:	f04a 0101 	orr.w	r1, sl, #1
    2684:	4628      	mov	r0, r5
    2686:	47c8      	blx	r9
	}
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);
    2688:	2101      	movs	r1, #1
    268a:	4628      	mov	r0, r5
    268c:	47b8      	blx	r7

	dev->prvt = hw;

	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
    268e:	6823      	ldr	r3, [r4, #0]
    2690:	f8df a0c4 	ldr.w	sl, [pc, #196]	@ 2758 <_spi_m_sync_init+0x134>
	dev->prvt = hw;
    2694:	6035      	str	r5, [r6, #0]
	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
    2696:	f003 031c 	and.w	r3, r3, #28
    269a:	2b08      	cmp	r3, #8
    269c:	d12e      	bne.n	26fc <_spi_m_sync_init+0xd8>
	ASSERT(hw && regs);
    269e:	4929      	ldr	r1, [pc, #164]	@ (2744 <_spi_m_sync_init+0x120>)
    26a0:	2001      	movs	r0, #1
    26a2:	f640 121d 	movw	r2, #2333	@ 0x91d
    26a6:	47c0      	blx	r8
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    26a8:	6821      	ldr	r1, [r4, #0]
	hri_sercomspi_write_CTRLA_reg(
    26aa:	4628      	mov	r0, r5
    26ac:	ea01 010a 	and.w	r1, r1, sl
    26b0:	47c8      	blx	r9
	                              (regs->ctrlb & ~(SERCOM_SPI_CTRLB_MSSEN))
    26b2:	6863      	ldr	r3, [r4, #4]
	                                  | (SERCOM_SPI_CTRLB_RXEN | SERCOM_SPI_CTRLB_SSDE | SERCOM_SPI_CTRLB_PLOADEN));
    26b4:	f423 3308 	bic.w	r3, r3, #139264	@ 0x22000
    26b8:	f423 7310 	bic.w	r3, r3, #576	@ 0x240
	hri_sercomspi_write_CTRLB_reg(hw,
    26bc:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
    26c0:	f443 7310 	orr.w	r3, r3, #576	@ 0x240
	((Sercom *)hw)->SPI.CTRLB.reg = data;
    26c4:	606b      	str	r3, [r5, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
    26c6:	2117      	movs	r1, #23
    26c8:	47b8      	blx	r7
	hri_sercomspi_write_ADDR_reg(hw, regs->addr);
    26ca:	68a3      	ldr	r3, [r4, #8]
	((Sercom *)hw)->SPI.ADDR.reg = data;
    26cc:	626b      	str	r3, [r5, #36]	@ 0x24
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    26ce:	7b63      	ldrb	r3, [r4, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
    26d0:	f885 3030 	strb.w	r3, [r5, #48]	@ 0x30
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
    26d4:	69eb      	ldr	r3, [r5, #28]
	while (hri_sercomspi_is_syncing(hw, 0xFFFFFFFF))
    26d6:	2b00      	cmp	r3, #0
    26d8:	d1fc      	bne.n	26d4 <_spi_m_sync_init+0xb0>
	} else {
		_spi_load_regs_master(hw, regs);
	}

	/* Load character size from default hardware configuration */
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
    26da:	6863      	ldr	r3, [r4, #4]
    26dc:	f013 0f07 	tst.w	r3, #7
    26e0:	bf14      	ite	ne
    26e2:	2302      	movne	r3, #2
    26e4:	2301      	moveq	r3, #1
    26e6:	7133      	strb	r3, [r6, #4]

	dev->dummy_byte = regs->dummy_byte;
    26e8:	7ba3      	ldrb	r3, [r4, #14]
    26ea:	7be2      	ldrb	r2, [r4, #15]
    26ec:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    26f0:	80f3      	strh	r3, [r6, #6]

	return ERR_NONE;
    26f2:	2000      	movs	r0, #0
}
    26f4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ASSERT(dev && hw);
    26f8:	4630      	mov	r0, r6
    26fa:	e7a3      	b.n	2644 <_spi_m_sync_init+0x20>
	ASSERT(hw && regs);
    26fc:	4911      	ldr	r1, [pc, #68]	@ (2744 <_spi_m_sync_init+0x120>)
    26fe:	2001      	movs	r0, #1
    2700:	f640 1209 	movw	r2, #2313	@ 0x909
    2704:	47c0      	blx	r8
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    2706:	6821      	ldr	r1, [r4, #0]
	hri_sercomspi_write_CTRLA_reg(
    2708:	4628      	mov	r0, r5
    270a:	ea01 010a 	and.w	r1, r1, sl
    270e:	47c8      	blx	r9
	    (regs->ctrlb
    2710:	6863      	ldr	r3, [r4, #4]
	        | (SERCOM_SPI_CTRLB_RXEN));
    2712:	f423 3338 	bic.w	r3, r3, #188416	@ 0x2e000
    2716:	f423 7310 	bic.w	r3, r3, #576	@ 0x240
	hri_sercomspi_write_CTRLB_reg(
    271a:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
	((Sercom *)hw)->SPI.CTRLB.reg = data;
    271e:	606b      	str	r3, [r5, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
    2720:	2117      	movs	r1, #23
    2722:	47b8      	blx	r7
	hri_sercomspi_write_BAUD_reg(hw, regs->baud);
    2724:	7b23      	ldrb	r3, [r4, #12]
	((Sercom *)hw)->SPI.BAUD.reg = data;
    2726:	732b      	strb	r3, [r5, #12]
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    2728:	7b63      	ldrb	r3, [r4, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
    272a:	f885 3030 	strb.w	r3, [r5, #48]	@ 0x30
}
    272e:	e7d4      	b.n	26da <_spi_m_sync_init+0xb6>
		return ERR_INVALID_ARG;
    2730:	f06f 000c 	mvn.w	r0, #12
    2734:	e7de      	b.n	26f4 <_spi_m_sync_init+0xd0>
    2736:	bf00      	nop
    2738:	00002139 	.word	0x00002139
    273c:	000034e4 	.word	0x000034e4
    2740:	00001ab5 	.word	0x00001ab5
    2744:	00003435 	.word	0x00003435
    2748:	000020fd 	.word	0x000020fd
    274c:	000020fd 	.word	0x000020fd
    2750:	00002119 	.word	0x00002119
    2754:	0000212d 	.word	0x0000212d
    2758:	fffffefc 	.word	0xfffffefc

0000275c <_spi_m_sync_trans>:

	return ERR_NONE;
}

int32_t _spi_m_sync_trans(struct _spi_m_sync_dev *dev, const struct spi_msg *msg)
{
    275c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	void *                 hw   = dev->prvt;
    2760:	6804      	ldr	r4, [r0, #0]
	int32_t                rc   = 0;
	struct _spi_trans_ctrl ctrl = {msg->txbuf, msg->rxbuf, 0, 0, dev->char_size};
    2762:	f890 9004 	ldrb.w	r9, [r0, #4]

	ASSERT(dev && hw);
    2766:	4b29      	ldr	r3, [pc, #164]	@ (280c <_spi_m_sync_trans+0xb0>)
{
    2768:	4607      	mov	r7, r0
	ASSERT(dev && hw);
    276a:	1e20      	subs	r0, r4, #0
	struct _spi_trans_ctrl ctrl = {msg->txbuf, msg->rxbuf, 0, 0, dev->char_size};
    276c:	e9d1 5600 	ldrd	r5, r6, [r1]
	ASSERT(dev && hw);
    2770:	f640 22a3 	movw	r2, #2723	@ 0xaa3
    2774:	bf18      	it	ne
    2776:	2001      	movne	r0, #1
{
    2778:	4688      	mov	r8, r1
	ASSERT(dev && hw);
    277a:	4925      	ldr	r1, [pc, #148]	@ (2810 <_spi_m_sync_trans+0xb4>)
    277c:	4798      	blx	r3
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
    277e:	69e2      	ldr	r2, [r4, #28]

	/* If settings are not applied (pending), we can not go on */
	if (hri_sercomspi_is_syncing(
    2780:	f012 0207 	ands.w	r2, r2, #7
    2784:	d13e      	bne.n	2804 <_spi_m_sync_trans+0xa8>
	        hw, (SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE | SERCOM_SPI_SYNCBUSY_CTRLB))) {
		return ERR_BUSY;
	}

	/* SPI must be enabled to start synchronous transfer */
	if (!hri_sercomspi_get_CTRLA_ENABLE_bit(hw)) {
    2786:	4b23      	ldr	r3, [pc, #140]	@ (2814 <_spi_m_sync_trans+0xb8>)
    2788:	4620      	mov	r0, r4
    278a:	4798      	blx	r3
    278c:	b918      	cbnz	r0, 2796 <_spi_m_sync_trans+0x3a>
		return ERR_NOT_INITIALIZED;
    278e:	f06f 0013 	mvn.w	r0, #19
	}
	/* Wait until SPI bus idle */
	_spi_wait_bus_idle(hw);

	return rc;
}
    2792:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	struct _spi_trans_ctrl ctrl = {msg->txbuf, msg->rxbuf, 0, 0, dev->char_size};
    2796:	4611      	mov	r1, r2
	return ((Sercom *)hw)->SPI.INTFLAG.reg;
    2798:	7e23      	ldrb	r3, [r4, #24]
    279a:	b2d8      	uxtb	r0, r3
	if (!(iflag & SERCOM_SPI_INTFLAG_RXC)) {
    279c:	075b      	lsls	r3, r3, #29
    279e:	d40f      	bmi.n	27c0 <_spi_m_sync_trans+0x64>
			if (ctrl.rxcnt >= ctrl.txcnt) {
    27a0:	4291      	cmp	r1, r2
    27a2:	d318      	bcc.n	27d6 <_spi_m_sync_trans+0x7a>
	if (!(SERCOM_SPI_INTFLAG_DRE & iflag)) {
    27a4:	07c3      	lsls	r3, r0, #31
    27a6:	d516      	bpl.n	27d6 <_spi_m_sync_trans+0x7a>
				_spi_tx_check_and_send(hw, iflag, &ctrl, dev->dummy_byte);
    27a8:	88fb      	ldrh	r3, [r7, #6]
	if (ctrl->txbuf) {
    27aa:	b135      	cbz	r5, 27ba <_spi_m_sync_trans+0x5e>
		if (ctrl->char_size > 1) {
    27ac:	f1b9 0f01 	cmp.w	r9, #1
		data = *ctrl->txbuf++;
    27b0:	bf94      	ite	ls
    27b2:	f815 3b01 	ldrbls.w	r3, [r5], #1
			data |= (*ctrl->txbuf) << 8;
    27b6:	f835 3b02 	ldrhhi.w	r3, [r5], #2
	((Sercom *)hw)->SPI.DATA.reg = data;
    27ba:	62a3      	str	r3, [r4, #40]	@ 0x28
	ctrl->txcnt++;
    27bc:	3201      	adds	r2, #1
}
    27be:	e00a      	b.n	27d6 <_spi_m_sync_trans+0x7a>
	return ((Sercom *)hw)->SPI.DATA.reg;
    27c0:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
	if (ctrl->rxbuf) {
    27c2:	b13e      	cbz	r6, 27d4 <_spi_m_sync_trans+0x78>
		if (ctrl->char_size > 1) {
    27c4:	f1b9 0f01 	cmp.w	r9, #1
		*ctrl->rxbuf++ = (uint8_t)data;
    27c8:	7033      	strb	r3, [r6, #0]
			*ctrl->rxbuf++ = (uint8_t)(data >> 8);
    27ca:	bf85      	ittet	hi
    27cc:	0a1b      	lsrhi	r3, r3, #8
    27ce:	7073      	strbhi	r3, [r6, #1]
		*ctrl->rxbuf++ = (uint8_t)data;
    27d0:	3601      	addls	r6, #1
			*ctrl->rxbuf++ = (uint8_t)(data >> 8);
    27d2:	3602      	addhi	r6, #2
	ctrl->rxcnt++;
    27d4:	3101      	adds	r1, #1
	if (SERCOM_SPI_INTFLAG_ERROR & iflag) {
    27d6:	0600      	lsls	r0, r0, #24
    27d8:	d407      	bmi.n	27ea <_spi_m_sync_trans+0x8e>
		if (ctrl.txcnt >= msg->size && ctrl.rxcnt >= msg->size) {
    27da:	f8d8 3008 	ldr.w	r3, [r8, #8]
    27de:	4293      	cmp	r3, r2
    27e0:	d8da      	bhi.n	2798 <_spi_m_sync_trans+0x3c>
    27e2:	428b      	cmp	r3, r1
    27e4:	d8d8      	bhi.n	2798 <_spi_m_sync_trans+0x3c>
			rc = ctrl.txcnt;
    27e6:	4610      	mov	r0, r2
	while (!(hri_sercomspi_get_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_TXC | SERCOM_SPI_INTFLAG_DRE))) {
    27e8:	e006      	b.n	27f8 <_spi_m_sync_trans+0x9c>
	((Sercom *)hw)->SPI.STATUS.reg = mask;
    27ea:	f64f 73ff 	movw	r3, #65535	@ 0xffff
    27ee:	8363      	strh	r3, [r4, #26]
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    27f0:	2380      	movs	r3, #128	@ 0x80
    27f2:	7623      	strb	r3, [r4, #24]
		rc = _spi_err_check(iflag, hw);
    27f4:	f06f 0012 	mvn.w	r0, #18
	tmp = ((Sercom *)hw)->SPI.INTFLAG.reg;
    27f8:	7e23      	ldrb	r3, [r4, #24]
	while (!(hri_sercomspi_get_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_TXC | SERCOM_SPI_INTFLAG_DRE))) {
    27fa:	079b      	lsls	r3, r3, #30
    27fc:	d0fc      	beq.n	27f8 <_spi_m_sync_trans+0x9c>
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    27fe:	2303      	movs	r3, #3
    2800:	7623      	strb	r3, [r4, #24]
}
    2802:	e7c6      	b.n	2792 <_spi_m_sync_trans+0x36>
		return ERR_BUSY;
    2804:	f06f 0003 	mvn.w	r0, #3
    2808:	e7c3      	b.n	2792 <_spi_m_sync_trans+0x36>
    280a:	bf00      	nop
    280c:	00001ab5 	.word	0x00001ab5
    2810:	00003435 	.word	0x00003435
    2814:	00002105 	.word	0x00002105

00002818 <cache_init>:
/**
 * \brief Initialize cache module
 */
int32_t cache_init(void)
{
	return _cmcc_init();
    2818:	4b00      	ldr	r3, [pc, #0]	@ (281c <cache_init+0x4>)
    281a:	4718      	bx	r3
    281c:	00002841 	.word	0x00002841

00002820 <_cmcc_enable>:
	return ((Cmcc *)hw)->TYPE.reg;
}

static inline bool hri_cmcc_get_SR_CSTS_bit(const void *const hw)
{
	return (((Cmcc *)hw)->SR.reg & CMCC_SR_CSTS) >> CMCC_SR_CSTS_Pos;
    2820:	68c3      	ldr	r3, [r0, #12]
 */
static inline int32_t _cmcc_enable(const void *hw)
{
	int32_t return_value;

	if (_is_cache_disabled(hw)) {
    2822:	07db      	lsls	r3, r3, #31
    2824:	d409      	bmi.n	283a <_cmcc_enable+0x1a>
}

static inline void hri_cmcc_write_CTRL_reg(const void *const hw, hri_cmcc_ctrl_reg_t data)
{
	CMCC_CRITICAL_SECTION_ENTER();
	((Cmcc *)hw)->CTRL.reg = data;
    2826:	2301      	movs	r3, #1
    2828:	6083      	str	r3, [r0, #8]
	return (((Cmcc *)hw)->SR.reg & CMCC_SR_CSTS) >> CMCC_SR_CSTS_Pos;
    282a:	68c3      	ldr	r3, [r0, #12]
		hri_cmcc_write_CTRL_reg(hw, CMCC_CTRL_CEN);
		return_value = _is_cache_enabled(hw) == true ? ERR_NONE : ERR_FAILURE;
    282c:	f013 0f01 	tst.w	r3, #1
    2830:	bf0c      	ite	eq
    2832:	f06f 001d 	mvneq.w	r0, #29
    2836:	2000      	movne	r0, #0
    2838:	4770      	bx	lr
	} else {
		return_value = ERR_NO_CHANGE;
    283a:	f06f 0001 	mvn.w	r0, #1
	}

	return return_value;
}
    283e:	4770      	bx	lr

00002840 <_cmcc_init>:
	((Cmcc *)hw)->CTRL.reg = data;
    2840:	4a0c      	ldr	r2, [pc, #48]	@ (2874 <_cmcc_init+0x34>)
 * This function does low level cache configuration.
 *
 * \return initialize status
 */
int32_t _cmcc_init(void)
{
    2842:	b508      	push	{r3, lr}
    2844:	2300      	movs	r3, #0
    2846:	6093      	str	r3, [r2, #8]
	return (((Cmcc *)hw)->SR.reg & CMCC_SR_CSTS) >> CMCC_SR_CSTS_Pos;
    2848:	68d3      	ldr	r3, [r2, #12]
 * \brief Cache disable
 */
static inline int32_t _cmcc_disable(const void *hw)
{
	hri_cmcc_write_CTRL_reg(hw, (CMCC_DISABLE << CMCC_CTRL_CEN_Pos));
	while (!(_is_cache_disabled(hw)))
    284a:	07d9      	lsls	r1, r3, #31
    284c:	d4fc      	bmi.n	2848 <_cmcc_init+0x8>
    284e:	68d3      	ldr	r3, [r2, #12]
	int32_t return_value;

	_cmcc_disable(CMCC);

	if (_is_cache_disabled(CMCC)) {
    2850:	07db      	lsls	r3, r3, #31
    2852:	d40c      	bmi.n	286e <_cmcc_init+0x2e>
	((Cmcc *)hw)->CFG.reg = data;
    2854:	2320      	movs	r3, #32
    2856:	6053      	str	r3, [r2, #4]
		hri_cmcc_write_CFG_reg(
		    CMCC,
		    (CMCC_CFG_CSIZESW(CONF_CMCC_CACHE_SIZE) | (CONF_CMCC_DATA_CACHE_DISABLE << CMCC_CFG_DCDIS_Pos)
		     | (CONF_CMCC_INST_CACHE_DISABLE << CMCC_CFG_ICDIS_Pos) | (CONF_CMCC_CLK_GATING_DISABLE)));

		_cmcc_enable(CMCC);
    2858:	4806      	ldr	r0, [pc, #24]	@ (2874 <_cmcc_init+0x34>)
    285a:	4b07      	ldr	r3, [pc, #28]	@ (2878 <_cmcc_init+0x38>)
    285c:	4798      	blx	r3
	return (((Cmcc *)hw)->SR.reg & CMCC_SR_CSTS) >> CMCC_SR_CSTS_Pos;
    285e:	68d3      	ldr	r3, [r2, #12]
		return_value = _is_cache_enabled(CMCC) == true ? ERR_NONE : ERR_FAILURE;
    2860:	f013 0f01 	tst.w	r3, #1
    2864:	bf0c      	ite	eq
    2866:	f06f 001d 	mvneq.w	r0, #29
    286a:	2000      	movne	r0, #0
	} else {
		return_value = ERR_NOT_INITIALIZED;
	}

	return return_value;
}
    286c:	bd08      	pop	{r3, pc}
		return_value = ERR_NOT_INITIALIZED;
    286e:	f06f 0013 	mvn.w	r0, #19
    2872:	e7fb      	b.n	286c <_cmcc_init+0x2c>
    2874:	41006000 	.word	0x41006000
    2878:	00002821 	.word	0x00002821

0000287c <Dummy_Handler>:
/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
	while (1) {
    287c:	e7fe      	b.n	287c <Dummy_Handler>
	...

00002880 <Reset_Handler>:
	if (pSrc != pDest) {
    2880:	4918      	ldr	r1, [pc, #96]	@ (28e4 <Reset_Handler+0x64>)
    2882:	4819      	ldr	r0, [pc, #100]	@ (28e8 <Reset_Handler+0x68>)
    2884:	4281      	cmp	r1, r0
{
    2886:	b510      	push	{r4, lr}
	if (pSrc != pDest) {
    2888:	d00a      	beq.n	28a0 <Reset_Handler+0x20>
			*pDest++ = *pSrc++;
    288a:	4b18      	ldr	r3, [pc, #96]	@ (28ec <Reset_Handler+0x6c>)
    288c:	1cda      	adds	r2, r3, #3
    288e:	1a12      	subs	r2, r2, r0
    2890:	f022 0203 	bic.w	r2, r2, #3
    2894:	1ec4      	subs	r4, r0, #3
    2896:	429c      	cmp	r4, r3
    2898:	bf88      	it	hi
    289a:	2200      	movhi	r2, #0
    289c:	4b14      	ldr	r3, [pc, #80]	@ (28f0 <Reset_Handler+0x70>)
    289e:	4798      	blx	r3
		*pDest++ = 0;
    28a0:	4b14      	ldr	r3, [pc, #80]	@ (28f4 <Reset_Handler+0x74>)
    28a2:	4815      	ldr	r0, [pc, #84]	@ (28f8 <Reset_Handler+0x78>)
    28a4:	1cda      	adds	r2, r3, #3
    28a6:	1a12      	subs	r2, r2, r0
    28a8:	1ec1      	subs	r1, r0, #3
    28aa:	f022 0203 	bic.w	r2, r2, #3
    28ae:	4299      	cmp	r1, r3
    28b0:	bf88      	it	hi
    28b2:	2200      	movhi	r2, #0
    28b4:	4b11      	ldr	r3, [pc, #68]	@ (28fc <Reset_Handler+0x7c>)
    28b6:	2100      	movs	r1, #0
    28b8:	4798      	blx	r3
	SCB->VTOR = ((uint32_t)pSrc & SCB_VTOR_TBLOFF_Msk);
    28ba:	4a11      	ldr	r2, [pc, #68]	@ (2900 <Reset_Handler+0x80>)
    28bc:	4b11      	ldr	r3, [pc, #68]	@ (2904 <Reset_Handler+0x84>)
    28be:	f022 027f 	bic.w	r2, r2, #127	@ 0x7f
    28c2:	609a      	str	r2, [r3, #8]
	SCB->CPACR |= (0xFu << 20);
    28c4:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
    28c8:	f442 0270 	orr.w	r2, r2, #15728640	@ 0xf00000
    28cc:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    28d0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    28d4:	f3bf 8f6f 	isb	sy
	__libc_init_array();
    28d8:	4b0b      	ldr	r3, [pc, #44]	@ (2908 <Reset_Handler+0x88>)
    28da:	4798      	blx	r3
	main();
    28dc:	4b0b      	ldr	r3, [pc, #44]	@ (290c <Reset_Handler+0x8c>)
    28de:	4798      	blx	r3
	while (1)
    28e0:	e7fe      	b.n	28e0 <Reset_Handler+0x60>
    28e2:	bf00      	nop
    28e4:	00003544 	.word	0x00003544
    28e8:	20000000 	.word	0x20000000
    28ec:	20000004 	.word	0x20000004
    28f0:	000032cd 	.word	0x000032cd
    28f4:	20020678 	.word	0x20020678
    28f8:	20000004 	.word	0x20000004
    28fc:	00003275 	.word	0x00003275
    2900:	00000000 	.word	0x00000000
    2904:	e000ed00 	.word	0xe000ed00
    2908:	00003285 	.word	0x00003285
    290c:	000002f1 	.word	0x000002f1

00002910 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
    2910:	4b00      	ldr	r3, [pc, #0]	@ (2914 <atmel_start_init+0x4>)
    2912:	4718      	bx	r3
    2914:	00002015 	.word	0x00002015

00002918 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
    2918:	4907      	ldr	r1, [pc, #28]	@ (2938 <prvIdleTask+0x20>)
				taskYIELD();
    291a:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
    291e:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
    2922:	6808      	ldr	r0, [r1, #0]
    2924:	2801      	cmp	r0, #1
    2926:	d9fc      	bls.n	2922 <prvIdleTask+0xa>
				taskYIELD();
    2928:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
    292c:	f3bf 8f4f 	dsb	sy
    2930:	f3bf 8f6f 	isb	sy
    2934:	e7f5      	b.n	2922 <prvIdleTask+0xa>
    2936:	bf00      	nop
    2938:	2002058c 	.word	0x2002058c

0000293c <prvAddCurrentTaskToDelayedList>:

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList(TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely)
{
    293c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	TickType_t       xTimeToWake;
	const TickType_t xConstTickCount = xTickCount;
    2940:	4c14      	ldr	r4, [pc, #80]	@ (2994 <prvAddCurrentTaskToDelayedList+0x58>)
	}
#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
    2942:	4b15      	ldr	r3, [pc, #84]	@ (2998 <prvAddCurrentTaskToDelayedList+0x5c>)
	const TickType_t xConstTickCount = xTickCount;
    2944:	6e65      	ldr	r5, [r4, #100]	@ 0x64
{
    2946:	4606      	mov	r6, r0
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
    2948:	6ea0      	ldr	r0, [r4, #104]	@ 0x68
    294a:	3004      	adds	r0, #4
{
    294c:	460f      	mov	r7, r1
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
    294e:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

#if (INCLUDE_vTaskSuspend == 1)
	{
		if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
    2950:	1c73      	adds	r3, r6, #1
    2952:	d108      	bne.n	2966 <prvAddCurrentTaskToDelayedList+0x2a>
    2954:	b13f      	cbz	r7, 2966 <prvAddCurrentTaskToDelayedList+0x2a>
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
    2956:	6ea1      	ldr	r1, [r4, #104]	@ 0x68
    2958:	4b10      	ldr	r3, [pc, #64]	@ (299c <prvAddCurrentTaskToDelayedList+0x60>)
    295a:	3104      	adds	r1, #4
    295c:	f104 006c 	add.w	r0, r4, #108	@ 0x6c

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		(void)xCanBlockIndefinitely;
	}
#endif /* INCLUDE_vTaskSuspend */
}
    2960:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
    2964:	4718      	bx	r3
			listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);
    2966:	6ea3      	ldr	r3, [r4, #104]	@ 0x68
    2968:	19ad      	adds	r5, r5, r6
    296a:	605d      	str	r5, [r3, #4]
			if (xTimeToWake < xConstTickCount) {
    296c:	4b0c      	ldr	r3, [pc, #48]	@ (29a0 <prvAddCurrentTaskToDelayedList+0x64>)
    296e:	d304      	bcc.n	297a <prvAddCurrentTaskToDelayedList+0x3e>
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
    2970:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
    2974:	6ea1      	ldr	r1, [r4, #104]	@ 0x68
    2976:	3104      	adds	r1, #4
    2978:	e7f2      	b.n	2960 <prvAddCurrentTaskToDelayedList+0x24>
				vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));
    297a:	f8d4 0084 	ldr.w	r0, [r4, #132]	@ 0x84
    297e:	6ea1      	ldr	r1, [r4, #104]	@ 0x68
    2980:	3104      	adds	r1, #4
    2982:	4798      	blx	r3
				if (xTimeToWake < xNextTaskUnblockTime) {
    2984:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
    2988:	42ab      	cmp	r3, r5
					xNextTaskUnblockTime = xTimeToWake;
    298a:	bf88      	it	hi
    298c:	f8c4 5088 	strhi.w	r5, [r4, #136]	@ 0x88
}
    2990:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2994:	2002058c 	.word	0x2002058c
    2998:	00000989 	.word	0x00000989
    299c:	00000945 	.word	0x00000945
    29a0:	0000095b 	.word	0x0000095b

000029a4 <prvResetNextTaskUnblockTime>:
	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    29a4:	4b07      	ldr	r3, [pc, #28]	@ (29c4 <prvResetNextTaskUnblockTime+0x20>)
    29a6:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
    29aa:	6812      	ldr	r2, [r2, #0]
    29ac:	b922      	cbnz	r2, 29b8 <prvResetNextTaskUnblockTime+0x14>
		xNextTaskUnblockTime = portMAX_DELAY;
    29ae:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
    29b2:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
}
    29b6:	4770      	bx	lr
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    29b8:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
    29bc:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
    29be:	68d2      	ldr	r2, [r2, #12]
    29c0:	6852      	ldr	r2, [r2, #4]
    29c2:	e7f6      	b.n	29b2 <prvResetNextTaskUnblockTime+0xe>
    29c4:	2002058c 	.word	0x2002058c

000029c8 <xTaskCreate>:
{
    29c8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		pxStack = (StackType_t *)pvPortMalloc(
    29cc:	0095      	lsls	r5, r2, #2
    29ce:	4c59      	ldr	r4, [pc, #356]	@ (2b34 <xTaskCreate+0x16c>)
{
    29d0:	4607      	mov	r7, r0
		pxStack = (StackType_t *)pvPortMalloc(
    29d2:	4628      	mov	r0, r5
{
    29d4:	4689      	mov	r9, r1
    29d6:	4698      	mov	r8, r3
		pxStack = (StackType_t *)pvPortMalloc(
    29d8:	47a0      	blx	r4
		if (pxStack != NULL) {
    29da:	4606      	mov	r6, r0
    29dc:	b918      	cbnz	r0, 29e6 <xTaskCreate+0x1e>
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    29de:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
}
    29e2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			pxNewTCB = (TCB_t *)pvPortMalloc(
    29e6:	2054      	movs	r0, #84	@ 0x54
    29e8:	47a0      	blx	r4
			if (pxNewTCB != NULL) {
    29ea:	4604      	mov	r4, r0
    29ec:	2800      	cmp	r0, #0
    29ee:	f000 809c 	beq.w	2b2a <xTaskCreate+0x162>
				pxNewTCB->pxStack = pxStack;
    29f2:	6306      	str	r6, [r0, #48]	@ 0x30
		(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)ulStackDepth * sizeof(StackType_t));
    29f4:	462a      	mov	r2, r5
    29f6:	4b50      	ldr	r3, [pc, #320]	@ (2b38 <xTaskCreate+0x170>)
    29f8:	4630      	mov	r0, r6
    29fa:	21a5      	movs	r1, #165	@ 0xa5
    29fc:	4798      	blx	r3
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
    29fe:	6b26      	ldr	r6, [r4, #48]	@ 0x30
    2a00:	3d04      	subs	r5, #4
    2a02:	442e      	add	r6, r5
    2a04:	f109 33ff 	add.w	r3, r9, #4294967295	@ 0xffffffff
		                      & (~(
    2a08:	f026 0607 	bic.w	r6, r6, #7
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
    2a0c:	f104 0233 	add.w	r2, r4, #51	@ 0x33
    2a10:	f109 0907 	add.w	r9, r9, #7
		pxNewTCB->pcTaskName[x] = pcName[x];
    2a14:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    2a18:	f802 1f01 	strb.w	r1, [r2, #1]!
		if (pcName[x] == 0x00) {
    2a1c:	b109      	cbz	r1, 2a22 <xTaskCreate+0x5a>
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
    2a1e:	454b      	cmp	r3, r9
    2a20:	d1f8      	bne.n	2a14 <xTaskCreate+0x4c>
	if (uxPriority >= (UBaseType_t)configMAX_PRIORITIES) {
    2a22:	9d0a      	ldr	r5, [sp, #40]	@ 0x28
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
    2a24:	f8df a134 	ldr.w	sl, [pc, #308]	@ 2b5c <xTaskCreate+0x194>
	if (uxPriority >= (UBaseType_t)configMAX_PRIORITIES) {
    2a28:	2d04      	cmp	r5, #4
    2a2a:	bf28      	it	cs
    2a2c:	2504      	movcs	r5, #4
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
    2a2e:	f04f 0b00 	mov.w	fp, #0
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
    2a32:	f104 0904 	add.w	r9, r4, #4
		pxNewTCB->uxMutexesHeld  = 0;
    2a36:	e9c4 5b11 	strd	r5, fp, [r4, #68]	@ 0x44
	pxNewTCB->uxPriority = uxPriority;
    2a3a:	62e5      	str	r5, [r4, #44]	@ 0x2c
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
    2a3c:	4648      	mov	r0, r9
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
    2a3e:	f884 b03b 	strb.w	fp, [r4, #59]	@ 0x3b
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
    2a42:	47d0      	blx	sl
	listSET_LIST_ITEM_VALUE(
    2a44:	f1c5 0505 	rsb	r5, r5, #5
	vListInitialiseItem(&(pxNewTCB->xEventListItem));
    2a48:	f104 0018 	add.w	r0, r4, #24
    2a4c:	47d0      	blx	sl
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
    2a4e:	4b3b      	ldr	r3, [pc, #236]	@ (2b3c <xTaskCreate+0x174>)
		pxNewTCB->ulNotifiedValue = 0;
    2a50:	f8c4 b04c 	str.w	fp, [r4, #76]	@ 0x4c
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem), pxNewTCB);
    2a54:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE(
    2a56:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xEventListItem), pxNewTCB);
    2a58:	6264      	str	r4, [r4, #36]	@ 0x24
		pxNewTCB->ucNotifyState   = taskNOT_WAITING_NOTIFICATION;
    2a5a:	f884 b050 	strb.w	fp, [r4, #80]	@ 0x50
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
    2a5e:	4642      	mov	r2, r8
    2a60:	4639      	mov	r1, r7
    2a62:	4630      	mov	r0, r6
    2a64:	4798      	blx	r3
	if ((void *)pxCreatedTask != NULL) {
    2a66:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
    2a68:	6020      	str	r0, [r4, #0]
	if ((void *)pxCreatedTask != NULL) {
    2a6a:	b103      	cbz	r3, 2a6e <xTaskCreate+0xa6>
		*pxCreatedTask = (TaskHandle_t)pxNewTCB;
    2a6c:	601c      	str	r4, [r3, #0]
		uxCurrentNumberOfTasks++;
    2a6e:	4d34      	ldr	r5, [pc, #208]	@ (2b40 <xTaskCreate+0x178>)
	taskENTER_CRITICAL();
    2a70:	4b34      	ldr	r3, [pc, #208]	@ (2b44 <xTaskCreate+0x17c>)
    2a72:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
    2a74:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    2a78:	3301      	adds	r3, #1
    2a7a:	f8c5 308c 	str.w	r3, [r5, #140]	@ 0x8c
		if (pxCurrentTCB == NULL) {
    2a7e:	6eae      	ldr	r6, [r5, #104]	@ 0x68
    2a80:	2e00      	cmp	r6, #0
    2a82:	d147      	bne.n	2b14 <xTaskCreate+0x14c>
			pxCurrentTCB = pxNewTCB;
    2a84:	66ac      	str	r4, [r5, #104]	@ 0x68
			if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
    2a86:	f8d5 308c 	ldr.w	r3, [r5, #140]	@ 0x8c
    2a8a:	2b01      	cmp	r3, #1
    2a8c:	d119      	bne.n	2ac2 <xTaskCreate+0xfa>
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
    2a8e:	4f2e      	ldr	r7, [pc, #184]	@ (2b48 <xTaskCreate+0x180>)
    2a90:	46a8      	mov	r8, r5
    2a92:	4640      	mov	r0, r8
	for (uxPriority = (UBaseType_t)0U; uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
    2a94:	3601      	adds	r6, #1
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
    2a96:	47b8      	blx	r7
	for (uxPriority = (UBaseType_t)0U; uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
    2a98:	2e05      	cmp	r6, #5
    2a9a:	f108 0814 	add.w	r8, r8, #20
    2a9e:	d1f8      	bne.n	2a92 <xTaskCreate+0xca>
	vListInitialise(&xDelayedTaskList1);
    2aa0:	4e2a      	ldr	r6, [pc, #168]	@ (2b4c <xTaskCreate+0x184>)
    2aa2:	4630      	mov	r0, r6
	vListInitialise(&xDelayedTaskList2);
    2aa4:	f106 0814 	add.w	r8, r6, #20
	vListInitialise(&xDelayedTaskList1);
    2aa8:	47b8      	blx	r7
	vListInitialise(&xDelayedTaskList2);
    2aaa:	4640      	mov	r0, r8
    2aac:	47b8      	blx	r7
	vListInitialise(&xPendingReadyList);
    2aae:	f106 0028 	add.w	r0, r6, #40	@ 0x28
    2ab2:	47b8      	blx	r7
		vListInitialise(&xSuspendedTaskList);
    2ab4:	f1a6 0024 	sub.w	r0, r6, #36	@ 0x24
    2ab8:	47b8      	blx	r7
	pxDelayedTaskList         = &xDelayedTaskList1;
    2aba:	f8c5 6084 	str.w	r6, [r5, #132]	@ 0x84
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2abe:	f8c5 8080 	str.w	r8, [r5, #128]	@ 0x80
		uxTaskNumber++;
    2ac2:	f8d5 30d0 	ldr.w	r3, [r5, #208]	@ 0xd0
		prvAddTaskToReadyList(pxNewTCB);
    2ac6:	f8d5 20d4 	ldr.w	r2, [r5, #212]	@ 0xd4
		uxTaskNumber++;
    2aca:	3301      	adds	r3, #1
    2acc:	f8c5 30d0 	str.w	r3, [r5, #208]	@ 0xd0
			pxNewTCB->uxTCBNumber = uxTaskNumber;
    2ad0:	63e3      	str	r3, [r4, #60]	@ 0x3c
		prvAddTaskToReadyList(pxNewTCB);
    2ad2:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
    2ad4:	2014      	movs	r0, #20
    2ad6:	4293      	cmp	r3, r2
    2ad8:	bf88      	it	hi
    2ada:	f8c5 30d4 	strhi.w	r3, [r5, #212]	@ 0xd4
    2ade:	fb00 5003 	mla	r0, r0, r3, r5
    2ae2:	4649      	mov	r1, r9
    2ae4:	4b1a      	ldr	r3, [pc, #104]	@ (2b50 <xTaskCreate+0x188>)
    2ae6:	4798      	blx	r3
	taskEXIT_CRITICAL();
    2ae8:	4b1a      	ldr	r3, [pc, #104]	@ (2b54 <xTaskCreate+0x18c>)
    2aea:	4798      	blx	r3
	if (xSchedulerRunning != pdFALSE) {
    2aec:	f8d5 30cc 	ldr.w	r3, [r5, #204]	@ 0xcc
    2af0:	b173      	cbz	r3, 2b10 <xTaskCreate+0x148>
		if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority) {
    2af2:	6eab      	ldr	r3, [r5, #104]	@ 0x68
    2af4:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    2af6:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
    2af8:	429a      	cmp	r2, r3
    2afa:	d209      	bcs.n	2b10 <xTaskCreate+0x148>
			taskYIELD_IF_USING_PREEMPTION();
    2afc:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
    2b00:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
    2b04:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
    2b08:	f3bf 8f4f 	dsb	sy
    2b0c:	f3bf 8f6f 	isb	sy
		xReturn = pdPASS;
    2b10:	2001      	movs	r0, #1
	return xReturn;
    2b12:	e766      	b.n	29e2 <xTaskCreate+0x1a>
			if (xSchedulerRunning == pdFALSE) {
    2b14:	f8d5 20cc 	ldr.w	r2, [r5, #204]	@ 0xcc
				if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority) {
    2b18:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
			if (xSchedulerRunning == pdFALSE) {
    2b1a:	2a00      	cmp	r2, #0
    2b1c:	d1d1      	bne.n	2ac2 <xTaskCreate+0xfa>
				if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority) {
    2b1e:	6eaa      	ldr	r2, [r5, #104]	@ 0x68
    2b20:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
    2b22:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
    2b24:	bf98      	it	ls
    2b26:	66ac      	strls	r4, [r5, #104]	@ 0x68
    2b28:	e7cb      	b.n	2ac2 <xTaskCreate+0xfa>
				vPortFree(pxStack);
    2b2a:	4b0b      	ldr	r3, [pc, #44]	@ (2b58 <xTaskCreate+0x190>)
    2b2c:	4630      	mov	r0, r6
    2b2e:	4798      	blx	r3
	if (pxNewTCB != NULL) {
    2b30:	e755      	b.n	29de <xTaskCreate+0x16>
    2b32:	bf00      	nop
    2b34:	00000d69 	.word	0x00000d69
    2b38:	00003275 	.word	0x00003275
    2b3c:	00000a35 	.word	0x00000a35
    2b40:	2002058c 	.word	0x2002058c
    2b44:	00000a85 	.word	0x00000a85
    2b48:	00000929 	.word	0x00000929
    2b4c:	2002061c 	.word	0x2002061c
    2b50:	00000945 	.word	0x00000945
    2b54:	00000ac5 	.word	0x00000ac5
    2b58:	00000dbd 	.word	0x00000dbd
    2b5c:	0000093f 	.word	0x0000093f

00002b60 <vTaskStartScheduler>:
{
    2b60:	b573      	push	{r0, r1, r4, r5, r6, lr}
		xReturn = xTaskCreate(prvIdleTask,
    2b62:	4c19      	ldr	r4, [pc, #100]	@ (2bc8 <vTaskStartScheduler+0x68>)
    2b64:	4919      	ldr	r1, [pc, #100]	@ (2bcc <vTaskStartScheduler+0x6c>)
    2b66:	481a      	ldr	r0, [pc, #104]	@ (2bd0 <vTaskStartScheduler+0x70>)
    2b68:	4e1a      	ldr	r6, [pc, #104]	@ (2bd4 <vTaskStartScheduler+0x74>)
    2b6a:	f104 03dc 	add.w	r3, r4, #220	@ 0xdc
    2b6e:	2500      	movs	r5, #0
    2b70:	9301      	str	r3, [sp, #4]
    2b72:	9500      	str	r5, [sp, #0]
    2b74:	462b      	mov	r3, r5
    2b76:	2240      	movs	r2, #64	@ 0x40
    2b78:	47b0      	blx	r6
		if (xReturn == pdPASS) {
    2b7a:	2801      	cmp	r0, #1
    2b7c:	d117      	bne.n	2bae <vTaskStartScheduler+0x4e>
			xReturn = xTimerCreateTimerTask();
    2b7e:	4b16      	ldr	r3, [pc, #88]	@ (2bd8 <vTaskStartScheduler+0x78>)
    2b80:	4798      	blx	r3
	if (xReturn == pdPASS) {
    2b82:	2801      	cmp	r0, #1
    2b84:	d113      	bne.n	2bae <vTaskStartScheduler+0x4e>
    2b86:	f04f 0380 	mov.w	r3, #128	@ 0x80
    2b8a:	f383 8811 	msr	BASEPRI, r3
    2b8e:	f3bf 8f6f 	isb	sy
    2b92:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
    2b96:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
    2b9a:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
		if (xPortStartScheduler() != pdFALSE) {
    2b9e:	4b0f      	ldr	r3, [pc, #60]	@ (2bdc <vTaskStartScheduler+0x7c>)
		xSchedulerRunning    = pdTRUE;
    2ba0:	f8c4 00cc 	str.w	r0, [r4, #204]	@ 0xcc
		xTickCount           = (TickType_t)0U;
    2ba4:	6665      	str	r5, [r4, #100]	@ 0x64
}
    2ba6:	b002      	add	sp, #8
    2ba8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		if (xPortStartScheduler() != pdFALSE) {
    2bac:	4718      	bx	r3
		configASSERT(xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY);
    2bae:	3001      	adds	r0, #1
    2bb0:	d108      	bne.n	2bc4 <vTaskStartScheduler+0x64>
    2bb2:	f04f 0380 	mov.w	r3, #128	@ 0x80
    2bb6:	f383 8811 	msr	BASEPRI, r3
    2bba:	f3bf 8f6f 	isb	sy
    2bbe:	f3bf 8f4f 	dsb	sy
    2bc2:	e7fe      	b.n	2bc2 <vTaskStartScheduler+0x62>
}
    2bc4:	b002      	add	sp, #8
    2bc6:	bd70      	pop	{r4, r5, r6, pc}
    2bc8:	2002058c 	.word	0x2002058c
    2bcc:	00003450 	.word	0x00003450
    2bd0:	00002919 	.word	0x00002919
    2bd4:	000029c9 	.word	0x000029c9
    2bd8:	000016d1 	.word	0x000016d1
    2bdc:	00000b9d 	.word	0x00000b9d

00002be0 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
    2be0:	4a03      	ldr	r2, [pc, #12]	@ (2bf0 <vTaskSuspendAll+0x10>)
    2be2:	f8d2 30d8 	ldr.w	r3, [r2, #216]	@ 0xd8
    2be6:	3301      	adds	r3, #1
    2be8:	f8c2 30d8 	str.w	r3, [r2, #216]	@ 0xd8
}
    2bec:	4770      	bx	lr
    2bee:	bf00      	nop
    2bf0:	2002058c 	.word	0x2002058c

00002bf4 <xTaskGetTickCount>:
		xTicks = xTickCount;
    2bf4:	4b01      	ldr	r3, [pc, #4]	@ (2bfc <xTaskGetTickCount+0x8>)
    2bf6:	6e58      	ldr	r0, [r3, #100]	@ 0x64
}
    2bf8:	4770      	bx	lr
    2bfa:	bf00      	nop
    2bfc:	2002058c 	.word	0x2002058c

00002c00 <xTaskIncrementTick>:
{
    2c00:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    2c04:	4c39      	ldr	r4, [pc, #228]	@ (2cec <xTaskIncrementTick+0xec>)
    2c06:	f8d4 30d8 	ldr.w	r3, [r4, #216]	@ 0xd8
    2c0a:	2b00      	cmp	r3, #0
    2c0c:	d166      	bne.n	2cdc <xTaskIncrementTick+0xdc>
		const TickType_t xConstTickCount = xTickCount + (TickType_t)1;
    2c0e:	6e67      	ldr	r7, [r4, #100]	@ 0x64
    2c10:	3701      	adds	r7, #1
		xTickCount = xConstTickCount;
    2c12:	6667      	str	r7, [r4, #100]	@ 0x64
		if (xConstTickCount
    2c14:	b9df      	cbnz	r7, 2c4e <xTaskIncrementTick+0x4e>
			taskSWITCH_DELAYED_LISTS();
    2c16:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
    2c1a:	681b      	ldr	r3, [r3, #0]
    2c1c:	b143      	cbz	r3, 2c30 <xTaskIncrementTick+0x30>
    2c1e:	f04f 0380 	mov.w	r3, #128	@ 0x80
    2c22:	f383 8811 	msr	BASEPRI, r3
    2c26:	f3bf 8f6f 	isb	sy
    2c2a:	f3bf 8f4f 	dsb	sy
    2c2e:	e7fe      	b.n	2c2e <xTaskIncrementTick+0x2e>
    2c30:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
    2c34:	f8d4 2080 	ldr.w	r2, [r4, #128]	@ 0x80
    2c38:	f8c4 2084 	str.w	r2, [r4, #132]	@ 0x84
    2c3c:	f8c4 3080 	str.w	r3, [r4, #128]	@ 0x80
    2c40:	f8d4 30e0 	ldr.w	r3, [r4, #224]	@ 0xe0
    2c44:	3301      	adds	r3, #1
    2c46:	f8c4 30e0 	str.w	r3, [r4, #224]	@ 0xe0
    2c4a:	4b29      	ldr	r3, [pc, #164]	@ (2cf0 <xTaskIncrementTick+0xf0>)
    2c4c:	4798      	blx	r3
		if (xConstTickCount >= xNextTaskUnblockTime) {
    2c4e:	f8d4 3088 	ldr.w	r3, [r4, #136]	@ 0x88
    2c52:	42bb      	cmp	r3, r7
	BaseType_t xSwitchRequired = pdFALSE;
    2c54:	f04f 0500 	mov.w	r5, #0
		if (xConstTickCount >= xNextTaskUnblockTime) {
    2c58:	d90f      	bls.n	2c7a <xTaskIncrementTick+0x7a>
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1) {
    2c5a:	6ea3      	ldr	r3, [r4, #104]	@ 0x68
    2c5c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
    2c5e:	2214      	movs	r2, #20
    2c60:	4353      	muls	r3, r2
    2c62:	58e3      	ldr	r3, [r4, r3]
				xSwitchRequired = pdTRUE;
    2c64:	2b02      	cmp	r3, #2
    2c66:	bf28      	it	cs
    2c68:	2501      	movcs	r5, #1
		if (xYieldPending != pdFALSE) {
    2c6a:	f8d4 30e8 	ldr.w	r3, [r4, #232]	@ 0xe8
			xSwitchRequired = pdTRUE;
    2c6e:	2b00      	cmp	r3, #0
}
    2c70:	bf0c      	ite	eq
    2c72:	4628      	moveq	r0, r5
    2c74:	2001      	movne	r0, #1
    2c76:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					(void)uxListRemove(&(pxTCB->xStateListItem));
    2c7a:	f8df 9078 	ldr.w	r9, [pc, #120]	@ 2cf4 <xTaskIncrementTick+0xf4>
					prvAddTaskToReadyList(pxTCB);
    2c7e:	f8df a078 	ldr.w	sl, [pc, #120]	@ 2cf8 <xTaskIncrementTick+0xf8>
    2c82:	f04f 0b14 	mov.w	fp, #20
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    2c86:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
    2c8a:	681b      	ldr	r3, [r3, #0]
    2c8c:	b923      	cbnz	r3, 2c98 <xTaskIncrementTick+0x98>
					    = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2c8e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
						xNextTaskUnblockTime = xItemValue;
    2c92:	f8c4 3088 	str.w	r3, [r4, #136]	@ 0x88
						break;
    2c96:	e7e0      	b.n	2c5a <xTaskIncrementTick+0x5a>
					pxTCB      = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    2c98:	f8d4 3084 	ldr.w	r3, [r4, #132]	@ 0x84
    2c9c:	68db      	ldr	r3, [r3, #12]
    2c9e:	68de      	ldr	r6, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
    2ca0:	6873      	ldr	r3, [r6, #4]
					if (xConstTickCount < xItemValue) {
    2ca2:	429f      	cmp	r7, r3
    2ca4:	d3f5      	bcc.n	2c92 <xTaskIncrementTick+0x92>
					(void)uxListRemove(&(pxTCB->xStateListItem));
    2ca6:	f106 0804 	add.w	r8, r6, #4
    2caa:	4640      	mov	r0, r8
    2cac:	47c8      	blx	r9
					if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
    2cae:	6ab3      	ldr	r3, [r6, #40]	@ 0x28
    2cb0:	b113      	cbz	r3, 2cb8 <xTaskIncrementTick+0xb8>
						(void)uxListRemove(&(pxTCB->xEventListItem));
    2cb2:	f106 0018 	add.w	r0, r6, #24
    2cb6:	47c8      	blx	r9
					prvAddTaskToReadyList(pxTCB);
    2cb8:	6af0      	ldr	r0, [r6, #44]	@ 0x2c
    2cba:	f8d4 30d4 	ldr.w	r3, [r4, #212]	@ 0xd4
    2cbe:	4298      	cmp	r0, r3
    2cc0:	bf88      	it	hi
    2cc2:	f8c4 00d4 	strhi.w	r0, [r4, #212]	@ 0xd4
    2cc6:	4641      	mov	r1, r8
    2cc8:	fb0b 4000 	mla	r0, fp, r0, r4
    2ccc:	47d0      	blx	sl
						if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    2cce:	6ea3      	ldr	r3, [r4, #104]	@ 0x68
    2cd0:	6af2      	ldr	r2, [r6, #44]	@ 0x2c
    2cd2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
							xSwitchRequired = pdTRUE;
    2cd4:	429a      	cmp	r2, r3
    2cd6:	bf28      	it	cs
    2cd8:	2501      	movcs	r5, #1
    2cda:	e7d4      	b.n	2c86 <xTaskIncrementTick+0x86>
		++uxPendedTicks;
    2cdc:	f8d4 30e4 	ldr.w	r3, [r4, #228]	@ 0xe4
    2ce0:	3301      	adds	r3, #1
    2ce2:	f8c4 30e4 	str.w	r3, [r4, #228]	@ 0xe4
	BaseType_t xSwitchRequired = pdFALSE;
    2ce6:	2500      	movs	r5, #0
    2ce8:	e7bf      	b.n	2c6a <xTaskIncrementTick+0x6a>
    2cea:	bf00      	nop
    2cec:	2002058c 	.word	0x2002058c
    2cf0:	000029a5 	.word	0x000029a5
    2cf4:	00000989 	.word	0x00000989
    2cf8:	00000945 	.word	0x00000945

00002cfc <xTaskResumeAll>:
{
    2cfc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT(uxSchedulerSuspended);
    2d00:	4c33      	ldr	r4, [pc, #204]	@ (2dd0 <xTaskResumeAll+0xd4>)
    2d02:	f8d4 30d8 	ldr.w	r3, [r4, #216]	@ 0xd8
    2d06:	b943      	cbnz	r3, 2d1a <xTaskResumeAll+0x1e>
    2d08:	f04f 0380 	mov.w	r3, #128	@ 0x80
    2d0c:	f383 8811 	msr	BASEPRI, r3
    2d10:	f3bf 8f6f 	isb	sy
    2d14:	f3bf 8f4f 	dsb	sy
    2d18:	e7fe      	b.n	2d18 <xTaskResumeAll+0x1c>
	taskENTER_CRITICAL();
    2d1a:	4b2e      	ldr	r3, [pc, #184]	@ (2dd4 <xTaskResumeAll+0xd8>)
    2d1c:	4798      	blx	r3
		--uxSchedulerSuspended;
    2d1e:	f8d4 30d8 	ldr.w	r3, [r4, #216]	@ 0xd8
    2d22:	3b01      	subs	r3, #1
    2d24:	f8c4 30d8 	str.w	r3, [r4, #216]	@ 0xd8
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    2d28:	f8d4 50d8 	ldr.w	r5, [r4, #216]	@ 0xd8
    2d2c:	b12d      	cbz	r5, 2d3a <xTaskResumeAll+0x3e>
	BaseType_t xAlreadyYielded = pdFALSE;
    2d2e:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
    2d30:	4b29      	ldr	r3, [pc, #164]	@ (2dd8 <xTaskResumeAll+0xdc>)
    2d32:	4798      	blx	r3
}
    2d34:	4620      	mov	r0, r4
    2d36:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
    2d3a:	f8d4 308c 	ldr.w	r3, [r4, #140]	@ 0x8c
    2d3e:	2b00      	cmp	r3, #0
    2d40:	d0f5      	beq.n	2d2e <xTaskResumeAll+0x32>
					(void)uxListRemove(&(pxTCB->xEventListItem));
    2d42:	4e26      	ldr	r6, [pc, #152]	@ (2ddc <xTaskResumeAll+0xe0>)
					prvAddTaskToReadyList(pxTCB);
    2d44:	f8df 90a0 	ldr.w	r9, [pc, #160]	@ 2de8 <xTaskResumeAll+0xec>
    2d48:	f04f 0814 	mov.w	r8, #20
    2d4c:	e01b      	b.n	2d86 <xTaskResumeAll+0x8a>
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xPendingReadyList));
    2d4e:	f8d4 30c4 	ldr.w	r3, [r4, #196]	@ 0xc4
    2d52:	68dd      	ldr	r5, [r3, #12]
					(void)uxListRemove(&(pxTCB->xStateListItem));
    2d54:	1d2f      	adds	r7, r5, #4
					(void)uxListRemove(&(pxTCB->xEventListItem));
    2d56:	f105 0018 	add.w	r0, r5, #24
    2d5a:	47b0      	blx	r6
					(void)uxListRemove(&(pxTCB->xStateListItem));
    2d5c:	4638      	mov	r0, r7
    2d5e:	47b0      	blx	r6
					prvAddTaskToReadyList(pxTCB);
    2d60:	6ae8      	ldr	r0, [r5, #44]	@ 0x2c
    2d62:	f8d4 30d4 	ldr.w	r3, [r4, #212]	@ 0xd4
    2d66:	4298      	cmp	r0, r3
    2d68:	bf88      	it	hi
    2d6a:	f8c4 00d4 	strhi.w	r0, [r4, #212]	@ 0xd4
    2d6e:	4639      	mov	r1, r7
    2d70:	fb08 4000 	mla	r0, r8, r0, r4
    2d74:	47c8      	blx	r9
					if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    2d76:	6ea3      	ldr	r3, [r4, #104]	@ 0x68
    2d78:	6aea      	ldr	r2, [r5, #44]	@ 0x2c
    2d7a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
    2d7c:	429a      	cmp	r2, r3
    2d7e:	d302      	bcc.n	2d86 <xTaskResumeAll+0x8a>
						xYieldPending = pdTRUE;
    2d80:	2301      	movs	r3, #1
    2d82:	f8c4 30e8 	str.w	r3, [r4, #232]	@ 0xe8
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
    2d86:	f8d4 30b8 	ldr.w	r3, [r4, #184]	@ 0xb8
    2d8a:	2b00      	cmp	r3, #0
    2d8c:	d1df      	bne.n	2d4e <xTaskResumeAll+0x52>
				if (pxTCB != NULL) {
    2d8e:	b10d      	cbz	r5, 2d94 <xTaskResumeAll+0x98>
					prvResetNextTaskUnblockTime();
    2d90:	4b13      	ldr	r3, [pc, #76]	@ (2de0 <xTaskResumeAll+0xe4>)
    2d92:	4798      	blx	r3
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    2d94:	f8d4 50e4 	ldr.w	r5, [r4, #228]	@ 0xe4
					if (uxPendedCounts > (UBaseType_t)0U) {
    2d98:	b14d      	cbz	r5, 2dae <xTaskResumeAll+0xb2>
							if (xTaskIncrementTick() != pdFALSE) {
    2d9a:	4e12      	ldr	r6, [pc, #72]	@ (2de4 <xTaskResumeAll+0xe8>)
								xYieldPending = pdTRUE;
    2d9c:	2701      	movs	r7, #1
							if (xTaskIncrementTick() != pdFALSE) {
    2d9e:	47b0      	blx	r6
    2da0:	b108      	cbz	r0, 2da6 <xTaskResumeAll+0xaa>
								xYieldPending = pdTRUE;
    2da2:	f8c4 70e8 	str.w	r7, [r4, #232]	@ 0xe8
						} while (uxPendedCounts > (UBaseType_t)0U);
    2da6:	3d01      	subs	r5, #1
    2da8:	d1f9      	bne.n	2d9e <xTaskResumeAll+0xa2>
						uxPendedTicks = 0;
    2daa:	f8c4 50e4 	str.w	r5, [r4, #228]	@ 0xe4
				if (xYieldPending != pdFALSE) {
    2dae:	f8d4 30e8 	ldr.w	r3, [r4, #232]	@ 0xe8
    2db2:	2b00      	cmp	r3, #0
    2db4:	d0bb      	beq.n	2d2e <xTaskResumeAll+0x32>
					taskYIELD_IF_USING_PREEMPTION();
    2db6:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
    2dba:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
    2dbe:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
    2dc2:	f3bf 8f4f 	dsb	sy
    2dc6:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
    2dca:	2401      	movs	r4, #1
    2dcc:	e7b0      	b.n	2d30 <xTaskResumeAll+0x34>
    2dce:	bf00      	nop
    2dd0:	2002058c 	.word	0x2002058c
    2dd4:	00000a85 	.word	0x00000a85
    2dd8:	00000ac5 	.word	0x00000ac5
    2ddc:	00000989 	.word	0x00000989
    2de0:	000029a5 	.word	0x000029a5
    2de4:	00002c01 	.word	0x00002c01
    2de8:	00000945 	.word	0x00000945

00002dec <vTaskDelay>:
{
    2dec:	b508      	push	{r3, lr}
	if (xTicksToDelay > (TickType_t)0U) {
    2dee:	b950      	cbnz	r0, 2e06 <vTaskDelay+0x1a>
		portYIELD_WITHIN_API();
    2df0:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
    2df4:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
    2df8:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
    2dfc:	f3bf 8f4f 	dsb	sy
    2e00:	f3bf 8f6f 	isb	sy
}
    2e04:	bd08      	pop	{r3, pc}
		configASSERT(uxSchedulerSuspended == 0);
    2e06:	4b0b      	ldr	r3, [pc, #44]	@ (2e34 <vTaskDelay+0x48>)
    2e08:	f8d3 10d8 	ldr.w	r1, [r3, #216]	@ 0xd8
    2e0c:	b141      	cbz	r1, 2e20 <vTaskDelay+0x34>
    2e0e:	f04f 0380 	mov.w	r3, #128	@ 0x80
    2e12:	f383 8811 	msr	BASEPRI, r3
    2e16:	f3bf 8f6f 	isb	sy
    2e1a:	f3bf 8f4f 	dsb	sy
    2e1e:	e7fe      	b.n	2e1e <vTaskDelay+0x32>
		vTaskSuspendAll();
    2e20:	4b05      	ldr	r3, [pc, #20]	@ (2e38 <vTaskDelay+0x4c>)
    2e22:	4798      	blx	r3
			prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);
    2e24:	4b05      	ldr	r3, [pc, #20]	@ (2e3c <vTaskDelay+0x50>)
    2e26:	4798      	blx	r3
		xAlreadyYielded = xTaskResumeAll();
    2e28:	4b05      	ldr	r3, [pc, #20]	@ (2e40 <vTaskDelay+0x54>)
    2e2a:	4798      	blx	r3
	if (xAlreadyYielded == pdFALSE) {
    2e2c:	2800      	cmp	r0, #0
    2e2e:	d0df      	beq.n	2df0 <vTaskDelay+0x4>
    2e30:	e7e8      	b.n	2e04 <vTaskDelay+0x18>
    2e32:	bf00      	nop
    2e34:	2002058c 	.word	0x2002058c
    2e38:	00002be1 	.word	0x00002be1
    2e3c:	0000293d 	.word	0x0000293d
    2e40:	00002cfd 	.word	0x00002cfd

00002e44 <vTaskSwitchContext>:
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
    2e44:	4b18      	ldr	r3, [pc, #96]	@ (2ea8 <vTaskSwitchContext+0x64>)
    2e46:	f8d3 20d8 	ldr.w	r2, [r3, #216]	@ 0xd8
{
    2e4a:	b530      	push	{r4, r5, lr}
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
    2e4c:	b11a      	cbz	r2, 2e56 <vTaskSwitchContext+0x12>
		xYieldPending = pdTRUE;
    2e4e:	2201      	movs	r2, #1
    2e50:	f8c3 20e8 	str.w	r2, [r3, #232]	@ 0xe8
}
    2e54:	bd30      	pop	{r4, r5, pc}
		xYieldPending = pdFALSE;
    2e56:	f8c3 20e8 	str.w	r2, [r3, #232]	@ 0xe8
		taskSELECT_HIGHEST_PRIORITY_TASK();
    2e5a:	f8d3 10d4 	ldr.w	r1, [r3, #212]	@ 0xd4
    2e5e:	2514      	movs	r5, #20
    2e60:	fb05 f201 	mul.w	r2, r5, r1
    2e64:	1898      	adds	r0, r3, r2
    2e66:	589c      	ldr	r4, [r3, r2]
    2e68:	b18c      	cbz	r4, 2e8e <vTaskSwitchContext+0x4a>
    2e6a:	6844      	ldr	r4, [r0, #4]
    2e6c:	3208      	adds	r2, #8
    2e6e:	6864      	ldr	r4, [r4, #4]
    2e70:	6044      	str	r4, [r0, #4]
    2e72:	441a      	add	r2, r3
    2e74:	4294      	cmp	r4, r2
    2e76:	bf04      	itt	eq
    2e78:	6862      	ldreq	r2, [r4, #4]
    2e7a:	6042      	streq	r2, [r0, #4]
    2e7c:	2214      	movs	r2, #20
    2e7e:	fb02 3201 	mla	r2, r2, r1, r3
    2e82:	6852      	ldr	r2, [r2, #4]
    2e84:	68d2      	ldr	r2, [r2, #12]
    2e86:	669a      	str	r2, [r3, #104]	@ 0x68
    2e88:	f8c3 10d4 	str.w	r1, [r3, #212]	@ 0xd4
}
    2e8c:	e7e2      	b.n	2e54 <vTaskSwitchContext+0x10>
		taskSELECT_HIGHEST_PRIORITY_TASK();
    2e8e:	b941      	cbnz	r1, 2ea2 <vTaskSwitchContext+0x5e>
    2e90:	f04f 0380 	mov.w	r3, #128	@ 0x80
    2e94:	f383 8811 	msr	BASEPRI, r3
    2e98:	f3bf 8f6f 	isb	sy
    2e9c:	f3bf 8f4f 	dsb	sy
    2ea0:	e7fe      	b.n	2ea0 <vTaskSwitchContext+0x5c>
    2ea2:	3901      	subs	r1, #1
    2ea4:	e7dc      	b.n	2e60 <vTaskSwitchContext+0x1c>
    2ea6:	bf00      	nop
    2ea8:	2002058c 	.word	0x2002058c

00002eac <vTaskPlaceOnEventList>:
{
    2eac:	b510      	push	{r4, lr}
    2eae:	460c      	mov	r4, r1
	configASSERT(pxEventList);
    2eb0:	b940      	cbnz	r0, 2ec4 <vTaskPlaceOnEventList+0x18>
    2eb2:	f04f 0380 	mov.w	r3, #128	@ 0x80
    2eb6:	f383 8811 	msr	BASEPRI, r3
    2eba:	f3bf 8f6f 	isb	sy
    2ebe:	f3bf 8f4f 	dsb	sy
    2ec2:	e7fe      	b.n	2ec2 <vTaskPlaceOnEventList+0x16>
	vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
    2ec4:	4b05      	ldr	r3, [pc, #20]	@ (2edc <vTaskPlaceOnEventList+0x30>)
    2ec6:	6e99      	ldr	r1, [r3, #104]	@ 0x68
    2ec8:	4b05      	ldr	r3, [pc, #20]	@ (2ee0 <vTaskPlaceOnEventList+0x34>)
    2eca:	3118      	adds	r1, #24
    2ecc:	4798      	blx	r3
	prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
    2ece:	4620      	mov	r0, r4
    2ed0:	4b04      	ldr	r3, [pc, #16]	@ (2ee4 <vTaskPlaceOnEventList+0x38>)
}
    2ed2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
    2ed6:	2101      	movs	r1, #1
    2ed8:	4718      	bx	r3
    2eda:	bf00      	nop
    2edc:	2002058c 	.word	0x2002058c
    2ee0:	0000095b 	.word	0x0000095b
    2ee4:	0000293d 	.word	0x0000293d

00002ee8 <vTaskPlaceOnEventListRestricted>:
{
    2ee8:	b570      	push	{r4, r5, r6, lr}
    2eea:	460d      	mov	r5, r1
    2eec:	4614      	mov	r4, r2
	configASSERT(pxEventList);
    2eee:	b940      	cbnz	r0, 2f02 <vTaskPlaceOnEventListRestricted+0x1a>
    2ef0:	f04f 0380 	mov.w	r3, #128	@ 0x80
    2ef4:	f383 8811 	msr	BASEPRI, r3
    2ef8:	f3bf 8f6f 	isb	sy
    2efc:	f3bf 8f4f 	dsb	sy
    2f00:	e7fe      	b.n	2f00 <vTaskPlaceOnEventListRestricted+0x18>
	vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
    2f02:	4b08      	ldr	r3, [pc, #32]	@ (2f24 <vTaskPlaceOnEventListRestricted+0x3c>)
    2f04:	6e99      	ldr	r1, [r3, #104]	@ 0x68
    2f06:	4b08      	ldr	r3, [pc, #32]	@ (2f28 <vTaskPlaceOnEventListRestricted+0x40>)
    2f08:	3118      	adds	r1, #24
    2f0a:	4798      	blx	r3
		xTicksToWait = portMAX_DELAY;
    2f0c:	2c00      	cmp	r4, #0
	prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
    2f0e:	4621      	mov	r1, r4
    2f10:	bf08      	it	eq
    2f12:	4628      	moveq	r0, r5
    2f14:	4b05      	ldr	r3, [pc, #20]	@ (2f2c <vTaskPlaceOnEventListRestricted+0x44>)
}
    2f16:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
    2f1a:	bf18      	it	ne
    2f1c:	f04f 30ff 	movne.w	r0, #4294967295	@ 0xffffffff
    2f20:	4718      	bx	r3
    2f22:	bf00      	nop
    2f24:	2002058c 	.word	0x2002058c
    2f28:	00000945 	.word	0x00000945
    2f2c:	0000293d 	.word	0x0000293d

00002f30 <xTaskRemoveFromEventList>:
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
    2f30:	68c3      	ldr	r3, [r0, #12]
{
    2f32:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
    2f36:	68dd      	ldr	r5, [r3, #12]
	configASSERT(pxUnblockedTCB);
    2f38:	b945      	cbnz	r5, 2f4c <xTaskRemoveFromEventList+0x1c>
    2f3a:	f04f 0380 	mov.w	r3, #128	@ 0x80
    2f3e:	f383 8811 	msr	BASEPRI, r3
    2f42:	f3bf 8f6f 	isb	sy
    2f46:	f3bf 8f4f 	dsb	sy
    2f4a:	e7fe      	b.n	2f4a <xTaskRemoveFromEventList+0x1a>
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    2f4c:	4c14      	ldr	r4, [pc, #80]	@ (2fa0 <xTaskRemoveFromEventList+0x70>)
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
    2f4e:	f8df 8058 	ldr.w	r8, [pc, #88]	@ 2fa8 <xTaskRemoveFromEventList+0x78>
    2f52:	4e14      	ldr	r6, [pc, #80]	@ (2fa4 <xTaskRemoveFromEventList+0x74>)
    2f54:	f105 0718 	add.w	r7, r5, #24
    2f58:	4638      	mov	r0, r7
    2f5a:	47c0      	blx	r8
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    2f5c:	f8d4 30d8 	ldr.w	r3, [r4, #216]	@ 0xd8
    2f60:	b9cb      	cbnz	r3, 2f96 <xTaskRemoveFromEventList+0x66>
		(void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
    2f62:	1d2f      	adds	r7, r5, #4
    2f64:	4638      	mov	r0, r7
    2f66:	47c0      	blx	r8
		prvAddTaskToReadyList(pxUnblockedTCB);
    2f68:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
    2f6a:	f8d4 20d4 	ldr.w	r2, [r4, #212]	@ 0xd4
    2f6e:	2014      	movs	r0, #20
    2f70:	4293      	cmp	r3, r2
    2f72:	bf88      	it	hi
    2f74:	f8c4 30d4 	strhi.w	r3, [r4, #212]	@ 0xd4
    2f78:	4639      	mov	r1, r7
    2f7a:	fb00 4003 	mla	r0, r0, r3, r4
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
    2f7e:	47b0      	blx	r6
	if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
    2f80:	6ea3      	ldr	r3, [r4, #104]	@ 0x68
    2f82:	6aea      	ldr	r2, [r5, #44]	@ 0x2c
    2f84:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
    2f86:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
    2f88:	bf86      	itte	hi
    2f8a:	2001      	movhi	r0, #1
    2f8c:	f8c4 00e8 	strhi.w	r0, [r4, #232]	@ 0xe8
		xReturn = pdFALSE;
    2f90:	2000      	movls	r0, #0
}
    2f92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
    2f96:	4639      	mov	r1, r7
    2f98:	f104 00b8 	add.w	r0, r4, #184	@ 0xb8
    2f9c:	e7ef      	b.n	2f7e <xTaskRemoveFromEventList+0x4e>
    2f9e:	bf00      	nop
    2fa0:	2002058c 	.word	0x2002058c
    2fa4:	00000945 	.word	0x00000945
    2fa8:	00000989 	.word	0x00000989

00002fac <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
    2fac:	4b03      	ldr	r3, [pc, #12]	@ (2fbc <vTaskInternalSetTimeOutState+0x10>)
    2fae:	f8d3 20e0 	ldr.w	r2, [r3, #224]	@ 0xe0
	pxTimeOut->xTimeOnEntering = xTickCount;
    2fb2:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
    2fb4:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    2fb6:	6043      	str	r3, [r0, #4]
}
    2fb8:	4770      	bx	lr
    2fba:	bf00      	nop
    2fbc:	2002058c 	.word	0x2002058c

00002fc0 <xTaskCheckForTimeOut>:
{
    2fc0:	b570      	push	{r4, r5, r6, lr}
    2fc2:	460c      	mov	r4, r1
	configASSERT(pxTimeOut);
    2fc4:	4605      	mov	r5, r0
    2fc6:	b940      	cbnz	r0, 2fda <xTaskCheckForTimeOut+0x1a>
    2fc8:	f04f 0380 	mov.w	r3, #128	@ 0x80
    2fcc:	f383 8811 	msr	BASEPRI, r3
    2fd0:	f3bf 8f6f 	isb	sy
    2fd4:	f3bf 8f4f 	dsb	sy
    2fd8:	e7fe      	b.n	2fd8 <xTaskCheckForTimeOut+0x18>
	configASSERT(pxTicksToWait);
    2fda:	b941      	cbnz	r1, 2fee <xTaskCheckForTimeOut+0x2e>
    2fdc:	f04f 0380 	mov.w	r3, #128	@ 0x80
    2fe0:	f383 8811 	msr	BASEPRI, r3
    2fe4:	f3bf 8f6f 	isb	sy
    2fe8:	f3bf 8f4f 	dsb	sy
    2fec:	e7fe      	b.n	2fec <xTaskCheckForTimeOut+0x2c>
	taskENTER_CRITICAL();
    2fee:	4b10      	ldr	r3, [pc, #64]	@ (3030 <xTaskCheckForTimeOut+0x70>)
    2ff0:	4798      	blx	r3
		    if (*pxTicksToWait == portMAX_DELAY) {
    2ff2:	6823      	ldr	r3, [r4, #0]
		const TickType_t xConstTickCount = xTickCount;
    2ff4:	480f      	ldr	r0, [pc, #60]	@ (3034 <xTaskCheckForTimeOut+0x74>)
		    if (*pxTicksToWait == portMAX_DELAY) {
    2ff6:	1c5a      	adds	r2, r3, #1
		const TickType_t xConstTickCount = xTickCount;
    2ff8:	6e41      	ldr	r1, [r0, #100]	@ 0x64
		    if (*pxTicksToWait == portMAX_DELAY) {
    2ffa:	d010      	beq.n	301e <xTaskCheckForTimeOut+0x5e>
		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
    2ffc:	f8d0 00e0 	ldr.w	r0, [r0, #224]	@ 0xe0
    3000:	682e      	ldr	r6, [r5, #0]
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
    3002:	686a      	ldr	r2, [r5, #4]
		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
    3004:	4286      	cmp	r6, r0
    3006:	d001      	beq.n	300c <xTaskCheckForTimeOut+0x4c>
		        && (xConstTickCount >= pxTimeOut->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to make
    3008:	428a      	cmp	r2, r1
    300a:	d90f      	bls.n	302c <xTaskCheckForTimeOut+0x6c>
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
    300c:	1a88      	subs	r0, r1, r2
		} else if (xElapsedTime < *pxTicksToWait) /*lint !e961 Explicit casting is only redundant with some compilers,
    300e:	4283      	cmp	r3, r0
    3010:	d90a      	bls.n	3028 <xTaskCheckForTimeOut+0x68>
			*pxTicksToWait -= xElapsedTime;
    3012:	1a5b      	subs	r3, r3, r1
    3014:	4413      	add	r3, r2
    3016:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState(pxTimeOut);
    3018:	4628      	mov	r0, r5
    301a:	4b07      	ldr	r3, [pc, #28]	@ (3038 <xTaskCheckForTimeOut+0x78>)
    301c:	4798      	blx	r3
			xReturn = pdFALSE;
    301e:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
    3020:	4b06      	ldr	r3, [pc, #24]	@ (303c <xTaskCheckForTimeOut+0x7c>)
    3022:	4798      	blx	r3
}
    3024:	4620      	mov	r0, r4
    3026:	bd70      	pop	{r4, r5, r6, pc}
			*pxTicksToWait = 0;
    3028:	2300      	movs	r3, #0
    302a:	6023      	str	r3, [r4, #0]
			xReturn = pdTRUE;
    302c:	2401      	movs	r4, #1
    302e:	e7f7      	b.n	3020 <xTaskCheckForTimeOut+0x60>
    3030:	00000a85 	.word	0x00000a85
    3034:	2002058c 	.word	0x2002058c
    3038:	00002fad 	.word	0x00002fad
    303c:	00000ac5 	.word	0x00000ac5

00003040 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
    3040:	4b02      	ldr	r3, [pc, #8]	@ (304c <vTaskMissedYield+0xc>)
    3042:	2201      	movs	r2, #1
    3044:	f8c3 20e8 	str.w	r2, [r3, #232]	@ 0xe8
}
    3048:	4770      	bx	lr
    304a:	bf00      	nop
    304c:	2002058c 	.word	0x2002058c

00003050 <xTaskGetSchedulerState>:
	if (xSchedulerRunning == pdFALSE) {
    3050:	4b06      	ldr	r3, [pc, #24]	@ (306c <xTaskGetSchedulerState+0x1c>)
    3052:	f8d3 20cc 	ldr.w	r2, [r3, #204]	@ 0xcc
    3056:	b132      	cbz	r2, 3066 <xTaskGetSchedulerState+0x16>
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    3058:	f8d3 00d8 	ldr.w	r0, [r3, #216]	@ 0xd8
    305c:	fab0 f080 	clz	r0, r0
    3060:	0940      	lsrs	r0, r0, #5
    3062:	0040      	lsls	r0, r0, #1
    3064:	4770      	bx	lr
		xReturn = taskSCHEDULER_NOT_STARTED;
    3066:	2001      	movs	r0, #1
}
    3068:	4770      	bx	lr
    306a:	bf00      	nop
    306c:	2002058c 	.word	0x2002058c

00003070 <xTaskPriorityDisinherit>:
{
    3070:	b570      	push	{r4, r5, r6, lr}
	if (pxMutexHolder != NULL) {
    3072:	b908      	cbnz	r0, 3078 <xTaskPriorityDisinherit+0x8>
	BaseType_t   xReturn = pdFALSE;
    3074:	2000      	movs	r0, #0
}
    3076:	bd70      	pop	{r4, r5, r6, pc}
		configASSERT(pxTCB == pxCurrentTCB);
    3078:	4d1b      	ldr	r5, [pc, #108]	@ (30e8 <xTaskPriorityDisinherit+0x78>)
    307a:	6eac      	ldr	r4, [r5, #104]	@ 0x68
    307c:	4284      	cmp	r4, r0
    307e:	d008      	beq.n	3092 <xTaskPriorityDisinherit+0x22>
    3080:	f04f 0380 	mov.w	r3, #128	@ 0x80
    3084:	f383 8811 	msr	BASEPRI, r3
    3088:	f3bf 8f6f 	isb	sy
    308c:	f3bf 8f4f 	dsb	sy
    3090:	e7fe      	b.n	3090 <xTaskPriorityDisinherit+0x20>
		configASSERT(pxTCB->uxMutexesHeld);
    3092:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
    3094:	b943      	cbnz	r3, 30a8 <xTaskPriorityDisinherit+0x38>
    3096:	f04f 0380 	mov.w	r3, #128	@ 0x80
    309a:	f383 8811 	msr	BASEPRI, r3
    309e:	f3bf 8f6f 	isb	sy
    30a2:	f3bf 8f4f 	dsb	sy
    30a6:	e7fe      	b.n	30a6 <xTaskPriorityDisinherit+0x36>
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
    30a8:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
    30aa:	6c62      	ldr	r2, [r4, #68]	@ 0x44
		(pxTCB->uxMutexesHeld)--;
    30ac:	3b01      	subs	r3, #1
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
    30ae:	4291      	cmp	r1, r2
		(pxTCB->uxMutexesHeld)--;
    30b0:	64a3      	str	r3, [r4, #72]	@ 0x48
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
    30b2:	d0df      	beq.n	3074 <xTaskPriorityDisinherit+0x4>
			if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
    30b4:	2b00      	cmp	r3, #0
    30b6:	d1dd      	bne.n	3074 <xTaskPriorityDisinherit+0x4>
				if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
    30b8:	1d26      	adds	r6, r4, #4
    30ba:	4b0c      	ldr	r3, [pc, #48]	@ (30ec <xTaskPriorityDisinherit+0x7c>)
    30bc:	4630      	mov	r0, r6
    30be:	4798      	blx	r3
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    30c0:	6c63      	ldr	r3, [r4, #68]	@ 0x44
    30c2:	62e3      	str	r3, [r4, #44]	@ 0x2c
				listSET_LIST_ITEM_VALUE(
    30c4:	f1c3 0205 	rsb	r2, r3, #5
    30c8:	61a2      	str	r2, [r4, #24]
				prvAddTaskToReadyList(pxTCB);
    30ca:	f8d5 20d4 	ldr.w	r2, [r5, #212]	@ 0xd4
    30ce:	2014      	movs	r0, #20
    30d0:	4293      	cmp	r3, r2
    30d2:	fb00 5003 	mla	r0, r0, r3, r5
    30d6:	bf88      	it	hi
    30d8:	f8c5 30d4 	strhi.w	r3, [r5, #212]	@ 0xd4
    30dc:	4631      	mov	r1, r6
    30de:	4b04      	ldr	r3, [pc, #16]	@ (30f0 <xTaskPriorityDisinherit+0x80>)
    30e0:	4798      	blx	r3
				xReturn = pdTRUE;
    30e2:	2001      	movs	r0, #1
	return xReturn;
    30e4:	e7c7      	b.n	3076 <xTaskPriorityDisinherit+0x6>
    30e6:	bf00      	nop
    30e8:	2002058c 	.word	0x2002058c
    30ec:	00000989 	.word	0x00000989
    30f0:	00000945 	.word	0x00000945

000030f4 <hri_adc_wait_for_sync>:
typedef uint8_t  hri_adc_status_reg_t;
typedef uint8_t  hri_adc_swtrig_reg_t;

static inline void hri_adc_wait_for_sync(const void *const hw, hri_adc_syncbusy_reg_t reg)
{
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    30f4:	6b03      	ldr	r3, [r0, #48]	@ 0x30
    30f6:	420b      	tst	r3, r1
    30f8:	d1fc      	bne.n	30f4 <hri_adc_wait_for_sync>
	};
}
    30fa:	4770      	bx	lr

000030fc <hri_adc_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_adc_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg &= ~ADC_CTRLA_ENABLE;
    30fc:	8803      	ldrh	r3, [r0, #0]
    30fe:	f023 0302 	bic.w	r3, r3, #2
    3102:	041b      	lsls	r3, r3, #16
    3104:	0c1b      	lsrs	r3, r3, #16
    3106:	8003      	strh	r3, [r0, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
    3108:	2103      	movs	r1, #3
    310a:	4b01      	ldr	r3, [pc, #4]	@ (3110 <hri_adc_clear_CTRLA_ENABLE_bit+0x14>)
    310c:	4718      	bx	r3
    310e:	bf00      	nop
    3110:	000030f5 	.word	0x000030f5

00003114 <_adc_get_regs>:
/** \brief Return the pointer to register settings of specific ADC
 *  \param[in] hw_addr The hardware register base address.
 *  \return Pointer to register settings of specific ADC.
 */
static uint8_t _adc_get_regs(const uint32_t hw_addr)
{
    3114:	b508      	push	{r3, lr}
	return ((uint32_t)hw - (uint32_t)ADC0) >> 10;
    3116:	f100 433d 	add.w	r3, r0, #3170893824	@ 0xbd000000
    311a:	f5a3 53e0 	sub.w	r3, r3, #7168	@ 0x1c00
	uint8_t n = _adc_get_hardware_index((const void *)hw_addr);
	uint8_t i;

	for (i = 0; i < sizeof(_adcs) / sizeof(struct adc_configuration); i++) {
		if (_adcs[i].number == n) {
    311e:	f413 3f7f 	tst.w	r3, #261120	@ 0x3fc00
	return ((uint32_t)hw - (uint32_t)ADC0) >> 10;
    3122:	f3c3 2087 	ubfx	r0, r3, #10, #8
		if (_adcs[i].number == n) {
    3126:	d101      	bne.n	312c <_adc_get_regs+0x18>
	for (i = 0; i < sizeof(_adcs) / sizeof(struct adc_configuration); i++) {
    3128:	2000      	movs	r0, #0
		}
	}

	ASSERT(false);
	return 0;
}
    312a:	bd08      	pop	{r3, pc}
		if (_adcs[i].number == n) {
    312c:	2801      	cmp	r0, #1
    312e:	d0fc      	beq.n	312a <_adc_get_regs+0x16>
	ASSERT(false);
    3130:	4902      	ldr	r1, [pc, #8]	@ (313c <_adc_get_regs+0x28>)
    3132:	4b03      	ldr	r3, [pc, #12]	@ (3140 <_adc_get_regs+0x2c>)
    3134:	2288      	movs	r2, #136	@ 0x88
    3136:	2000      	movs	r0, #0
    3138:	4798      	blx	r3
	return 0;
    313a:	e7f5      	b.n	3128 <_adc_get_regs+0x14>
    313c:	00003464 	.word	0x00003464
    3140:	00001ab5 	.word	0x00001ab5

00003144 <_adc_init>:
 * \param[in] i The number of hardware instance
 */
static int32_t _adc_init(void *const hw, const uint8_t i)
{
	uint16_t calib_reg = 0;
	if (hw == ADC0) {
    3144:	4b38      	ldr	r3, [pc, #224]	@ (3228 <_adc_init+0xe4>)
    3146:	4298      	cmp	r0, r3
{
    3148:	b570      	push	{r4, r5, r6, lr}
    314a:	4606      	mov	r6, r0
    314c:	460d      	mov	r5, r1
	if (hw == ADC0) {
    314e:	d158      	bne.n	3202 <_adc_init+0xbe>
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC0_FUSES_BIASREFBUF_ADDR >> ADC0_FUSES_BIASREFBUF_Pos))
    3150:	f44f 0300 	mov.w	r3, #8388608	@ 0x800000
    3154:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
    3158:	00da      	lsls	r2, r3, #3
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC0_FUSES_BIASR2R_ADDR >> ADC0_FUSES_BIASR2R_Pos))
    315a:	0919      	lsrs	r1, r3, #4
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC0_FUSES_BIASREFBUF_ADDR >> ADC0_FUSES_BIASREFBUF_Pos))
    315c:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC0_FUSES_BIASR2R_ADDR >> ADC0_FUSES_BIASR2R_Pos))
    3160:	f001 0170 	and.w	r1, r1, #112	@ 0x70
    3164:	430a      	orrs	r2, r1
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC0_FUSES_BIASCOMP_ADDR >> ADC0_FUSES_BIASCOMP_Pos));
    3166:	f3c3 0382 	ubfx	r3, r3, #2, #3
	} else if (hw == ADC1) {
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
    316a:	431a      	orrs	r2, r3
	return ((Adc *)hw)->SYNCBUSY.reg & reg;
    316c:	6b33      	ldr	r3, [r6, #48]	@ 0x30
    316e:	4c2f      	ldr	r4, [pc, #188]	@ (322c <_adc_init+0xe8>)
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC1_FUSES_BIASR2R_ADDR >> ADC1_FUSES_BIASR2R_Pos))
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC1_FUSES_BIASCOMP_ADDR >> ADC1_FUSES_BIASCOMP_Pos));
	}

	if (!hri_adc_is_syncing(hw, ADC_SYNCBUSY_SWRST)) {
    3170:	f013 0f01 	tst.w	r3, #1
    3174:	d10e      	bne.n	3194 <_adc_init+0x50>
}

static inline hri_adc_ctrla_reg_t hri_adc_get_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t mask)
{
	uint16_t tmp;
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
    3176:	2103      	movs	r1, #3
    3178:	4630      	mov	r0, r6
    317a:	47a0      	blx	r4
	tmp = ((Adc *)hw)->CTRLA.reg;
    317c:	8833      	ldrh	r3, [r6, #0]
		if (hri_adc_get_CTRLA_reg(hw, ADC_CTRLA_ENABLE)) {
    317e:	079b      	lsls	r3, r3, #30
    3180:	d503      	bpl.n	318a <_adc_init+0x46>
			hri_adc_clear_CTRLA_ENABLE_bit(hw);
    3182:	4b2b      	ldr	r3, [pc, #172]	@ (3230 <_adc_init+0xec>)
    3184:	4798      	blx	r3
			hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_ENABLE);
    3186:	2102      	movs	r1, #2
    3188:	47a0      	blx	r4
}

static inline void hri_adc_write_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t data)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg = data;
    318a:	2301      	movs	r3, #1
    318c:	8033      	strh	r3, [r6, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
    318e:	2103      	movs	r1, #3
    3190:	4630      	mov	r0, r6
    3192:	47a0      	blx	r4
		}
		hri_adc_write_CTRLA_reg(hw, ADC_CTRLA_SWRST);
	}
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST);
    3194:	4630      	mov	r0, r6
    3196:	2101      	movs	r1, #1
    3198:	47a0      	blx	r4
}

static inline void hri_adc_write_CALIB_reg(const void *const hw, hri_adc_calib_reg_t data)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CALIB.reg = data;
    319a:	f8a6 2048 	strh.w	r2, [r6, #72]	@ 0x48

	hri_adc_write_CALIB_reg(hw, calib_reg);
	hri_adc_write_CTRLB_reg(hw, _adcs[i].ctrl_b);
    319e:	4a25      	ldr	r2, [pc, #148]	@ (3234 <_adc_init+0xf0>)
    31a0:	2316      	movs	r3, #22
    31a2:	fb03 2205 	mla	r2, r3, r5, r2
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
    31a6:	f640 71ff 	movw	r1, #4095	@ 0xfff
    31aa:	8893      	ldrh	r3, [r2, #4]
	((Adc *)hw)->CTRLB.reg = data;
    31ac:	80f3      	strh	r3, [r6, #6]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
    31ae:	47a0      	blx	r4
	hri_adc_write_REFCTRL_reg(hw, _adcs[i].ref_ctrl);
    31b0:	7993      	ldrb	r3, [r2, #6]
	((Adc *)hw)->REFCTRL.reg = data;
    31b2:	7233      	strb	r3, [r6, #8]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
    31b4:	47a0      	blx	r4
	hri_adc_write_EVCTRL_reg(hw, _adcs[i].ev_ctrl);
    31b6:	79d3      	ldrb	r3, [r2, #7]
	((Adc *)hw)->EVCTRL.reg = data;
    31b8:	70b3      	strb	r3, [r6, #2]
	hri_adc_write_INPUTCTRL_reg(hw, _adcs[i].input_ctrl);
    31ba:	8913      	ldrh	r3, [r2, #8]
	((Adc *)hw)->INPUTCTRL.reg = data;
    31bc:	80b3      	strh	r3, [r6, #4]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
    31be:	47a0      	blx	r4
	hri_adc_write_AVGCTRL_reg(hw, _adcs[i].avg_ctrl);
    31c0:	7a93      	ldrb	r3, [r2, #10]
	((Adc *)hw)->AVGCTRL.reg = data;
    31c2:	72b3      	strb	r3, [r6, #10]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
    31c4:	47a0      	blx	r4
	hri_adc_write_SAMPCTRL_reg(hw, _adcs[i].samp_ctrl);
    31c6:	7ad3      	ldrb	r3, [r2, #11]
	((Adc *)hw)->SAMPCTRL.reg = data;
    31c8:	72f3      	strb	r3, [r6, #11]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
    31ca:	47a0      	blx	r4
	hri_adc_write_WINLT_reg(hw, _adcs[i].win_lt);
    31cc:	8993      	ldrh	r3, [r2, #12]
	((Adc *)hw)->WINLT.reg = data;
    31ce:	81b3      	strh	r3, [r6, #12]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_WINLT);
    31d0:	2180      	movs	r1, #128	@ 0x80
    31d2:	47a0      	blx	r4
	hri_adc_write_WINUT_reg(hw, _adcs[i].win_ut);
    31d4:	89d3      	ldrh	r3, [r2, #14]
	((Adc *)hw)->WINUT.reg = data;
    31d6:	81f3      	strh	r3, [r6, #14]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_WINUT);
    31d8:	f44f 7180 	mov.w	r1, #256	@ 0x100
    31dc:	47a0      	blx	r4
	hri_adc_write_GAINCORR_reg(hw, _adcs[i].gain_corr);
    31de:	8a13      	ldrh	r3, [r2, #16]
	((Adc *)hw)->GAINCORR.reg = data;
    31e0:	8233      	strh	r3, [r6, #16]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_GAINCORR);
    31e2:	f44f 7100 	mov.w	r1, #512	@ 0x200
    31e6:	47a0      	blx	r4
	hri_adc_write_OFFSETCORR_reg(hw, _adcs[i].offset_corr);
    31e8:	8a53      	ldrh	r3, [r2, #18]
	((Adc *)hw)->OFFSETCORR.reg = data;
    31ea:	8273      	strh	r3, [r6, #18]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_OFFSETCORR);
    31ec:	f44f 6180 	mov.w	r1, #1024	@ 0x400
    31f0:	47a0      	blx	r4
	hri_adc_write_DBGCTRL_reg(hw, _adcs[i].dbg_ctrl);
    31f2:	7d13      	ldrb	r3, [r2, #20]
	((Adc *)hw)->DBGCTRL.reg = data;
    31f4:	70f3      	strb	r3, [r6, #3]
	hri_adc_write_CTRLA_reg(hw, _adcs[i].ctrl_a);
    31f6:	8853      	ldrh	r3, [r2, #2]
	((Adc *)hw)->CTRLA.reg = data;
    31f8:	8033      	strh	r3, [r6, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
    31fa:	2103      	movs	r1, #3
    31fc:	47a0      	blx	r4

	return ERR_NONE;
}
    31fe:	2000      	movs	r0, #0
    3200:	bd70      	pop	{r4, r5, r6, pc}
	} else if (hw == ADC1) {
    3202:	4b0d      	ldr	r3, [pc, #52]	@ (3238 <_adc_init+0xf4>)
    3204:	4298      	cmp	r0, r3
    3206:	d10d      	bne.n	3224 <_adc_init+0xe0>
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
    3208:	f44f 0300 	mov.w	r3, #8388608	@ 0x800000
    320c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
    3210:	0ada      	lsrs	r2, r3, #11
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC1_FUSES_BIASR2R_ADDR >> ADC1_FUSES_BIASR2R_Pos))
    3212:	0c99      	lsrs	r1, r3, #18
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
    3214:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC1_FUSES_BIASR2R_ADDR >> ADC1_FUSES_BIASR2R_Pos))
    3218:	f001 0170 	and.w	r1, r1, #112	@ 0x70
    321c:	430a      	orrs	r2, r1
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC1_FUSES_BIASCOMP_ADDR >> ADC1_FUSES_BIASCOMP_Pos));
    321e:	f3c3 4302 	ubfx	r3, r3, #16, #3
    3222:	e7a2      	b.n	316a <_adc_init+0x26>
	uint16_t calib_reg = 0;
    3224:	2200      	movs	r2, #0
    3226:	e7a1      	b.n	316c <_adc_init+0x28>
    3228:	43001c00 	.word	0x43001c00
    322c:	000030f5 	.word	0x000030f5
    3230:	000030fd 	.word	0x000030fd
    3234:	000034f6 	.word	0x000034f6
    3238:	43002000 	.word	0x43002000

0000323c <_adc_sync_init>:

/**
 * \brief Initialize ADC
 */
int32_t _adc_sync_init(struct _adc_sync_device *const device, void *const hw)
{
    323c:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
    323e:	4605      	mov	r5, r0
    3240:	3800      	subs	r0, #0
{
    3242:	460c      	mov	r4, r1
	ASSERT(device);
    3244:	bf18      	it	ne
    3246:	2001      	movne	r0, #1
    3248:	4906      	ldr	r1, [pc, #24]	@ (3264 <_adc_sync_init+0x28>)
    324a:	4b07      	ldr	r3, [pc, #28]	@ (3268 <_adc_sync_init+0x2c>)
    324c:	22d9      	movs	r2, #217	@ 0xd9
    324e:	4798      	blx	r3

	device->hw = hw;

	return _adc_init(hw, _adc_get_regs((uint32_t)hw));
    3250:	4b06      	ldr	r3, [pc, #24]	@ (326c <_adc_sync_init+0x30>)
	device->hw = hw;
    3252:	602c      	str	r4, [r5, #0]
	return _adc_init(hw, _adc_get_regs((uint32_t)hw));
    3254:	4620      	mov	r0, r4
    3256:	4798      	blx	r3
    3258:	4b05      	ldr	r3, [pc, #20]	@ (3270 <_adc_sync_init+0x34>)
    325a:	4601      	mov	r1, r0
    325c:	4620      	mov	r0, r4
}
    325e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _adc_init(hw, _adc_get_regs((uint32_t)hw));
    3262:	4718      	bx	r3
    3264:	00003464 	.word	0x00003464
    3268:	00001ab5 	.word	0x00001ab5
    326c:	00003115 	.word	0x00003115
    3270:	00003145 	.word	0x00003145

00003274 <memset>:
    3274:	4402      	add	r2, r0
    3276:	4603      	mov	r3, r0
    3278:	4293      	cmp	r3, r2
    327a:	d100      	bne.n	327e <memset+0xa>
    327c:	4770      	bx	lr
    327e:	f803 1b01 	strb.w	r1, [r3], #1
    3282:	e7f9      	b.n	3278 <memset+0x4>

00003284 <__libc_init_array>:
    3284:	b570      	push	{r4, r5, r6, lr}
    3286:	4d0d      	ldr	r5, [pc, #52]	@ (32bc <__libc_init_array+0x38>)
    3288:	4c0d      	ldr	r4, [pc, #52]	@ (32c0 <__libc_init_array+0x3c>)
    328a:	1b64      	subs	r4, r4, r5
    328c:	10a4      	asrs	r4, r4, #2
    328e:	2600      	movs	r6, #0
    3290:	42a6      	cmp	r6, r4
    3292:	d109      	bne.n	32a8 <__libc_init_array+0x24>
    3294:	4d0b      	ldr	r5, [pc, #44]	@ (32c4 <__libc_init_array+0x40>)
    3296:	4c0c      	ldr	r4, [pc, #48]	@ (32c8 <__libc_init_array+0x44>)
    3298:	f000 f944 	bl	3524 <_init>
    329c:	1b64      	subs	r4, r4, r5
    329e:	10a4      	asrs	r4, r4, #2
    32a0:	2600      	movs	r6, #0
    32a2:	42a6      	cmp	r6, r4
    32a4:	d105      	bne.n	32b2 <__libc_init_array+0x2e>
    32a6:	bd70      	pop	{r4, r5, r6, pc}
    32a8:	f855 3b04 	ldr.w	r3, [r5], #4
    32ac:	4798      	blx	r3
    32ae:	3601      	adds	r6, #1
    32b0:	e7ee      	b.n	3290 <__libc_init_array+0xc>
    32b2:	f855 3b04 	ldr.w	r3, [r5], #4
    32b6:	4798      	blx	r3
    32b8:	3601      	adds	r6, #1
    32ba:	e7f2      	b.n	32a2 <__libc_init_array+0x1e>
    32bc:	00003530 	.word	0x00003530
    32c0:	00003530 	.word	0x00003530
    32c4:	00003530 	.word	0x00003530
    32c8:	00003534 	.word	0x00003534

000032cc <memcpy>:
    32cc:	440a      	add	r2, r1
    32ce:	4291      	cmp	r1, r2
    32d0:	f100 33ff 	add.w	r3, r0, #4294967295	@ 0xffffffff
    32d4:	d100      	bne.n	32d8 <memcpy+0xc>
    32d6:	4770      	bx	lr
    32d8:	b510      	push	{r4, lr}
    32da:	f811 4b01 	ldrb.w	r4, [r1], #1
    32de:	f803 4f01 	strb.w	r4, [r3, #1]!
    32e2:	4291      	cmp	r1, r2
    32e4:	d1f9      	bne.n	32da <memcpy+0xe>
    32e6:	bd10      	pop	{r4, pc}
    32e8:	454d5441 	.word	0x454d5441
    32ec:	6e49204c 	.word	0x6e49204c
    32f0:	61697469 	.word	0x61697469
    32f4:	617a696c 	.word	0x617a696c
    32f8:	6e6f6974 	.word	0x6e6f6974
    32fc:	6d6f4320 	.word	0x6d6f4320
    3300:	74656c70 	.word	0x74656c70
    3304:	000a2165 	.word	0x000a2165
    3308:	72616548 	.word	0x72616548
    330c:	61656274 	.word	0x61656274
    3310:	65480074 	.word	0x65480074
    3314:	62747261 	.word	0x62747261
    3318:	20746165 	.word	0x20746165
    331c:	6b736154 	.word	0x6b736154
    3320:	65724320 	.word	0x65724320
    3324:	6f697461 	.word	0x6f697461
    3328:	6146206e 	.word	0x6146206e
    332c:	64656c69 	.word	0x64656c69
    3330:	48000a21 	.word	0x48000a21
    3334:	74726165 	.word	0x74726165
    3338:	74616562 	.word	0x74616562
    333c:	73615420 	.word	0x73615420
    3340:	7243206b 	.word	0x7243206b
    3344:	65746165 	.word	0x65746165
    3348:	000a2164 	.word	0x000a2164
    334c:	6b726f57 	.word	0x6b726f57
    3350:	6d6f6320 	.word	0x6d6f6320
    3354:	74656c70 	.word	0x74656c70
    3358:	2d206465 	.word	0x2d206465
    335c:	6f4c202d 	.word	0x6f4c202d
    3360:	6e69706f 	.word	0x6e69706f
    3364:	6f662067 	.word	0x6f662067
    3368:	65766572 	.word	0x65766572
    336c:	48000a72 	.word	0x48000a72
    3370:	74726165 	.word	0x74726165
    3374:	74616562 	.word	0x74616562
    3378:	73615420 	.word	0x73615420
    337c:	7453206b 	.word	0x7453206b
    3380:	65747261 	.word	0x65747261
    3384:	000a2164 	.word	0x000a2164
    3388:	6d726554 	.word	0x6d726554
    338c:	6c616e69 	.word	0x6c616e69
    3390:	2f2e2e00 	.word	0x2f2e2e00
    3394:	2f6c7068 	.word	0x2f6c7068
    3398:	2f746477 	.word	0x2f746477
    339c:	5f6c7068 	.word	0x5f6c7068
    33a0:	2e746477 	.word	0x2e746477
    33a4:	2e2e0063 	.word	0x2e2e0063
    33a8:	6c61682f 	.word	0x6c61682f
    33ac:	6372732f 	.word	0x6372732f
    33b0:	6c61682f 	.word	0x6c61682f
    33b4:	6970735f 	.word	0x6970735f
    33b8:	735f6d5f 	.word	0x735f6d5f
    33bc:	2e636e79 	.word	0x2e636e79
    33c0:	2e2e0063 	.word	0x2e2e0063
    33c4:	6c61682f 	.word	0x6c61682f
    33c8:	6372732f 	.word	0x6372732f
    33cc:	6c61682f 	.word	0x6c61682f
    33d0:	6332695f 	.word	0x6332695f
    33d4:	735f6d5f 	.word	0x735f6d5f
    33d8:	2e636e79 	.word	0x2e636e79
    33dc:	6d540063 	.word	0x6d540063
    33e0:	76532072 	.word	0x76532072
    33e4:	2e2e0063 	.word	0x2e2e0063
    33e8:	6c61682f 	.word	0x6c61682f
    33ec:	6372732f 	.word	0x6372732f
    33f0:	6c61682f 	.word	0x6c61682f
    33f4:	6173755f 	.word	0x6173755f
    33f8:	735f7472 	.word	0x735f7472
    33fc:	2e636e79 	.word	0x2e636e79
    3400:	2e2e0063 	.word	0x2e2e0063
    3404:	6c61682f 	.word	0x6c61682f
    3408:	636e692f 	.word	0x636e692f
    340c:	6564756c 	.word	0x6564756c
    3410:	6c61682f 	.word	0x6c61682f
    3414:	7464775f 	.word	0x7464775f
    3418:	2e00682e 	.word	0x2e00682e
    341c:	61682f2e 	.word	0x61682f2e
    3420:	72732f6c 	.word	0x72732f6c
    3424:	61682f63 	.word	0x61682f63
    3428:	64615f6c 	.word	0x64615f6c
    342c:	79735f63 	.word	0x79735f63
    3430:	632e636e 	.word	0x632e636e
    3434:	2f2e2e00 	.word	0x2f2e2e00
    3438:	2f6c7068 	.word	0x2f6c7068
    343c:	63726573 	.word	0x63726573
    3440:	682f6d6f 	.word	0x682f6d6f
    3444:	735f6c70 	.word	0x735f6c70
    3448:	6f637265 	.word	0x6f637265
    344c:	00632e6d 	.word	0x00632e6d
    3450:	454c4449 	.word	0x454c4449
    3454:	63250900 	.word	0x63250900
    3458:	09752509 	.word	0x09752509
    345c:	25097525 	.word	0x25097525
    3460:	000a0d75 	.word	0x000a0d75
    3464:	682f2e2e 	.word	0x682f2e2e
    3468:	612f6c70 	.word	0x612f6c70
    346c:	682f6364 	.word	0x682f6364
    3470:	615f6c70 	.word	0x615f6c70
    3474:	632e6364 	.word	0x632e6364
	...

00003479 <_aInitStr.0>:
    3479:	00000000 54540000 45522052 53454747     ......TTR REGGES
	...

0000348a <_aTerminalId>:
    348a:	33323130 37363534 42413938 46454443     0123456789ABCDEF

0000349a <_aV2C.0>:
    349a:	33323130 37363534 42413938 46454443     0123456789ABCDEF
    34aa:	30000000 34004000 20004000 40004101     ...0.@.4.@. .A.@
    34ba:	00004101 04004300 08004300 0c004300     .A...C...C...C..
    34ca:	                                         .C

000034cc <_i2cms>:
    34cc:	00000001 00200014 00000100 00000002     ...... .........
    34dc:	00d70000 0016e360                       ....`...

000034e4 <sercomspi_regs>:
    34e4:	0030000c 00020000 00000000 01ff0000     ..0.............
    34f4:	                                         ..

000034f6 <_adcs>:
	...
    350a:	00010000 00000000 00000000 00000000     ................
	...

00003524 <_init>:
    3524:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3526:	bf00      	nop
    3528:	bcf8      	pop	{r3, r4, r5, r6, r7}
    352a:	bc08      	pop	{r3}
    352c:	469e      	mov	lr, r3
    352e:	4770      	bx	lr

00003530 <__frame_dummy_init_array_entry>:
    3530:	02cd 0000                                   ....

00003534 <_fini>:
    3534:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3536:	bf00      	nop
    3538:	bcf8      	pop	{r3, r4, r5, r6, r7}
    353a:	bc08      	pop	{r3}
    353c:	469e      	mov	lr, r3
    353e:	4770      	bx	lr

00003540 <__do_global_dtors_aux_fini_array_entry>:
    3540:	02a5 0000                                   ....
