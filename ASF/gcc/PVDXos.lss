
PVDXos.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000056d0  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000030  20000000  000056d0  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bkupram      00000000  47000000  47000000  00020030  2**0
                  CONTENTS
  3 .qspi         00000000  04000000  04000000  00020030  2**0
                  CONTENTS
  4 .bss          00000630  20000030  00005700  00020030  2**2
                  ALLOC
  5 .stack        00010000  20000660  00005d30  00020030  2**0
                  ALLOC
  6 .ARM.attributes 0000002e  00000000  00000000  00020030  2**0
                  CONTENTS, READONLY
  7 .comment      00000033  00000000  00000000  0002005e  2**0
                  CONTENTS, READONLY
  8 .debug_info   00020ff8  00000000  00000000  00020091  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_abbrev 00003c71  00000000  00000000  00041089  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_aranges 00001b18  00000000  00000000  00044d00  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_ranges 000018e0  00000000  00000000  00046818  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_macro  00031067  00000000  00000000  000480f8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_line   000189ef  00000000  00000000  0007915f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_str    0010ca10  00000000  00000000  00091b4e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_frame  00006fc0  00000000  00000000  0019e560  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_loc    000002e6  00000000  00000000  001a5520  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00000000 <exception_table>:
       0:	60 06 01 20 d1 48 00 00 71 49 00 00 71 49 00 00     `.. .H..qI..qI..
      10:	71 49 00 00 71 49 00 00 71 49 00 00 00 00 00 00     qI..qI..qI......
	...
      2c:	c1 13 00 00 71 49 00 00 00 00 00 00 f1 13 00 00     ....qI..........
      3c:	59 14 00 00 71 49 00 00 71 49 00 00 71 49 00 00     Y...qI..qI..qI..
      4c:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
      5c:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
      6c:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
      7c:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
      8c:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
      9c:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
      ac:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
      bc:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
      cc:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
      dc:	71 49 00 00 71 49 00 00 71 49 00 00 00 00 00 00     qI..qI..qI......
	...
      f4:	b9 22 00 00 71 49 00 00 71 49 00 00 71 49 00 00     ."..qI..qI..qI..
     104:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
     114:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
     124:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
     134:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
     144:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
     154:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
     164:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
     174:	71 49 00 00 00 00 00 00 00 00 00 00 71 49 00 00     qI..........qI..
     184:	71 49 00 00 71 49 00 00 71 49 00 00 00 00 00 00     qI..qI..qI......
     194:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
     1a4:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
     1b4:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
     1c4:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
     1d4:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
     1e4:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
     1f4:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
     204:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
     214:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
     224:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
     234:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
     244:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..
     254:	71 49 00 00 71 49 00 00 71 49 00 00 71 49 00 00     qI..qI..qI..qI..

00000264 <deregister_tm_clones>:
     264:	4803      	ldr	r0, [pc, #12]	; (274 <deregister_tm_clones+0x10>)
     266:	4b04      	ldr	r3, [pc, #16]	; (278 <deregister_tm_clones+0x14>)
     268:	4283      	cmp	r3, r0
     26a:	d002      	beq.n	272 <deregister_tm_clones+0xe>
     26c:	4b03      	ldr	r3, [pc, #12]	; (27c <deregister_tm_clones+0x18>)
     26e:	b103      	cbz	r3, 272 <deregister_tm_clones+0xe>
     270:	4718      	bx	r3
     272:	4770      	bx	lr
     274:	000056d0 	.word	0x000056d0
     278:	000056d0 	.word	0x000056d0
     27c:	00000000 	.word	0x00000000

00000280 <register_tm_clones>:
     280:	4805      	ldr	r0, [pc, #20]	; (298 <register_tm_clones+0x18>)
     282:	4906      	ldr	r1, [pc, #24]	; (29c <register_tm_clones+0x1c>)
     284:	1a0b      	subs	r3, r1, r0
     286:	0fd9      	lsrs	r1, r3, #31
     288:	eb01 01a3 	add.w	r1, r1, r3, asr #2
     28c:	1049      	asrs	r1, r1, #1
     28e:	d002      	beq.n	296 <register_tm_clones+0x16>
     290:	4b03      	ldr	r3, [pc, #12]	; (2a0 <register_tm_clones+0x20>)
     292:	b103      	cbz	r3, 296 <register_tm_clones+0x16>
     294:	4718      	bx	r3
     296:	4770      	bx	lr
     298:	000056d0 	.word	0x000056d0
     29c:	000056d0 	.word	0x000056d0
     2a0:	00000000 	.word	0x00000000

000002a4 <__do_global_dtors_aux>:
     2a4:	b510      	push	{r4, lr}
     2a6:	4c06      	ldr	r4, [pc, #24]	; (2c0 <__do_global_dtors_aux+0x1c>)
     2a8:	7823      	ldrb	r3, [r4, #0]
     2aa:	b943      	cbnz	r3, 2be <__do_global_dtors_aux+0x1a>
     2ac:	f7ff ffda 	bl	264 <deregister_tm_clones>
     2b0:	4b04      	ldr	r3, [pc, #16]	; (2c4 <__do_global_dtors_aux+0x20>)
     2b2:	b113      	cbz	r3, 2ba <__do_global_dtors_aux+0x16>
     2b4:	4804      	ldr	r0, [pc, #16]	; (2c8 <__do_global_dtors_aux+0x24>)
     2b6:	f3af 8000 	nop.w
     2ba:	2301      	movs	r3, #1
     2bc:	7023      	strb	r3, [r4, #0]
     2be:	bd10      	pop	{r4, pc}
     2c0:	20000030 	.word	0x20000030
     2c4:	00000000 	.word	0x00000000
     2c8:	000056d0 	.word	0x000056d0

000002cc <frame_dummy>:
     2cc:	b508      	push	{r3, lr}
     2ce:	4b04      	ldr	r3, [pc, #16]	; (2e0 <frame_dummy+0x14>)
     2d0:	b11b      	cbz	r3, 2da <frame_dummy+0xe>
     2d2:	4904      	ldr	r1, [pc, #16]	; (2e4 <frame_dummy+0x18>)
     2d4:	4804      	ldr	r0, [pc, #16]	; (2e8 <frame_dummy+0x1c>)
     2d6:	f3af 8000 	nop.w
     2da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     2de:	e7cf      	b.n	280 <register_tm_clones>
     2e0:	00000000 	.word	0x00000000
     2e4:	20000034 	.word	0x20000034
     2e8:	000056d0 	.word	0x000056d0

000002ec <runRM3100>:
#include "globals.h"

void runRM3100() {
     2ec:	b580      	push	{r7, lr}
     2ee:	b084      	sub	sp, #16
     2f0:	af00      	add	r7, sp, #0
    RM3100_return_t returnVal = values_loop();
     2f2:	1d3b      	adds	r3, r7, #4
     2f4:	4618      	mov	r0, r3
     2f6:	4b03      	ldr	r3, [pc, #12]	; (304 <runRM3100+0x18>)
     2f8:	4798      	blx	r3
    if (returnVal.x == 0) {
     2fa:	687b      	ldr	r3, [r7, #4]
     2fc:	2b00      	cmp	r3, #0
        return;
    }
}
     2fe:	3710      	adds	r7, #16
     300:	46bd      	mov	sp, r7
     302:	bd80      	pop	{r7, pc}
     304:	00000f5d 	.word	0x00000f5d

00000308 <main>:

int main(void)
{
     308:	b580      	push	{r7, lr}
     30a:	af00      	add	r7, sp, #0
            /* Initializes MCU, drivers and middleware */
            atmel_start_init();
     30c:	4b07      	ldr	r3, [pc, #28]	; (32c <main+0x24>)
     30e:	4798      	blx	r3
            printf("ATMEL Initialization Complete!\n");
     310:	4907      	ldr	r1, [pc, #28]	; (330 <main+0x28>)
     312:	2000      	movs	r0, #0
     314:	4b07      	ldr	r3, [pc, #28]	; (334 <main+0x2c>)
     316:	4798      	blx	r3

            init_rm3100();
     318:	4b07      	ldr	r3, [pc, #28]	; (338 <main+0x30>)
     31a:	4798      	blx	r3
            // }

            // Start the scheduler
            //vTaskStartScheduler();

            printf("Work completed -- Looping forever\n");
     31c:	4907      	ldr	r1, [pc, #28]	; (33c <main+0x34>)
     31e:	2000      	movs	r0, #0
     320:	4b04      	ldr	r3, [pc, #16]	; (334 <main+0x2c>)
     322:	4798      	blx	r3
            while (1) {
                runRM3100();
     324:	4b06      	ldr	r3, [pc, #24]	; (340 <main+0x38>)
     326:	4798      	blx	r3
     328:	e7fc      	b.n	324 <main+0x1c>
     32a:	bf00      	nop
     32c:	00004979 	.word	0x00004979
     330:	00005468 	.word	0x00005468
     334:	00000d85 	.word	0x00000d85
     338:	00000ed9 	.word	0x00000ed9
     33c:	00005488 	.word	0x00005488
     340:	000002ed 	.word	0x000002ed

00000344 <_DoInit>:
      if (pRTTCBInit->acID[0] != 'S') {                                                      \
        _DoInit();                                                                           \
      }                                                                                      \
    } while (0)

static void _DoInit(void) {
     344:	b580      	push	{r7, lr}
     346:	b082      	sub	sp, #8
     348:	af00      	add	r7, sp, #0
  static const char _aInitStr[] = "\0\0\0\0\0\0TTR REGGES";  // Init complete ID string to make sure that things also work if RTT is linked to a no-init memory area
  unsigned i;
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
     34a:	4b26      	ldr	r3, [pc, #152]	; (3e4 <_DoInit+0xa0>)
     34c:	603b      	str	r3, [r7, #0]
  memset((SEGGER_RTT_CB*)p, 0, sizeof(_SEGGER_RTT));         // Make sure that the RTT CB is always zero initialized.
     34e:	22a8      	movs	r2, #168	; 0xa8
     350:	2100      	movs	r1, #0
     352:	6838      	ldr	r0, [r7, #0]
     354:	4b24      	ldr	r3, [pc, #144]	; (3e8 <_DoInit+0xa4>)
     356:	4798      	blx	r3
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
     358:	683b      	ldr	r3, [r7, #0]
     35a:	2203      	movs	r2, #3
     35c:	611a      	str	r2, [r3, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
     35e:	683b      	ldr	r3, [r7, #0]
     360:	2203      	movs	r2, #3
     362:	615a      	str	r2, [r3, #20]
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
     364:	683b      	ldr	r3, [r7, #0]
     366:	4a21      	ldr	r2, [pc, #132]	; (3ec <_DoInit+0xa8>)
     368:	619a      	str	r2, [r3, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
     36a:	683b      	ldr	r3, [r7, #0]
     36c:	4a20      	ldr	r2, [pc, #128]	; (3f0 <_DoInit+0xac>)
     36e:	61da      	str	r2, [r3, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
     370:	683b      	ldr	r3, [r7, #0]
     372:	f44f 6280 	mov.w	r2, #1024	; 0x400
     376:	621a      	str	r2, [r3, #32]
  p->aUp[0].RdOff         = 0u;
     378:	683b      	ldr	r3, [r7, #0]
     37a:	2200      	movs	r2, #0
     37c:	629a      	str	r2, [r3, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
     37e:	683b      	ldr	r3, [r7, #0]
     380:	2200      	movs	r2, #0
     382:	625a      	str	r2, [r3, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
     384:	683b      	ldr	r3, [r7, #0]
     386:	2200      	movs	r2, #0
     388:	62da      	str	r2, [r3, #44]	; 0x2c
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
     38a:	683b      	ldr	r3, [r7, #0]
     38c:	4a17      	ldr	r2, [pc, #92]	; (3ec <_DoInit+0xa8>)
     38e:	661a      	str	r2, [r3, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
     390:	683b      	ldr	r3, [r7, #0]
     392:	4a18      	ldr	r2, [pc, #96]	; (3f4 <_DoInit+0xb0>)
     394:	665a      	str	r2, [r3, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
     396:	683b      	ldr	r3, [r7, #0]
     398:	2210      	movs	r2, #16
     39a:	669a      	str	r2, [r3, #104]	; 0x68
  p->aDown[0].RdOff         = 0u;
     39c:	683b      	ldr	r3, [r7, #0]
     39e:	2200      	movs	r2, #0
     3a0:	671a      	str	r2, [r3, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
     3a2:	683b      	ldr	r3, [r7, #0]
     3a4:	2200      	movs	r2, #0
     3a6:	66da      	str	r2, [r3, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
     3a8:	683b      	ldr	r3, [r7, #0]
     3aa:	2200      	movs	r2, #0
     3ac:	675a      	str	r2, [r3, #116]	; 0x74
  //
  // Finish initialization of the control block.
  // Copy Id string backwards to make sure that "SEGGER RTT" is not found in initializer memory (usually flash),
  // as this would cause J-Link to "find" the control block at a wrong address.
  //
  RTT__DMB();                       // Force order of memory accesses for cores that may perform out-of-order memory accesses
     3ae:	f3bf 8f5f 	dmb	sy
  for (i = 0; i < sizeof(_aInitStr) - 1; ++i) {
     3b2:	2300      	movs	r3, #0
     3b4:	607b      	str	r3, [r7, #4]
     3b6:	e00c      	b.n	3d2 <_DoInit+0x8e>
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
     3b8:	687b      	ldr	r3, [r7, #4]
     3ba:	f1c3 030f 	rsb	r3, r3, #15
     3be:	4a0e      	ldr	r2, [pc, #56]	; (3f8 <_DoInit+0xb4>)
     3c0:	5cd1      	ldrb	r1, [r2, r3]
     3c2:	683a      	ldr	r2, [r7, #0]
     3c4:	687b      	ldr	r3, [r7, #4]
     3c6:	4413      	add	r3, r2
     3c8:	460a      	mov	r2, r1
     3ca:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < sizeof(_aInitStr) - 1; ++i) {
     3cc:	687b      	ldr	r3, [r7, #4]
     3ce:	3301      	adds	r3, #1
     3d0:	607b      	str	r3, [r7, #4]
     3d2:	687b      	ldr	r3, [r7, #4]
     3d4:	2b0f      	cmp	r3, #15
     3d6:	d9ef      	bls.n	3b8 <_DoInit+0x74>
  }
  RTT__DMB();                       // Force order of memory accesses for cores that may perform out-of-order memory accesses
     3d8:	f3bf 8f5f 	dmb	sy
}
     3dc:	bf00      	nop
     3de:	3708      	adds	r7, #8
     3e0:	46bd      	mov	sp, r7
     3e2:	bd80      	pop	{r7, pc}
     3e4:	2000004c 	.word	0x2000004c
     3e8:	000053c5 	.word	0x000053c5
     3ec:	000054bc 	.word	0x000054bc
     3f0:	200000f4 	.word	0x200000f4
     3f4:	200004f4 	.word	0x200004f4
     3f8:	000054c8 	.word	0x000054c8

000003fc <_WriteBlocking>:
*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
*
*  Return value
*    >= 0 - Number of bytes written into buffer.
*/
static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
     3fc:	b580      	push	{r7, lr}
     3fe:	b08a      	sub	sp, #40	; 0x28
     400:	af00      	add	r7, sp, #0
     402:	60f8      	str	r0, [r7, #12]
     404:	60b9      	str	r1, [r7, #8]
     406:	607a      	str	r2, [r7, #4]
  unsigned WrOff;
  volatile char* pDst;
  //
  // Write data to buffer and handle wrap-around if necessary
  //
  NumBytesWritten = 0u;
     408:	2300      	movs	r3, #0
     40a:	623b      	str	r3, [r7, #32]
  WrOff = pRing->WrOff;
     40c:	68fb      	ldr	r3, [r7, #12]
     40e:	68db      	ldr	r3, [r3, #12]
     410:	61fb      	str	r3, [r7, #28]
  do {
    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
     412:	68fb      	ldr	r3, [r7, #12]
     414:	691b      	ldr	r3, [r3, #16]
     416:	61bb      	str	r3, [r7, #24]
    if (RdOff > WrOff) {
     418:	69ba      	ldr	r2, [r7, #24]
     41a:	69fb      	ldr	r3, [r7, #28]
     41c:	429a      	cmp	r2, r3
     41e:	d905      	bls.n	42c <_WriteBlocking+0x30>
      NumBytesToWrite = RdOff - WrOff - 1u;
     420:	69ba      	ldr	r2, [r7, #24]
     422:	69fb      	ldr	r3, [r7, #28]
     424:	1ad3      	subs	r3, r2, r3
     426:	3b01      	subs	r3, #1
     428:	627b      	str	r3, [r7, #36]	; 0x24
     42a:	e007      	b.n	43c <_WriteBlocking+0x40>
    } else {
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
     42c:	68fb      	ldr	r3, [r7, #12]
     42e:	689a      	ldr	r2, [r3, #8]
     430:	69b9      	ldr	r1, [r7, #24]
     432:	69fb      	ldr	r3, [r7, #28]
     434:	1acb      	subs	r3, r1, r3
     436:	4413      	add	r3, r2
     438:	3b01      	subs	r3, #1
     43a:	627b      	str	r3, [r7, #36]	; 0x24
    }
    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
     43c:	68fb      	ldr	r3, [r7, #12]
     43e:	689a      	ldr	r2, [r3, #8]
     440:	69fb      	ldr	r3, [r7, #28]
     442:	1ad3      	subs	r3, r2, r3
     444:	6a7a      	ldr	r2, [r7, #36]	; 0x24
     446:	4293      	cmp	r3, r2
     448:	bf28      	it	cs
     44a:	4613      	movcs	r3, r2
     44c:	627b      	str	r3, [r7, #36]	; 0x24
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
     44e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
     450:	687b      	ldr	r3, [r7, #4]
     452:	4293      	cmp	r3, r2
     454:	bf28      	it	cs
     456:	4613      	movcs	r3, r2
     458:	627b      	str	r3, [r7, #36]	; 0x24
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
     45a:	68fb      	ldr	r3, [r7, #12]
     45c:	685a      	ldr	r2, [r3, #4]
     45e:	69fb      	ldr	r3, [r7, #28]
     460:	4413      	add	r3, r2
     462:	617b      	str	r3, [r7, #20]
    WrOff           += NumBytesToWrite;
    while (NumBytesToWrite--) {
      *pDst++ = *pBuffer++;
    };
#else
    SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
     464:	6a7a      	ldr	r2, [r7, #36]	; 0x24
     466:	68b9      	ldr	r1, [r7, #8]
     468:	6978      	ldr	r0, [r7, #20]
     46a:	4b13      	ldr	r3, [pc, #76]	; (4b8 <_WriteBlocking+0xbc>)
     46c:	4798      	blx	r3
    NumBytesWritten += NumBytesToWrite;
     46e:	6a3a      	ldr	r2, [r7, #32]
     470:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     472:	4413      	add	r3, r2
     474:	623b      	str	r3, [r7, #32]
    pBuffer         += NumBytesToWrite;
     476:	68ba      	ldr	r2, [r7, #8]
     478:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     47a:	4413      	add	r3, r2
     47c:	60bb      	str	r3, [r7, #8]
    NumBytes        -= NumBytesToWrite;
     47e:	687a      	ldr	r2, [r7, #4]
     480:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     482:	1ad3      	subs	r3, r2, r3
     484:	607b      	str	r3, [r7, #4]
    WrOff           += NumBytesToWrite;
     486:	69fa      	ldr	r2, [r7, #28]
     488:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     48a:	4413      	add	r3, r2
     48c:	61fb      	str	r3, [r7, #28]
#endif
    if (WrOff == pRing->SizeOfBuffer) {
     48e:	68fb      	ldr	r3, [r7, #12]
     490:	689b      	ldr	r3, [r3, #8]
     492:	69fa      	ldr	r2, [r7, #28]
     494:	429a      	cmp	r2, r3
     496:	d101      	bne.n	49c <_WriteBlocking+0xa0>
      WrOff = 0u;
     498:	2300      	movs	r3, #0
     49a:	61fb      	str	r3, [r7, #28]
    }
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
     49c:	f3bf 8f5f 	dmb	sy
    pRing->WrOff = WrOff;
     4a0:	68fb      	ldr	r3, [r7, #12]
     4a2:	69fa      	ldr	r2, [r7, #28]
     4a4:	60da      	str	r2, [r3, #12]
  } while (NumBytes);
     4a6:	687b      	ldr	r3, [r7, #4]
     4a8:	2b00      	cmp	r3, #0
     4aa:	d1b2      	bne.n	412 <_WriteBlocking+0x16>
  return NumBytesWritten;
     4ac:	6a3b      	ldr	r3, [r7, #32]
}
     4ae:	4618      	mov	r0, r3
     4b0:	3728      	adds	r7, #40	; 0x28
     4b2:	46bd      	mov	sp, r7
     4b4:	bd80      	pop	{r7, pc}
     4b6:	bf00      	nop
     4b8:	00005291 	.word	0x00005291

000004bc <_WriteNoCheck>:
*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
*
*  Notes
*    (1) If there might not be enough space in the "Up"-buffer, call _WriteBlocking
*/
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
     4bc:	b580      	push	{r7, lr}
     4be:	b088      	sub	sp, #32
     4c0:	af00      	add	r7, sp, #0
     4c2:	60f8      	str	r0, [r7, #12]
     4c4:	60b9      	str	r1, [r7, #8]
     4c6:	607a      	str	r2, [r7, #4]
  unsigned NumBytesAtOnce;
  unsigned WrOff;
  unsigned Rem;
  volatile char* pDst;

  WrOff = pRing->WrOff;
     4c8:	68fb      	ldr	r3, [r7, #12]
     4ca:	68db      	ldr	r3, [r3, #12]
     4cc:	61fb      	str	r3, [r7, #28]
  Rem = pRing->SizeOfBuffer - WrOff;
     4ce:	68fb      	ldr	r3, [r7, #12]
     4d0:	689a      	ldr	r2, [r3, #8]
     4d2:	69fb      	ldr	r3, [r7, #28]
     4d4:	1ad3      	subs	r3, r2, r3
     4d6:	61bb      	str	r3, [r7, #24]
  if (Rem > NumBytes) {
     4d8:	69ba      	ldr	r2, [r7, #24]
     4da:	687b      	ldr	r3, [r7, #4]
     4dc:	429a      	cmp	r2, r3
     4de:	d911      	bls.n	504 <_WriteNoCheck+0x48>
    //
    // All data fits before wrap around
    //
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
     4e0:	68fb      	ldr	r3, [r7, #12]
     4e2:	685a      	ldr	r2, [r3, #4]
     4e4:	69fb      	ldr	r3, [r7, #28]
     4e6:	4413      	add	r3, r2
     4e8:	613b      	str	r3, [r7, #16]
      *pDst++ = *pData++;
    };
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = WrOff;
#else
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
     4ea:	687a      	ldr	r2, [r7, #4]
     4ec:	68b9      	ldr	r1, [r7, #8]
     4ee:	6938      	ldr	r0, [r7, #16]
     4f0:	4b16      	ldr	r3, [pc, #88]	; (54c <_WriteNoCheck+0x90>)
     4f2:	4798      	blx	r3
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
     4f4:	f3bf 8f5f 	dmb	sy
    pRing->WrOff = WrOff + NumBytes;
     4f8:	69fa      	ldr	r2, [r7, #28]
     4fa:	687b      	ldr	r3, [r7, #4]
     4fc:	441a      	add	r2, r3
     4fe:	68fb      	ldr	r3, [r7, #12]
     500:	60da      	str	r2, [r3, #12]
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = NumBytesAtOnce;
#endif
  }
}
     502:	e01f      	b.n	544 <_WriteNoCheck+0x88>
    NumBytesAtOnce = Rem;
     504:	69bb      	ldr	r3, [r7, #24]
     506:	617b      	str	r3, [r7, #20]
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
     508:	68fb      	ldr	r3, [r7, #12]
     50a:	685a      	ldr	r2, [r3, #4]
     50c:	69fb      	ldr	r3, [r7, #28]
     50e:	4413      	add	r3, r2
     510:	613b      	str	r3, [r7, #16]
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
     512:	697a      	ldr	r2, [r7, #20]
     514:	68b9      	ldr	r1, [r7, #8]
     516:	6938      	ldr	r0, [r7, #16]
     518:	4b0c      	ldr	r3, [pc, #48]	; (54c <_WriteNoCheck+0x90>)
     51a:	4798      	blx	r3
    NumBytesAtOnce = NumBytes - Rem;
     51c:	687a      	ldr	r2, [r7, #4]
     51e:	69bb      	ldr	r3, [r7, #24]
     520:	1ad3      	subs	r3, r2, r3
     522:	617b      	str	r3, [r7, #20]
    pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
     524:	68fb      	ldr	r3, [r7, #12]
     526:	685b      	ldr	r3, [r3, #4]
     528:	613b      	str	r3, [r7, #16]
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
     52a:	68ba      	ldr	r2, [r7, #8]
     52c:	69bb      	ldr	r3, [r7, #24]
     52e:	4413      	add	r3, r2
     530:	697a      	ldr	r2, [r7, #20]
     532:	4619      	mov	r1, r3
     534:	6938      	ldr	r0, [r7, #16]
     536:	4b05      	ldr	r3, [pc, #20]	; (54c <_WriteNoCheck+0x90>)
     538:	4798      	blx	r3
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
     53a:	f3bf 8f5f 	dmb	sy
    pRing->WrOff = NumBytesAtOnce;
     53e:	68fb      	ldr	r3, [r7, #12]
     540:	697a      	ldr	r2, [r7, #20]
     542:	60da      	str	r2, [r3, #12]
}
     544:	bf00      	nop
     546:	3720      	adds	r7, #32
     548:	46bd      	mov	sp, r7
     54a:	bd80      	pop	{r7, pc}
     54c:	00005291 	.word	0x00005291

00000550 <_GetAvailWriteSpace>:
*    pRing        Ring buffer to check.
*
*  Return value
*    Number of bytes that are free in the buffer.
*/
static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
     550:	b480      	push	{r7}
     552:	b087      	sub	sp, #28
     554:	af00      	add	r7, sp, #0
     556:	6078      	str	r0, [r7, #4]
  unsigned r;
  //
  // Avoid warnings regarding volatile access order.  It's not a problem
  // in this case, but dampen compiler enthusiasm.
  //
  RdOff = pRing->RdOff;
     558:	687b      	ldr	r3, [r7, #4]
     55a:	691b      	ldr	r3, [r3, #16]
     55c:	613b      	str	r3, [r7, #16]
  WrOff = pRing->WrOff;
     55e:	687b      	ldr	r3, [r7, #4]
     560:	68db      	ldr	r3, [r3, #12]
     562:	60fb      	str	r3, [r7, #12]
  if (RdOff <= WrOff) {
     564:	693a      	ldr	r2, [r7, #16]
     566:	68fb      	ldr	r3, [r7, #12]
     568:	429a      	cmp	r2, r3
     56a:	d808      	bhi.n	57e <_GetAvailWriteSpace+0x2e>
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
     56c:	687b      	ldr	r3, [r7, #4]
     56e:	689a      	ldr	r2, [r3, #8]
     570:	68fb      	ldr	r3, [r7, #12]
     572:	1ad2      	subs	r2, r2, r3
     574:	693b      	ldr	r3, [r7, #16]
     576:	4413      	add	r3, r2
     578:	3b01      	subs	r3, #1
     57a:	617b      	str	r3, [r7, #20]
     57c:	e004      	b.n	588 <_GetAvailWriteSpace+0x38>
  } else {
    r = RdOff - WrOff - 1u;
     57e:	693a      	ldr	r2, [r7, #16]
     580:	68fb      	ldr	r3, [r7, #12]
     582:	1ad3      	subs	r3, r2, r3
     584:	3b01      	subs	r3, #1
     586:	617b      	str	r3, [r7, #20]
  }
  return r;
     588:	697b      	ldr	r3, [r7, #20]
}
     58a:	4618      	mov	r0, r3
     58c:	371c      	adds	r7, #28
     58e:	46bd      	mov	sp, r7
     590:	f85d 7b04 	ldr.w	r7, [sp], #4
     594:	4770      	bx	lr
	...

00000598 <SEGGER_RTT_WriteNoLock>:
*    (1) Data is stored according to buffer flags.
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
     598:	b580      	push	{r7, lr}
     59a:	b088      	sub	sp, #32
     59c:	af00      	add	r7, sp, #0
     59e:	60f8      	str	r0, [r7, #12]
     5a0:	60b9      	str	r1, [r7, #8]
     5a2:	607a      	str	r2, [r7, #4]
  const char*           pData;
  SEGGER_RTT_BUFFER_UP* pRing;
  //
  // Get "to-host" ring buffer.
  //
  pData = (const char *)pBuffer;
     5a4:	68bb      	ldr	r3, [r7, #8]
     5a6:	61bb      	str	r3, [r7, #24]
  pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
     5a8:	68fb      	ldr	r3, [r7, #12]
     5aa:	1c5a      	adds	r2, r3, #1
     5ac:	4613      	mov	r3, r2
     5ae:	005b      	lsls	r3, r3, #1
     5b0:	4413      	add	r3, r2
     5b2:	00db      	lsls	r3, r3, #3
     5b4:	4a1f      	ldr	r2, [pc, #124]	; (634 <SEGGER_RTT_WriteNoLock+0x9c>)
     5b6:	4413      	add	r3, r2
     5b8:	617b      	str	r3, [r7, #20]
  //
  // How we output depends upon the mode...
  //
  switch (pRing->Flags) {
     5ba:	697b      	ldr	r3, [r7, #20]
     5bc:	695b      	ldr	r3, [r3, #20]
     5be:	2b02      	cmp	r3, #2
     5c0:	d029      	beq.n	616 <SEGGER_RTT_WriteNoLock+0x7e>
     5c2:	2b02      	cmp	r3, #2
     5c4:	d82e      	bhi.n	624 <SEGGER_RTT_WriteNoLock+0x8c>
     5c6:	2b00      	cmp	r3, #0
     5c8:	d002      	beq.n	5d0 <SEGGER_RTT_WriteNoLock+0x38>
     5ca:	2b01      	cmp	r3, #1
     5cc:	d013      	beq.n	5f6 <SEGGER_RTT_WriteNoLock+0x5e>
     5ce:	e029      	b.n	624 <SEGGER_RTT_WriteNoLock+0x8c>
  case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
    //
    // If we are in skip mode and there is no space for the whole
    // of this output, don't bother.
    //
    Avail = _GetAvailWriteSpace(pRing);
     5d0:	6978      	ldr	r0, [r7, #20]
     5d2:	4b19      	ldr	r3, [pc, #100]	; (638 <SEGGER_RTT_WriteNoLock+0xa0>)
     5d4:	4798      	blx	r3
     5d6:	6138      	str	r0, [r7, #16]
    if (Avail < NumBytes) {
     5d8:	693a      	ldr	r2, [r7, #16]
     5da:	687b      	ldr	r3, [r7, #4]
     5dc:	429a      	cmp	r2, r3
     5de:	d202      	bcs.n	5e6 <SEGGER_RTT_WriteNoLock+0x4e>
      Status = 0u;
     5e0:	2300      	movs	r3, #0
     5e2:	61fb      	str	r3, [r7, #28]
    } else {
      Status = NumBytes;
      _WriteNoCheck(pRing, pData, NumBytes);
    }
    break;
     5e4:	e021      	b.n	62a <SEGGER_RTT_WriteNoLock+0x92>
      Status = NumBytes;
     5e6:	687b      	ldr	r3, [r7, #4]
     5e8:	61fb      	str	r3, [r7, #28]
      _WriteNoCheck(pRing, pData, NumBytes);
     5ea:	687a      	ldr	r2, [r7, #4]
     5ec:	69b9      	ldr	r1, [r7, #24]
     5ee:	6978      	ldr	r0, [r7, #20]
     5f0:	4b12      	ldr	r3, [pc, #72]	; (63c <SEGGER_RTT_WriteNoLock+0xa4>)
     5f2:	4798      	blx	r3
    break;
     5f4:	e019      	b.n	62a <SEGGER_RTT_WriteNoLock+0x92>
  case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
    //
    // If we are in trim mode, trim to what we can output without blocking.
    //
    Avail = _GetAvailWriteSpace(pRing);
     5f6:	6978      	ldr	r0, [r7, #20]
     5f8:	4b0f      	ldr	r3, [pc, #60]	; (638 <SEGGER_RTT_WriteNoLock+0xa0>)
     5fa:	4798      	blx	r3
     5fc:	6138      	str	r0, [r7, #16]
    Status = Avail < NumBytes ? Avail : NumBytes;
     5fe:	687a      	ldr	r2, [r7, #4]
     600:	693b      	ldr	r3, [r7, #16]
     602:	4293      	cmp	r3, r2
     604:	bf28      	it	cs
     606:	4613      	movcs	r3, r2
     608:	61fb      	str	r3, [r7, #28]
    _WriteNoCheck(pRing, pData, Status);
     60a:	69fa      	ldr	r2, [r7, #28]
     60c:	69b9      	ldr	r1, [r7, #24]
     60e:	6978      	ldr	r0, [r7, #20]
     610:	4b0a      	ldr	r3, [pc, #40]	; (63c <SEGGER_RTT_WriteNoLock+0xa4>)
     612:	4798      	blx	r3
    break;
     614:	e009      	b.n	62a <SEGGER_RTT_WriteNoLock+0x92>
  case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
    //
    // If we are in blocking mode, output everything.
    //
    Status = _WriteBlocking(pRing, pData, NumBytes);
     616:	687a      	ldr	r2, [r7, #4]
     618:	69b9      	ldr	r1, [r7, #24]
     61a:	6978      	ldr	r0, [r7, #20]
     61c:	4b08      	ldr	r3, [pc, #32]	; (640 <SEGGER_RTT_WriteNoLock+0xa8>)
     61e:	4798      	blx	r3
     620:	61f8      	str	r0, [r7, #28]
    break;
     622:	e002      	b.n	62a <SEGGER_RTT_WriteNoLock+0x92>
  default:
    Status = 0u;
     624:	2300      	movs	r3, #0
     626:	61fb      	str	r3, [r7, #28]
    break;
     628:	bf00      	nop
  }
  //
  // Finish up.
  //
  return Status;
     62a:	69fb      	ldr	r3, [r7, #28]
}
     62c:	4618      	mov	r0, r3
     62e:	3720      	adds	r7, #32
     630:	46bd      	mov	sp, r7
     632:	bd80      	pop	{r7, pc}
     634:	2000004c 	.word	0x2000004c
     638:	00000551 	.word	0x00000551
     63c:	000004bd 	.word	0x000004bd
     640:	000003fd 	.word	0x000003fd

00000644 <SEGGER_RTT_Write>:
*    Number of bytes which have been stored in the "Up"-buffer.
*
*  Notes
*    (1) Data is stored according to buffer flags.
*/
unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
     644:	b580      	push	{r7, lr}
     646:	b088      	sub	sp, #32
     648:	af00      	add	r7, sp, #0
     64a:	60f8      	str	r0, [r7, #12]
     64c:	60b9      	str	r1, [r7, #8]
     64e:	607a      	str	r2, [r7, #4]
  unsigned Status;

  INIT();
     650:	4b0e      	ldr	r3, [pc, #56]	; (68c <SEGGER_RTT_Write+0x48>)
     652:	61fb      	str	r3, [r7, #28]
     654:	69fb      	ldr	r3, [r7, #28]
     656:	781b      	ldrb	r3, [r3, #0]
     658:	b2db      	uxtb	r3, r3
     65a:	2b53      	cmp	r3, #83	; 0x53
     65c:	d001      	beq.n	662 <SEGGER_RTT_Write+0x1e>
     65e:	4b0c      	ldr	r3, [pc, #48]	; (690 <SEGGER_RTT_Write+0x4c>)
     660:	4798      	blx	r3
  SEGGER_RTT_LOCK();
     662:	f3ef 8311 	mrs	r3, BASEPRI
     666:	f04f 0120 	mov.w	r1, #32
     66a:	f381 8811 	msr	BASEPRI, r1
     66e:	61bb      	str	r3, [r7, #24]
  Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);  // Call the non-locking write function
     670:	687a      	ldr	r2, [r7, #4]
     672:	68b9      	ldr	r1, [r7, #8]
     674:	68f8      	ldr	r0, [r7, #12]
     676:	4b07      	ldr	r3, [pc, #28]	; (694 <SEGGER_RTT_Write+0x50>)
     678:	4798      	blx	r3
     67a:	6178      	str	r0, [r7, #20]
  SEGGER_RTT_UNLOCK();
     67c:	69bb      	ldr	r3, [r7, #24]
     67e:	f383 8811 	msr	BASEPRI, r3
  return Status;
     682:	697b      	ldr	r3, [r7, #20]
}
     684:	4618      	mov	r0, r3
     686:	3720      	adds	r7, #32
     688:	46bd      	mov	sp, r7
     68a:	bd80      	pop	{r7, pc}
     68c:	2000004c 	.word	0x2000004c
     690:	00000345 	.word	0x00000345
     694:	00000599 	.word	0x00000599

00000698 <_StoreChar>:
*/
/*********************************************************************
*
*       _StoreChar
*/
static void _StoreChar(SEGGER_RTT_PRINTF_DESC * p, char c) {
     698:	b580      	push	{r7, lr}
     69a:	b084      	sub	sp, #16
     69c:	af00      	add	r7, sp, #0
     69e:	6078      	str	r0, [r7, #4]
     6a0:	460b      	mov	r3, r1
     6a2:	70fb      	strb	r3, [r7, #3]
  unsigned Cnt;

  Cnt = p->Cnt;
     6a4:	687b      	ldr	r3, [r7, #4]
     6a6:	689b      	ldr	r3, [r3, #8]
     6a8:	60fb      	str	r3, [r7, #12]
  if ((Cnt + 1u) <= p->BufferSize) {
     6aa:	68fb      	ldr	r3, [r7, #12]
     6ac:	1c5a      	adds	r2, r3, #1
     6ae:	687b      	ldr	r3, [r7, #4]
     6b0:	685b      	ldr	r3, [r3, #4]
     6b2:	429a      	cmp	r2, r3
     6b4:	d80e      	bhi.n	6d4 <_StoreChar+0x3c>
    *(p->pBuffer + Cnt) = c;
     6b6:	687b      	ldr	r3, [r7, #4]
     6b8:	681a      	ldr	r2, [r3, #0]
     6ba:	68fb      	ldr	r3, [r7, #12]
     6bc:	4413      	add	r3, r2
     6be:	78fa      	ldrb	r2, [r7, #3]
     6c0:	701a      	strb	r2, [r3, #0]
    p->Cnt = Cnt + 1u;
     6c2:	68fb      	ldr	r3, [r7, #12]
     6c4:	1c5a      	adds	r2, r3, #1
     6c6:	687b      	ldr	r3, [r7, #4]
     6c8:	609a      	str	r2, [r3, #8]
    p->ReturnValue++;
     6ca:	687b      	ldr	r3, [r7, #4]
     6cc:	68db      	ldr	r3, [r3, #12]
     6ce:	1c5a      	adds	r2, r3, #1
     6d0:	687b      	ldr	r3, [r7, #4]
     6d2:	60da      	str	r2, [r3, #12]
  }
  //
  // Write part of string, when the buffer is full
  //
  if (p->Cnt == p->BufferSize) {
     6d4:	687b      	ldr	r3, [r7, #4]
     6d6:	689a      	ldr	r2, [r3, #8]
     6d8:	687b      	ldr	r3, [r7, #4]
     6da:	685b      	ldr	r3, [r3, #4]
     6dc:	429a      	cmp	r2, r3
     6de:	d115      	bne.n	70c <_StoreChar+0x74>
    if (SEGGER_RTT_Write(p->RTTBufferIndex, p->pBuffer, p->Cnt) != p->Cnt) {
     6e0:	687b      	ldr	r3, [r7, #4]
     6e2:	6918      	ldr	r0, [r3, #16]
     6e4:	687b      	ldr	r3, [r7, #4]
     6e6:	6819      	ldr	r1, [r3, #0]
     6e8:	687b      	ldr	r3, [r7, #4]
     6ea:	689b      	ldr	r3, [r3, #8]
     6ec:	461a      	mov	r2, r3
     6ee:	4b09      	ldr	r3, [pc, #36]	; (714 <_StoreChar+0x7c>)
     6f0:	4798      	blx	r3
     6f2:	4602      	mov	r2, r0
     6f4:	687b      	ldr	r3, [r7, #4]
     6f6:	689b      	ldr	r3, [r3, #8]
     6f8:	429a      	cmp	r2, r3
     6fa:	d004      	beq.n	706 <_StoreChar+0x6e>
      p->ReturnValue = -1;
     6fc:	687b      	ldr	r3, [r7, #4]
     6fe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     702:	60da      	str	r2, [r3, #12]
    } else {
      p->Cnt = 0u;
    }
  }
}
     704:	e002      	b.n	70c <_StoreChar+0x74>
      p->Cnt = 0u;
     706:	687b      	ldr	r3, [r7, #4]
     708:	2200      	movs	r2, #0
     70a:	609a      	str	r2, [r3, #8]
}
     70c:	bf00      	nop
     70e:	3710      	adds	r7, #16
     710:	46bd      	mov	sp, r7
     712:	bd80      	pop	{r7, pc}
     714:	00000645 	.word	0x00000645

00000718 <_PrintUnsigned>:

/*********************************************************************
*
*       _PrintUnsigned
*/
static void _PrintUnsigned(SEGGER_RTT_PRINTF_DESC * pBufferDesc, unsigned v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
     718:	b580      	push	{r7, lr}
     71a:	b08a      	sub	sp, #40	; 0x28
     71c:	af00      	add	r7, sp, #0
     71e:	60f8      	str	r0, [r7, #12]
     720:	60b9      	str	r1, [r7, #8]
     722:	607a      	str	r2, [r7, #4]
     724:	603b      	str	r3, [r7, #0]
  unsigned Digit;
  unsigned Number;
  unsigned Width;
  char c;

  Number = v;
     726:	68bb      	ldr	r3, [r7, #8]
     728:	623b      	str	r3, [r7, #32]
  Digit = 1u;
     72a:	2301      	movs	r3, #1
     72c:	627b      	str	r3, [r7, #36]	; 0x24
  //
  // Get actual field width
  //
  Width = 1u;
     72e:	2301      	movs	r3, #1
     730:	61fb      	str	r3, [r7, #28]
  while (Number >= Base) {
     732:	e007      	b.n	744 <_PrintUnsigned+0x2c>
    Number = (Number / Base);
     734:	6a3a      	ldr	r2, [r7, #32]
     736:	687b      	ldr	r3, [r7, #4]
     738:	fbb2 f3f3 	udiv	r3, r2, r3
     73c:	623b      	str	r3, [r7, #32]
    Width++;
     73e:	69fb      	ldr	r3, [r7, #28]
     740:	3301      	adds	r3, #1
     742:	61fb      	str	r3, [r7, #28]
  while (Number >= Base) {
     744:	6a3a      	ldr	r2, [r7, #32]
     746:	687b      	ldr	r3, [r7, #4]
     748:	429a      	cmp	r2, r3
     74a:	d2f3      	bcs.n	734 <_PrintUnsigned+0x1c>
  }
  if (NumDigits > Width) {
     74c:	683a      	ldr	r2, [r7, #0]
     74e:	69fb      	ldr	r3, [r7, #28]
     750:	429a      	cmp	r2, r3
     752:	d901      	bls.n	758 <_PrintUnsigned+0x40>
    Width = NumDigits;
     754:	683b      	ldr	r3, [r7, #0]
     756:	61fb      	str	r3, [r7, #28]
  }
  //
  // Print leading chars if necessary
  //
  if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) {
     758:	6b7b      	ldr	r3, [r7, #52]	; 0x34
     75a:	f003 0301 	and.w	r3, r3, #1
     75e:	2b00      	cmp	r3, #0
     760:	d125      	bne.n	7ae <_PrintUnsigned+0x96>
    if (FieldWidth != 0u) {
     762:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     764:	2b00      	cmp	r3, #0
     766:	d022      	beq.n	7ae <_PrintUnsigned+0x96>
      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && (NumDigits == 0u)) {
     768:	6b7b      	ldr	r3, [r7, #52]	; 0x34
     76a:	f003 0302 	and.w	r3, r3, #2
     76e:	2b00      	cmp	r3, #0
     770:	d005      	beq.n	77e <_PrintUnsigned+0x66>
     772:	683b      	ldr	r3, [r7, #0]
     774:	2b00      	cmp	r3, #0
     776:	d102      	bne.n	77e <_PrintUnsigned+0x66>
        c = '0';
     778:	2330      	movs	r3, #48	; 0x30
     77a:	76fb      	strb	r3, [r7, #27]
     77c:	e001      	b.n	782 <_PrintUnsigned+0x6a>
      } else {
        c = ' ';
     77e:	2320      	movs	r3, #32
     780:	76fb      	strb	r3, [r7, #27]
      }
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
     782:	e00b      	b.n	79c <_PrintUnsigned+0x84>
        FieldWidth--;
     784:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     786:	3b01      	subs	r3, #1
     788:	633b      	str	r3, [r7, #48]	; 0x30
        _StoreChar(pBufferDesc, c);
     78a:	7efb      	ldrb	r3, [r7, #27]
     78c:	4619      	mov	r1, r3
     78e:	68f8      	ldr	r0, [r7, #12]
     790:	4b36      	ldr	r3, [pc, #216]	; (86c <_PrintUnsigned+0x154>)
     792:	4798      	blx	r3
        if (pBufferDesc->ReturnValue < 0) {
     794:	68fb      	ldr	r3, [r7, #12]
     796:	68db      	ldr	r3, [r3, #12]
     798:	2b00      	cmp	r3, #0
     79a:	db07      	blt.n	7ac <_PrintUnsigned+0x94>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
     79c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     79e:	2b00      	cmp	r3, #0
     7a0:	d005      	beq.n	7ae <_PrintUnsigned+0x96>
     7a2:	69fa      	ldr	r2, [r7, #28]
     7a4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     7a6:	429a      	cmp	r2, r3
     7a8:	d3ec      	bcc.n	784 <_PrintUnsigned+0x6c>
     7aa:	e000      	b.n	7ae <_PrintUnsigned+0x96>
          break;
     7ac:	bf00      	nop
        }
      }
    }
  }
  if (pBufferDesc->ReturnValue >= 0) {
     7ae:	68fb      	ldr	r3, [r7, #12]
     7b0:	68db      	ldr	r3, [r3, #12]
     7b2:	2b00      	cmp	r3, #0
     7b4:	db55      	blt.n	862 <_PrintUnsigned+0x14a>
    // Compute Digit.
    // Loop until Digit has the value of the highest digit required.
    // Example: If the output is 345 (Base 10), loop 2 times until Digit is 100.
    //
    while (1) {
      if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
     7b6:	683b      	ldr	r3, [r7, #0]
     7b8:	2b01      	cmp	r3, #1
     7ba:	d903      	bls.n	7c4 <_PrintUnsigned+0xac>
        NumDigits--;
     7bc:	683b      	ldr	r3, [r7, #0]
     7be:	3b01      	subs	r3, #1
     7c0:	603b      	str	r3, [r7, #0]
     7c2:	e009      	b.n	7d8 <_PrintUnsigned+0xc0>
      } else {
        Div = v / Digit;
     7c4:	68ba      	ldr	r2, [r7, #8]
     7c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     7c8:	fbb2 f3f3 	udiv	r3, r2, r3
     7cc:	617b      	str	r3, [r7, #20]
        if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
     7ce:	697a      	ldr	r2, [r7, #20]
     7d0:	687b      	ldr	r3, [r7, #4]
     7d2:	429a      	cmp	r2, r3
     7d4:	d200      	bcs.n	7d8 <_PrintUnsigned+0xc0>
          break;
     7d6:	e005      	b.n	7e4 <_PrintUnsigned+0xcc>
        }
      }
      Digit *= Base;
     7d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     7da:	687a      	ldr	r2, [r7, #4]
     7dc:	fb02 f303 	mul.w	r3, r2, r3
     7e0:	627b      	str	r3, [r7, #36]	; 0x24
      if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
     7e2:	e7e8      	b.n	7b6 <_PrintUnsigned+0x9e>
    }
    //
    // Output digits
    //
    do {
      Div = v / Digit;
     7e4:	68ba      	ldr	r2, [r7, #8]
     7e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     7e8:	fbb2 f3f3 	udiv	r3, r2, r3
     7ec:	617b      	str	r3, [r7, #20]
      v -= Div * Digit;
     7ee:	697b      	ldr	r3, [r7, #20]
     7f0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
     7f2:	fb02 f303 	mul.w	r3, r2, r3
     7f6:	68ba      	ldr	r2, [r7, #8]
     7f8:	1ad3      	subs	r3, r2, r3
     7fa:	60bb      	str	r3, [r7, #8]
      _StoreChar(pBufferDesc, _aV2C[Div]);
     7fc:	4a1c      	ldr	r2, [pc, #112]	; (870 <_PrintUnsigned+0x158>)
     7fe:	697b      	ldr	r3, [r7, #20]
     800:	4413      	add	r3, r2
     802:	781b      	ldrb	r3, [r3, #0]
     804:	4619      	mov	r1, r3
     806:	68f8      	ldr	r0, [r7, #12]
     808:	4b18      	ldr	r3, [pc, #96]	; (86c <_PrintUnsigned+0x154>)
     80a:	4798      	blx	r3
      if (pBufferDesc->ReturnValue < 0) {
     80c:	68fb      	ldr	r3, [r7, #12]
     80e:	68db      	ldr	r3, [r3, #12]
     810:	2b00      	cmp	r3, #0
     812:	db08      	blt.n	826 <_PrintUnsigned+0x10e>
        break;
      }
      Digit /= Base;
     814:	6a7a      	ldr	r2, [r7, #36]	; 0x24
     816:	687b      	ldr	r3, [r7, #4]
     818:	fbb2 f3f3 	udiv	r3, r2, r3
     81c:	627b      	str	r3, [r7, #36]	; 0x24
    } while (Digit);
     81e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     820:	2b00      	cmp	r3, #0
     822:	d1df      	bne.n	7e4 <_PrintUnsigned+0xcc>
     824:	e000      	b.n	828 <_PrintUnsigned+0x110>
        break;
     826:	bf00      	nop
    //
    // Print trailing spaces if necessary
    //
    if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == FORMAT_FLAG_LEFT_JUSTIFY) {
     828:	6b7b      	ldr	r3, [r7, #52]	; 0x34
     82a:	f003 0301 	and.w	r3, r3, #1
     82e:	2b00      	cmp	r3, #0
     830:	d017      	beq.n	862 <_PrintUnsigned+0x14a>
      if (FieldWidth != 0u) {
     832:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     834:	2b00      	cmp	r3, #0
     836:	d014      	beq.n	862 <_PrintUnsigned+0x14a>
        while ((FieldWidth != 0u) && (Width < FieldWidth)) {
     838:	e00a      	b.n	850 <_PrintUnsigned+0x138>
          FieldWidth--;
     83a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     83c:	3b01      	subs	r3, #1
     83e:	633b      	str	r3, [r7, #48]	; 0x30
          _StoreChar(pBufferDesc, ' ');
     840:	2120      	movs	r1, #32
     842:	68f8      	ldr	r0, [r7, #12]
     844:	4b09      	ldr	r3, [pc, #36]	; (86c <_PrintUnsigned+0x154>)
     846:	4798      	blx	r3
          if (pBufferDesc->ReturnValue < 0) {
     848:	68fb      	ldr	r3, [r7, #12]
     84a:	68db      	ldr	r3, [r3, #12]
     84c:	2b00      	cmp	r3, #0
     84e:	db07      	blt.n	860 <_PrintUnsigned+0x148>
        while ((FieldWidth != 0u) && (Width < FieldWidth)) {
     850:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     852:	2b00      	cmp	r3, #0
     854:	d005      	beq.n	862 <_PrintUnsigned+0x14a>
     856:	69fa      	ldr	r2, [r7, #28]
     858:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     85a:	429a      	cmp	r2, r3
     85c:	d3ed      	bcc.n	83a <_PrintUnsigned+0x122>
          }
        }
      }
    }
  }
}
     85e:	e000      	b.n	862 <_PrintUnsigned+0x14a>
            break;
     860:	bf00      	nop
}
     862:	bf00      	nop
     864:	3728      	adds	r7, #40	; 0x28
     866:	46bd      	mov	sp, r7
     868:	bd80      	pop	{r7, pc}
     86a:	bf00      	nop
     86c:	00000699 	.word	0x00000699
     870:	000054dc 	.word	0x000054dc

00000874 <_PrintInt>:

/*********************************************************************
*
*       _PrintInt
*/
static void _PrintInt(SEGGER_RTT_PRINTF_DESC * pBufferDesc, int v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
     874:	b590      	push	{r4, r7, lr}
     876:	b089      	sub	sp, #36	; 0x24
     878:	af02      	add	r7, sp, #8
     87a:	60f8      	str	r0, [r7, #12]
     87c:	60b9      	str	r1, [r7, #8]
     87e:	607a      	str	r2, [r7, #4]
     880:	603b      	str	r3, [r7, #0]
  unsigned Width;
  int Number;

  Number = (v < 0) ? -v : v;
     882:	68bb      	ldr	r3, [r7, #8]
     884:	2b00      	cmp	r3, #0
     886:	bfb8      	it	lt
     888:	425b      	neglt	r3, r3
     88a:	613b      	str	r3, [r7, #16]

  //
  // Get actual field width
  //
  Width = 1u;
     88c:	2301      	movs	r3, #1
     88e:	617b      	str	r3, [r7, #20]
  while (Number >= (int)Base) {
     890:	e007      	b.n	8a2 <_PrintInt+0x2e>
    Number = (Number / (int)Base);
     892:	687b      	ldr	r3, [r7, #4]
     894:	693a      	ldr	r2, [r7, #16]
     896:	fb92 f3f3 	sdiv	r3, r2, r3
     89a:	613b      	str	r3, [r7, #16]
    Width++;
     89c:	697b      	ldr	r3, [r7, #20]
     89e:	3301      	adds	r3, #1
     8a0:	617b      	str	r3, [r7, #20]
  while (Number >= (int)Base) {
     8a2:	687b      	ldr	r3, [r7, #4]
     8a4:	693a      	ldr	r2, [r7, #16]
     8a6:	429a      	cmp	r2, r3
     8a8:	daf3      	bge.n	892 <_PrintInt+0x1e>
  }
  if (NumDigits > Width) {
     8aa:	683a      	ldr	r2, [r7, #0]
     8ac:	697b      	ldr	r3, [r7, #20]
     8ae:	429a      	cmp	r2, r3
     8b0:	d901      	bls.n	8b6 <_PrintInt+0x42>
    Width = NumDigits;
     8b2:	683b      	ldr	r3, [r7, #0]
     8b4:	617b      	str	r3, [r7, #20]
  }
  if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN))) {
     8b6:	6abb      	ldr	r3, [r7, #40]	; 0x28
     8b8:	2b00      	cmp	r3, #0
     8ba:	d00a      	beq.n	8d2 <_PrintInt+0x5e>
     8bc:	68bb      	ldr	r3, [r7, #8]
     8be:	2b00      	cmp	r3, #0
     8c0:	db04      	blt.n	8cc <_PrintInt+0x58>
     8c2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     8c4:	f003 0304 	and.w	r3, r3, #4
     8c8:	2b00      	cmp	r3, #0
     8ca:	d002      	beq.n	8d2 <_PrintInt+0x5e>
    FieldWidth--;
     8cc:	6abb      	ldr	r3, [r7, #40]	; 0x28
     8ce:	3b01      	subs	r3, #1
     8d0:	62bb      	str	r3, [r7, #40]	; 0x28
  }

  //
  // Print leading spaces if necessary
  //
  if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
     8d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     8d4:	f003 0302 	and.w	r3, r3, #2
     8d8:	2b00      	cmp	r3, #0
     8da:	d002      	beq.n	8e2 <_PrintInt+0x6e>
     8dc:	683b      	ldr	r3, [r7, #0]
     8de:	2b00      	cmp	r3, #0
     8e0:	d01c      	beq.n	91c <_PrintInt+0xa8>
     8e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     8e4:	f003 0301 	and.w	r3, r3, #1
     8e8:	2b00      	cmp	r3, #0
     8ea:	d117      	bne.n	91c <_PrintInt+0xa8>
    if (FieldWidth != 0u) {
     8ec:	6abb      	ldr	r3, [r7, #40]	; 0x28
     8ee:	2b00      	cmp	r3, #0
     8f0:	d014      	beq.n	91c <_PrintInt+0xa8>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
     8f2:	e00a      	b.n	90a <_PrintInt+0x96>
        FieldWidth--;
     8f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
     8f6:	3b01      	subs	r3, #1
     8f8:	62bb      	str	r3, [r7, #40]	; 0x28
        _StoreChar(pBufferDesc, ' ');
     8fa:	2120      	movs	r1, #32
     8fc:	68f8      	ldr	r0, [r7, #12]
     8fe:	4b31      	ldr	r3, [pc, #196]	; (9c4 <_PrintInt+0x150>)
     900:	4798      	blx	r3
        if (pBufferDesc->ReturnValue < 0) {
     902:	68fb      	ldr	r3, [r7, #12]
     904:	68db      	ldr	r3, [r3, #12]
     906:	2b00      	cmp	r3, #0
     908:	db07      	blt.n	91a <_PrintInt+0xa6>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
     90a:	6abb      	ldr	r3, [r7, #40]	; 0x28
     90c:	2b00      	cmp	r3, #0
     90e:	d005      	beq.n	91c <_PrintInt+0xa8>
     910:	697a      	ldr	r2, [r7, #20]
     912:	6abb      	ldr	r3, [r7, #40]	; 0x28
     914:	429a      	cmp	r2, r3
     916:	d3ed      	bcc.n	8f4 <_PrintInt+0x80>
     918:	e000      	b.n	91c <_PrintInt+0xa8>
          break;
     91a:	bf00      	nop
    }
  }
  //
  // Print sign if necessary
  //
  if (pBufferDesc->ReturnValue >= 0) {
     91c:	68fb      	ldr	r3, [r7, #12]
     91e:	68db      	ldr	r3, [r3, #12]
     920:	2b00      	cmp	r3, #0
     922:	db4a      	blt.n	9ba <_PrintInt+0x146>
    if (v < 0) {
     924:	68bb      	ldr	r3, [r7, #8]
     926:	2b00      	cmp	r3, #0
     928:	da07      	bge.n	93a <_PrintInt+0xc6>
      v = -v;
     92a:	68bb      	ldr	r3, [r7, #8]
     92c:	425b      	negs	r3, r3
     92e:	60bb      	str	r3, [r7, #8]
      _StoreChar(pBufferDesc, '-');
     930:	212d      	movs	r1, #45	; 0x2d
     932:	68f8      	ldr	r0, [r7, #12]
     934:	4b23      	ldr	r3, [pc, #140]	; (9c4 <_PrintInt+0x150>)
     936:	4798      	blx	r3
     938:	e008      	b.n	94c <_PrintInt+0xd8>
    } else if ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN) {
     93a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     93c:	f003 0304 	and.w	r3, r3, #4
     940:	2b00      	cmp	r3, #0
     942:	d003      	beq.n	94c <_PrintInt+0xd8>
      _StoreChar(pBufferDesc, '+');
     944:	212b      	movs	r1, #43	; 0x2b
     946:	68f8      	ldr	r0, [r7, #12]
     948:	4b1e      	ldr	r3, [pc, #120]	; (9c4 <_PrintInt+0x150>)
     94a:	4798      	blx	r3
    } else {

    }
    if (pBufferDesc->ReturnValue >= 0) {
     94c:	68fb      	ldr	r3, [r7, #12]
     94e:	68db      	ldr	r3, [r3, #12]
     950:	2b00      	cmp	r3, #0
     952:	db32      	blt.n	9ba <_PrintInt+0x146>
      //
      // Print leading zeros if necessary
      //
      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
     954:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     956:	f003 0302 	and.w	r3, r3, #2
     95a:	2b00      	cmp	r3, #0
     95c:	d01f      	beq.n	99e <_PrintInt+0x12a>
     95e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     960:	f003 0301 	and.w	r3, r3, #1
     964:	2b00      	cmp	r3, #0
     966:	d11a      	bne.n	99e <_PrintInt+0x12a>
     968:	683b      	ldr	r3, [r7, #0]
     96a:	2b00      	cmp	r3, #0
     96c:	d117      	bne.n	99e <_PrintInt+0x12a>
        if (FieldWidth != 0u) {
     96e:	6abb      	ldr	r3, [r7, #40]	; 0x28
     970:	2b00      	cmp	r3, #0
     972:	d014      	beq.n	99e <_PrintInt+0x12a>
          while ((FieldWidth != 0u) && (Width < FieldWidth)) {
     974:	e00a      	b.n	98c <_PrintInt+0x118>
            FieldWidth--;
     976:	6abb      	ldr	r3, [r7, #40]	; 0x28
     978:	3b01      	subs	r3, #1
     97a:	62bb      	str	r3, [r7, #40]	; 0x28
            _StoreChar(pBufferDesc, '0');
     97c:	2130      	movs	r1, #48	; 0x30
     97e:	68f8      	ldr	r0, [r7, #12]
     980:	4b10      	ldr	r3, [pc, #64]	; (9c4 <_PrintInt+0x150>)
     982:	4798      	blx	r3
            if (pBufferDesc->ReturnValue < 0) {
     984:	68fb      	ldr	r3, [r7, #12]
     986:	68db      	ldr	r3, [r3, #12]
     988:	2b00      	cmp	r3, #0
     98a:	db07      	blt.n	99c <_PrintInt+0x128>
          while ((FieldWidth != 0u) && (Width < FieldWidth)) {
     98c:	6abb      	ldr	r3, [r7, #40]	; 0x28
     98e:	2b00      	cmp	r3, #0
     990:	d005      	beq.n	99e <_PrintInt+0x12a>
     992:	697a      	ldr	r2, [r7, #20]
     994:	6abb      	ldr	r3, [r7, #40]	; 0x28
     996:	429a      	cmp	r2, r3
     998:	d3ed      	bcc.n	976 <_PrintInt+0x102>
     99a:	e000      	b.n	99e <_PrintInt+0x12a>
              break;
     99c:	bf00      	nop
            }
          }
        }
      }
      if (pBufferDesc->ReturnValue >= 0) {
     99e:	68fb      	ldr	r3, [r7, #12]
     9a0:	68db      	ldr	r3, [r3, #12]
     9a2:	2b00      	cmp	r3, #0
     9a4:	db09      	blt.n	9ba <_PrintInt+0x146>
        //
        // Print number without sign
        //
        _PrintUnsigned(pBufferDesc, (unsigned)v, Base, NumDigits, FieldWidth, FormatFlags);
     9a6:	68b9      	ldr	r1, [r7, #8]
     9a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     9aa:	9301      	str	r3, [sp, #4]
     9ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
     9ae:	9300      	str	r3, [sp, #0]
     9b0:	683b      	ldr	r3, [r7, #0]
     9b2:	687a      	ldr	r2, [r7, #4]
     9b4:	68f8      	ldr	r0, [r7, #12]
     9b6:	4c04      	ldr	r4, [pc, #16]	; (9c8 <_PrintInt+0x154>)
     9b8:	47a0      	blx	r4
      }
    }
  }
}
     9ba:	bf00      	nop
     9bc:	371c      	adds	r7, #28
     9be:	46bd      	mov	sp, r7
     9c0:	bd90      	pop	{r4, r7, pc}
     9c2:	bf00      	nop
     9c4:	00000699 	.word	0x00000699
     9c8:	00000719 	.word	0x00000719

000009cc <SEGGER_RTT_vprintf>:
*
*  Return values
*    >= 0:  Number of bytes which have been stored in the "Up"-buffer.
*     < 0:  Error
*/
int SEGGER_RTT_vprintf(unsigned BufferIndex, const char * sFormat, va_list * pParamList) {
     9cc:	b590      	push	{r4, r7, lr}
     9ce:	b0a3      	sub	sp, #140	; 0x8c
     9d0:	af02      	add	r7, sp, #8
     9d2:	60f8      	str	r0, [r7, #12]
     9d4:	60b9      	str	r1, [r7, #8]
     9d6:	607a      	str	r2, [r7, #4]
  unsigned NumDigits;
  unsigned FormatFlags;
  unsigned FieldWidth;
  char acBuffer[SEGGER_RTT_PRINTF_BUFFER_SIZE];

  BufferDesc.pBuffer        = acBuffer;
     9d8:	f107 0310 	add.w	r3, r7, #16
     9dc:	653b      	str	r3, [r7, #80]	; 0x50
  BufferDesc.BufferSize     = SEGGER_RTT_PRINTF_BUFFER_SIZE;
     9de:	2340      	movs	r3, #64	; 0x40
     9e0:	657b      	str	r3, [r7, #84]	; 0x54
  BufferDesc.Cnt            = 0u;
     9e2:	2300      	movs	r3, #0
     9e4:	65bb      	str	r3, [r7, #88]	; 0x58
  BufferDesc.RTTBufferIndex = BufferIndex;
     9e6:	68fb      	ldr	r3, [r7, #12]
     9e8:	663b      	str	r3, [r7, #96]	; 0x60
  BufferDesc.ReturnValue    = 0;
     9ea:	2300      	movs	r3, #0
     9ec:	65fb      	str	r3, [r7, #92]	; 0x5c

  do {
    c = *sFormat;
     9ee:	68bb      	ldr	r3, [r7, #8]
     9f0:	781b      	ldrb	r3, [r3, #0]
     9f2:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
    sFormat++;
     9f6:	68bb      	ldr	r3, [r7, #8]
     9f8:	3301      	adds	r3, #1
     9fa:	60bb      	str	r3, [r7, #8]
    if (c == 0u) {
     9fc:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
     a00:	2b00      	cmp	r3, #0
     a02:	f000 819f 	beq.w	d44 <SEGGER_RTT_vprintf+0x378>
      break;
    }
    if (c == '%') {
     a06:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
     a0a:	2b25      	cmp	r3, #37	; 0x25
     a0c:	f040 818d 	bne.w	d2a <SEGGER_RTT_vprintf+0x35e>
      //
      // Filter out flags
      //
      FormatFlags = 0u;
     a10:	2300      	movs	r3, #0
     a12:	673b      	str	r3, [r7, #112]	; 0x70
      v = 1;
     a14:	2301      	movs	r3, #1
     a16:	67bb      	str	r3, [r7, #120]	; 0x78
      do {
        c = *sFormat;
     a18:	68bb      	ldr	r3, [r7, #8]
     a1a:	781b      	ldrb	r3, [r3, #0]
     a1c:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
        switch (c) {
     a20:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
     a24:	3b23      	subs	r3, #35	; 0x23
     a26:	2b0d      	cmp	r3, #13
     a28:	d83e      	bhi.n	aa8 <SEGGER_RTT_vprintf+0xdc>
     a2a:	a201      	add	r2, pc, #4	; (adr r2, a30 <SEGGER_RTT_vprintf+0x64>)
     a2c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     a30:	00000a99 	.word	0x00000a99
     a34:	00000aa9 	.word	0x00000aa9
     a38:	00000aa9 	.word	0x00000aa9
     a3c:	00000aa9 	.word	0x00000aa9
     a40:	00000aa9 	.word	0x00000aa9
     a44:	00000aa9 	.word	0x00000aa9
     a48:	00000aa9 	.word	0x00000aa9
     a4c:	00000aa9 	.word	0x00000aa9
     a50:	00000a89 	.word	0x00000a89
     a54:	00000aa9 	.word	0x00000aa9
     a58:	00000a69 	.word	0x00000a69
     a5c:	00000aa9 	.word	0x00000aa9
     a60:	00000aa9 	.word	0x00000aa9
     a64:	00000a79 	.word	0x00000a79
        case '-': FormatFlags |= FORMAT_FLAG_LEFT_JUSTIFY; sFormat++; break;
     a68:	6f3b      	ldr	r3, [r7, #112]	; 0x70
     a6a:	f043 0301 	orr.w	r3, r3, #1
     a6e:	673b      	str	r3, [r7, #112]	; 0x70
     a70:	68bb      	ldr	r3, [r7, #8]
     a72:	3301      	adds	r3, #1
     a74:	60bb      	str	r3, [r7, #8]
     a76:	e01a      	b.n	aae <SEGGER_RTT_vprintf+0xe2>
        case '0': FormatFlags |= FORMAT_FLAG_PAD_ZERO;     sFormat++; break;
     a78:	6f3b      	ldr	r3, [r7, #112]	; 0x70
     a7a:	f043 0302 	orr.w	r3, r3, #2
     a7e:	673b      	str	r3, [r7, #112]	; 0x70
     a80:	68bb      	ldr	r3, [r7, #8]
     a82:	3301      	adds	r3, #1
     a84:	60bb      	str	r3, [r7, #8]
     a86:	e012      	b.n	aae <SEGGER_RTT_vprintf+0xe2>
        case '+': FormatFlags |= FORMAT_FLAG_PRINT_SIGN;   sFormat++; break;
     a88:	6f3b      	ldr	r3, [r7, #112]	; 0x70
     a8a:	f043 0304 	orr.w	r3, r3, #4
     a8e:	673b      	str	r3, [r7, #112]	; 0x70
     a90:	68bb      	ldr	r3, [r7, #8]
     a92:	3301      	adds	r3, #1
     a94:	60bb      	str	r3, [r7, #8]
     a96:	e00a      	b.n	aae <SEGGER_RTT_vprintf+0xe2>
        case '#': FormatFlags |= FORMAT_FLAG_ALTERNATE;    sFormat++; break;
     a98:	6f3b      	ldr	r3, [r7, #112]	; 0x70
     a9a:	f043 0308 	orr.w	r3, r3, #8
     a9e:	673b      	str	r3, [r7, #112]	; 0x70
     aa0:	68bb      	ldr	r3, [r7, #8]
     aa2:	3301      	adds	r3, #1
     aa4:	60bb      	str	r3, [r7, #8]
     aa6:	e002      	b.n	aae <SEGGER_RTT_vprintf+0xe2>
        default:  v = 0; break;
     aa8:	2300      	movs	r3, #0
     aaa:	67bb      	str	r3, [r7, #120]	; 0x78
     aac:	bf00      	nop
        }
      } while (v);
     aae:	6fbb      	ldr	r3, [r7, #120]	; 0x78
     ab0:	2b00      	cmp	r3, #0
     ab2:	d1b1      	bne.n	a18 <SEGGER_RTT_vprintf+0x4c>
      //
      // filter out field with
      //
      FieldWidth = 0u;
     ab4:	2300      	movs	r3, #0
     ab6:	66fb      	str	r3, [r7, #108]	; 0x6c
      do {
        c = *sFormat;
     ab8:	68bb      	ldr	r3, [r7, #8]
     aba:	781b      	ldrb	r3, [r3, #0]
     abc:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
        if ((c < '0') || (c > '9')) {
     ac0:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
     ac4:	2b2f      	cmp	r3, #47	; 0x2f
     ac6:	d912      	bls.n	aee <SEGGER_RTT_vprintf+0x122>
     ac8:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
     acc:	2b39      	cmp	r3, #57	; 0x39
     ace:	d80e      	bhi.n	aee <SEGGER_RTT_vprintf+0x122>
          break;
        }
        sFormat++;
     ad0:	68bb      	ldr	r3, [r7, #8]
     ad2:	3301      	adds	r3, #1
     ad4:	60bb      	str	r3, [r7, #8]
        FieldWidth = (FieldWidth * 10u) + ((unsigned)c - '0');
     ad6:	6efa      	ldr	r2, [r7, #108]	; 0x6c
     ad8:	4613      	mov	r3, r2
     ada:	009b      	lsls	r3, r3, #2
     adc:	4413      	add	r3, r2
     ade:	005b      	lsls	r3, r3, #1
     ae0:	461a      	mov	r2, r3
     ae2:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
     ae6:	4413      	add	r3, r2
     ae8:	3b30      	subs	r3, #48	; 0x30
     aea:	66fb      	str	r3, [r7, #108]	; 0x6c
        c = *sFormat;
     aec:	e7e4      	b.n	ab8 <SEGGER_RTT_vprintf+0xec>
      } while (1);

      //
      // Filter out precision (number of digits to display)
      //
      NumDigits = 0u;
     aee:	2300      	movs	r3, #0
     af0:	677b      	str	r3, [r7, #116]	; 0x74
      c = *sFormat;
     af2:	68bb      	ldr	r3, [r7, #8]
     af4:	781b      	ldrb	r3, [r3, #0]
     af6:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
      if (c == '.') {
     afa:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
     afe:	2b2e      	cmp	r3, #46	; 0x2e
     b00:	d11d      	bne.n	b3e <SEGGER_RTT_vprintf+0x172>
        sFormat++;
     b02:	68bb      	ldr	r3, [r7, #8]
     b04:	3301      	adds	r3, #1
     b06:	60bb      	str	r3, [r7, #8]
        do {
          c = *sFormat;
     b08:	68bb      	ldr	r3, [r7, #8]
     b0a:	781b      	ldrb	r3, [r3, #0]
     b0c:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
          if ((c < '0') || (c > '9')) {
     b10:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
     b14:	2b2f      	cmp	r3, #47	; 0x2f
     b16:	d912      	bls.n	b3e <SEGGER_RTT_vprintf+0x172>
     b18:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
     b1c:	2b39      	cmp	r3, #57	; 0x39
     b1e:	d80e      	bhi.n	b3e <SEGGER_RTT_vprintf+0x172>
            break;
          }
          sFormat++;
     b20:	68bb      	ldr	r3, [r7, #8]
     b22:	3301      	adds	r3, #1
     b24:	60bb      	str	r3, [r7, #8]
          NumDigits = NumDigits * 10u + ((unsigned)c - '0');
     b26:	6f7a      	ldr	r2, [r7, #116]	; 0x74
     b28:	4613      	mov	r3, r2
     b2a:	009b      	lsls	r3, r3, #2
     b2c:	4413      	add	r3, r2
     b2e:	005b      	lsls	r3, r3, #1
     b30:	461a      	mov	r2, r3
     b32:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
     b36:	4413      	add	r3, r2
     b38:	3b30      	subs	r3, #48	; 0x30
     b3a:	677b      	str	r3, [r7, #116]	; 0x74
          c = *sFormat;
     b3c:	e7e4      	b.n	b08 <SEGGER_RTT_vprintf+0x13c>
        } while (1);
      }
      //
      // Filter out length modifier
      //
      c = *sFormat;
     b3e:	68bb      	ldr	r3, [r7, #8]
     b40:	781b      	ldrb	r3, [r3, #0]
     b42:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
      do {
        if ((c == 'l') || (c == 'h')) {
     b46:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
     b4a:	2b6c      	cmp	r3, #108	; 0x6c
     b4c:	d003      	beq.n	b56 <SEGGER_RTT_vprintf+0x18a>
     b4e:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
     b52:	2b68      	cmp	r3, #104	; 0x68
     b54:	d107      	bne.n	b66 <SEGGER_RTT_vprintf+0x19a>
          sFormat++;
     b56:	68bb      	ldr	r3, [r7, #8]
     b58:	3301      	adds	r3, #1
     b5a:	60bb      	str	r3, [r7, #8]
          c = *sFormat;
     b5c:	68bb      	ldr	r3, [r7, #8]
     b5e:	781b      	ldrb	r3, [r3, #0]
     b60:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
        if ((c == 'l') || (c == 'h')) {
     b64:	e7ef      	b.n	b46 <SEGGER_RTT_vprintf+0x17a>
        }
      } while (1);
      //
      // Handle specifiers
      //
      switch (c) {
     b66:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
     b6a:	2b25      	cmp	r3, #37	; 0x25
     b6c:	f000 80d1 	beq.w	d12 <SEGGER_RTT_vprintf+0x346>
     b70:	2b25      	cmp	r3, #37	; 0x25
     b72:	f2c0 80d5 	blt.w	d20 <SEGGER_RTT_vprintf+0x354>
     b76:	2b78      	cmp	r3, #120	; 0x78
     b78:	f300 80d2 	bgt.w	d20 <SEGGER_RTT_vprintf+0x354>
     b7c:	2b58      	cmp	r3, #88	; 0x58
     b7e:	f2c0 80cf 	blt.w	d20 <SEGGER_RTT_vprintf+0x354>
     b82:	3b58      	subs	r3, #88	; 0x58
     b84:	2b20      	cmp	r3, #32
     b86:	f200 80cb 	bhi.w	d20 <SEGGER_RTT_vprintf+0x354>
     b8a:	a201      	add	r2, pc, #4	; (adr r2, b90 <SEGGER_RTT_vprintf+0x1c4>)
     b8c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     b90:	00000c87 	.word	0x00000c87
     b94:	00000d21 	.word	0x00000d21
     b98:	00000d21 	.word	0x00000d21
     b9c:	00000d21 	.word	0x00000d21
     ba0:	00000d21 	.word	0x00000d21
     ba4:	00000d21 	.word	0x00000d21
     ba8:	00000d21 	.word	0x00000d21
     bac:	00000d21 	.word	0x00000d21
     bb0:	00000d21 	.word	0x00000d21
     bb4:	00000d21 	.word	0x00000d21
     bb8:	00000d21 	.word	0x00000d21
     bbc:	00000c15 	.word	0x00000c15
     bc0:	00000c3b 	.word	0x00000c3b
     bc4:	00000d21 	.word	0x00000d21
     bc8:	00000d21 	.word	0x00000d21
     bcc:	00000d21 	.word	0x00000d21
     bd0:	00000d21 	.word	0x00000d21
     bd4:	00000d21 	.word	0x00000d21
     bd8:	00000d21 	.word	0x00000d21
     bdc:	00000d21 	.word	0x00000d21
     be0:	00000d21 	.word	0x00000d21
     be4:	00000d21 	.word	0x00000d21
     be8:	00000d21 	.word	0x00000d21
     bec:	00000d21 	.word	0x00000d21
     bf0:	00000ced 	.word	0x00000ced
     bf4:	00000d21 	.word	0x00000d21
     bf8:	00000d21 	.word	0x00000d21
     bfc:	00000cad 	.word	0x00000cad
     c00:	00000d21 	.word	0x00000d21
     c04:	00000c61 	.word	0x00000c61
     c08:	00000d21 	.word	0x00000d21
     c0c:	00000d21 	.word	0x00000d21
     c10:	00000c87 	.word	0x00000c87
      case 'c': {
        char c0;
        v = va_arg(*pParamList, int);
     c14:	687b      	ldr	r3, [r7, #4]
     c16:	681b      	ldr	r3, [r3, #0]
     c18:	1d19      	adds	r1, r3, #4
     c1a:	687a      	ldr	r2, [r7, #4]
     c1c:	6011      	str	r1, [r2, #0]
     c1e:	681b      	ldr	r3, [r3, #0]
     c20:	67bb      	str	r3, [r7, #120]	; 0x78
        c0 = (char)v;
     c22:	6fbb      	ldr	r3, [r7, #120]	; 0x78
     c24:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67
        _StoreChar(&BufferDesc, c0);
     c28:	f897 2067 	ldrb.w	r2, [r7, #103]	; 0x67
     c2c:	f107 0350 	add.w	r3, r7, #80	; 0x50
     c30:	4611      	mov	r1, r2
     c32:	4618      	mov	r0, r3
     c34:	4b4f      	ldr	r3, [pc, #316]	; (d74 <SEGGER_RTT_vprintf+0x3a8>)
     c36:	4798      	blx	r3
        break;
     c38:	e073      	b.n	d22 <SEGGER_RTT_vprintf+0x356>
      }
      case 'd':
        v = va_arg(*pParamList, int);
     c3a:	687b      	ldr	r3, [r7, #4]
     c3c:	681b      	ldr	r3, [r3, #0]
     c3e:	1d19      	adds	r1, r3, #4
     c40:	687a      	ldr	r2, [r7, #4]
     c42:	6011      	str	r1, [r2, #0]
     c44:	681b      	ldr	r3, [r3, #0]
     c46:	67bb      	str	r3, [r7, #120]	; 0x78
        _PrintInt(&BufferDesc, v, 10u, NumDigits, FieldWidth, FormatFlags);
     c48:	f107 0050 	add.w	r0, r7, #80	; 0x50
     c4c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
     c4e:	9301      	str	r3, [sp, #4]
     c50:	6efb      	ldr	r3, [r7, #108]	; 0x6c
     c52:	9300      	str	r3, [sp, #0]
     c54:	6f7b      	ldr	r3, [r7, #116]	; 0x74
     c56:	220a      	movs	r2, #10
     c58:	6fb9      	ldr	r1, [r7, #120]	; 0x78
     c5a:	4c47      	ldr	r4, [pc, #284]	; (d78 <SEGGER_RTT_vprintf+0x3ac>)
     c5c:	47a0      	blx	r4
        break;
     c5e:	e060      	b.n	d22 <SEGGER_RTT_vprintf+0x356>
      case 'u':
        v = va_arg(*pParamList, int);
     c60:	687b      	ldr	r3, [r7, #4]
     c62:	681b      	ldr	r3, [r3, #0]
     c64:	1d19      	adds	r1, r3, #4
     c66:	687a      	ldr	r2, [r7, #4]
     c68:	6011      	str	r1, [r2, #0]
     c6a:	681b      	ldr	r3, [r3, #0]
     c6c:	67bb      	str	r3, [r7, #120]	; 0x78
        _PrintUnsigned(&BufferDesc, (unsigned)v, 10u, NumDigits, FieldWidth, FormatFlags);
     c6e:	6fb9      	ldr	r1, [r7, #120]	; 0x78
     c70:	f107 0050 	add.w	r0, r7, #80	; 0x50
     c74:	6f3b      	ldr	r3, [r7, #112]	; 0x70
     c76:	9301      	str	r3, [sp, #4]
     c78:	6efb      	ldr	r3, [r7, #108]	; 0x6c
     c7a:	9300      	str	r3, [sp, #0]
     c7c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
     c7e:	220a      	movs	r2, #10
     c80:	4c3e      	ldr	r4, [pc, #248]	; (d7c <SEGGER_RTT_vprintf+0x3b0>)
     c82:	47a0      	blx	r4
        break;
     c84:	e04d      	b.n	d22 <SEGGER_RTT_vprintf+0x356>
      case 'x':
      case 'X':
        v = va_arg(*pParamList, int);
     c86:	687b      	ldr	r3, [r7, #4]
     c88:	681b      	ldr	r3, [r3, #0]
     c8a:	1d19      	adds	r1, r3, #4
     c8c:	687a      	ldr	r2, [r7, #4]
     c8e:	6011      	str	r1, [r2, #0]
     c90:	681b      	ldr	r3, [r3, #0]
     c92:	67bb      	str	r3, [r7, #120]	; 0x78
        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, NumDigits, FieldWidth, FormatFlags);
     c94:	6fb9      	ldr	r1, [r7, #120]	; 0x78
     c96:	f107 0050 	add.w	r0, r7, #80	; 0x50
     c9a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
     c9c:	9301      	str	r3, [sp, #4]
     c9e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
     ca0:	9300      	str	r3, [sp, #0]
     ca2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
     ca4:	2210      	movs	r2, #16
     ca6:	4c35      	ldr	r4, [pc, #212]	; (d7c <SEGGER_RTT_vprintf+0x3b0>)
     ca8:	47a0      	blx	r4
        break;
     caa:	e03a      	b.n	d22 <SEGGER_RTT_vprintf+0x356>
      case 's':
        {
          const char * s = va_arg(*pParamList, const char *);
     cac:	687b      	ldr	r3, [r7, #4]
     cae:	681b      	ldr	r3, [r3, #0]
     cb0:	1d19      	adds	r1, r3, #4
     cb2:	687a      	ldr	r2, [r7, #4]
     cb4:	6011      	str	r1, [r2, #0]
     cb6:	681b      	ldr	r3, [r3, #0]
     cb8:	66bb      	str	r3, [r7, #104]	; 0x68
          do {
            c = *s;
     cba:	6ebb      	ldr	r3, [r7, #104]	; 0x68
     cbc:	781b      	ldrb	r3, [r3, #0]
     cbe:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
            s++;
     cc2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
     cc4:	3301      	adds	r3, #1
     cc6:	66bb      	str	r3, [r7, #104]	; 0x68
            if (c == '\0') {
     cc8:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
     ccc:	2b00      	cmp	r3, #0
     cce:	d00b      	beq.n	ce8 <SEGGER_RTT_vprintf+0x31c>
              break;
            }
           _StoreChar(&BufferDesc, c);
     cd0:	f897 207f 	ldrb.w	r2, [r7, #127]	; 0x7f
     cd4:	f107 0350 	add.w	r3, r7, #80	; 0x50
     cd8:	4611      	mov	r1, r2
     cda:	4618      	mov	r0, r3
     cdc:	4b25      	ldr	r3, [pc, #148]	; (d74 <SEGGER_RTT_vprintf+0x3a8>)
     cde:	4798      	blx	r3
          } while (BufferDesc.ReturnValue >= 0);
     ce0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     ce2:	2b00      	cmp	r3, #0
     ce4:	dae9      	bge.n	cba <SEGGER_RTT_vprintf+0x2ee>
        }
        break;
     ce6:	e01c      	b.n	d22 <SEGGER_RTT_vprintf+0x356>
              break;
     ce8:	bf00      	nop
        break;
     cea:	e01a      	b.n	d22 <SEGGER_RTT_vprintf+0x356>
      case 'p':
        v = va_arg(*pParamList, int);
     cec:	687b      	ldr	r3, [r7, #4]
     cee:	681b      	ldr	r3, [r3, #0]
     cf0:	1d19      	adds	r1, r3, #4
     cf2:	687a      	ldr	r2, [r7, #4]
     cf4:	6011      	str	r1, [r2, #0]
     cf6:	681b      	ldr	r3, [r3, #0]
     cf8:	67bb      	str	r3, [r7, #120]	; 0x78
        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, 8u, 8u, 0u);
     cfa:	6fb9      	ldr	r1, [r7, #120]	; 0x78
     cfc:	f107 0050 	add.w	r0, r7, #80	; 0x50
     d00:	2300      	movs	r3, #0
     d02:	9301      	str	r3, [sp, #4]
     d04:	2308      	movs	r3, #8
     d06:	9300      	str	r3, [sp, #0]
     d08:	2308      	movs	r3, #8
     d0a:	2210      	movs	r2, #16
     d0c:	4c1b      	ldr	r4, [pc, #108]	; (d7c <SEGGER_RTT_vprintf+0x3b0>)
     d0e:	47a0      	blx	r4
        break;
     d10:	e007      	b.n	d22 <SEGGER_RTT_vprintf+0x356>
      case '%':
        _StoreChar(&BufferDesc, '%');
     d12:	f107 0350 	add.w	r3, r7, #80	; 0x50
     d16:	2125      	movs	r1, #37	; 0x25
     d18:	4618      	mov	r0, r3
     d1a:	4b16      	ldr	r3, [pc, #88]	; (d74 <SEGGER_RTT_vprintf+0x3a8>)
     d1c:	4798      	blx	r3
        break;
     d1e:	e000      	b.n	d22 <SEGGER_RTT_vprintf+0x356>
      default:
        break;
     d20:	bf00      	nop
      }
      sFormat++;
     d22:	68bb      	ldr	r3, [r7, #8]
     d24:	3301      	adds	r3, #1
     d26:	60bb      	str	r3, [r7, #8]
     d28:	e007      	b.n	d3a <SEGGER_RTT_vprintf+0x36e>
    } else {
      _StoreChar(&BufferDesc, c);
     d2a:	f897 207f 	ldrb.w	r2, [r7, #127]	; 0x7f
     d2e:	f107 0350 	add.w	r3, r7, #80	; 0x50
     d32:	4611      	mov	r1, r2
     d34:	4618      	mov	r0, r3
     d36:	4b0f      	ldr	r3, [pc, #60]	; (d74 <SEGGER_RTT_vprintf+0x3a8>)
     d38:	4798      	blx	r3
    }
  } while (BufferDesc.ReturnValue >= 0);
     d3a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     d3c:	2b00      	cmp	r3, #0
     d3e:	f6bf ae56 	bge.w	9ee <SEGGER_RTT_vprintf+0x22>
     d42:	e000      	b.n	d46 <SEGGER_RTT_vprintf+0x37a>
      break;
     d44:	bf00      	nop

  if (BufferDesc.ReturnValue > 0) {
     d46:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     d48:	2b00      	cmp	r3, #0
     d4a:	dd0d      	ble.n	d68 <SEGGER_RTT_vprintf+0x39c>
    //
    // Write remaining data, if any
    //
    if (BufferDesc.Cnt != 0u) {
     d4c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
     d4e:	2b00      	cmp	r3, #0
     d50:	d006      	beq.n	d60 <SEGGER_RTT_vprintf+0x394>
      SEGGER_RTT_Write(BufferIndex, acBuffer, BufferDesc.Cnt);
     d52:	6dba      	ldr	r2, [r7, #88]	; 0x58
     d54:	f107 0310 	add.w	r3, r7, #16
     d58:	4619      	mov	r1, r3
     d5a:	68f8      	ldr	r0, [r7, #12]
     d5c:	4b08      	ldr	r3, [pc, #32]	; (d80 <SEGGER_RTT_vprintf+0x3b4>)
     d5e:	4798      	blx	r3
    }
    BufferDesc.ReturnValue += (int)BufferDesc.Cnt;
     d60:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     d62:	6dba      	ldr	r2, [r7, #88]	; 0x58
     d64:	4413      	add	r3, r2
     d66:	65fb      	str	r3, [r7, #92]	; 0x5c
  }
  return BufferDesc.ReturnValue;
     d68:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
}
     d6a:	4618      	mov	r0, r3
     d6c:	3784      	adds	r7, #132	; 0x84
     d6e:	46bd      	mov	sp, r7
     d70:	bd90      	pop	{r4, r7, pc}
     d72:	bf00      	nop
     d74:	00000699 	.word	0x00000699
     d78:	00000875 	.word	0x00000875
     d7c:	00000719 	.word	0x00000719
     d80:	00000645 	.word	0x00000645

00000d84 <SEGGER_RTT_printf>:
*          u: Print the argument as an unsigned integer
*          x: Print the argument as an hexadecimal integer
*          s: Print the string pointed to by the argument
*          p: Print the argument as an 8-digit hexadecimal integer. (Argument shall be a pointer to void.)
*/
int SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...) {
     d84:	b40e      	push	{r1, r2, r3}
     d86:	b580      	push	{r7, lr}
     d88:	b085      	sub	sp, #20
     d8a:	af00      	add	r7, sp, #0
     d8c:	6078      	str	r0, [r7, #4]
  int r;
  va_list ParamList;

  va_start(ParamList, sFormat);
     d8e:	f107 0320 	add.w	r3, r7, #32
     d92:	60bb      	str	r3, [r7, #8]
  r = SEGGER_RTT_vprintf(BufferIndex, sFormat, &ParamList);
     d94:	f107 0308 	add.w	r3, r7, #8
     d98:	461a      	mov	r2, r3
     d9a:	69f9      	ldr	r1, [r7, #28]
     d9c:	6878      	ldr	r0, [r7, #4]
     d9e:	4b05      	ldr	r3, [pc, #20]	; (db4 <SEGGER_RTT_printf+0x30>)
     da0:	4798      	blx	r3
     da2:	60f8      	str	r0, [r7, #12]
  va_end(ParamList);
  return r;
     da4:	68fb      	ldr	r3, [r7, #12]
}
     da6:	4618      	mov	r0, r3
     da8:	3714      	adds	r7, #20
     daa:	46bd      	mov	sp, r7
     dac:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
     db0:	b003      	add	sp, #12
     db2:	4770      	bx	lr
     db4:	000009cd 	.word	0x000009cd

00000db8 <hri_port_read_DIR_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_port_dir_reg_t hri_port_read_DIR_reg(const void *const hw, uint8_t submodule_index)
{
     db8:	b480      	push	{r7}
     dba:	b083      	sub	sp, #12
     dbc:	af00      	add	r7, sp, #0
     dbe:	6078      	str	r0, [r7, #4]
     dc0:	460b      	mov	r3, r1
     dc2:	70fb      	strb	r3, [r7, #3]
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
     dc4:	78fb      	ldrb	r3, [r7, #3]
     dc6:	687a      	ldr	r2, [r7, #4]
     dc8:	01db      	lsls	r3, r3, #7
     dca:	4413      	add	r3, r2
     dcc:	681b      	ldr	r3, [r3, #0]
}
     dce:	4618      	mov	r0, r3
     dd0:	370c      	adds	r7, #12
     dd2:	46bd      	mov	sp, r7
     dd4:	f85d 7b04 	ldr.w	r7, [sp], #4
     dd8:	4770      	bx	lr

00000dda <hri_port_read_OUT_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_port_out_reg_t hri_port_read_OUT_reg(const void *const hw, uint8_t submodule_index)
{
     dda:	b480      	push	{r7}
     ddc:	b083      	sub	sp, #12
     dde:	af00      	add	r7, sp, #0
     de0:	6078      	str	r0, [r7, #4]
     de2:	460b      	mov	r3, r1
     de4:	70fb      	strb	r3, [r7, #3]
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
     de6:	78fb      	ldrb	r3, [r7, #3]
     de8:	687a      	ldr	r2, [r7, #4]
     dea:	01db      	lsls	r3, r3, #7
     dec:	4413      	add	r3, r2
     dee:	3310      	adds	r3, #16
     df0:	681b      	ldr	r3, [r3, #0]
}
     df2:	4618      	mov	r0, r3
     df4:	370c      	adds	r7, #12
     df6:	46bd      	mov	sp, r7
     df8:	f85d 7b04 	ldr.w	r7, [sp], #4
     dfc:	4770      	bx	lr

00000dfe <hri_port_read_IN_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_port_in_reg_t hri_port_read_IN_reg(const void *const hw, uint8_t submodule_index)
{
     dfe:	b480      	push	{r7}
     e00:	b083      	sub	sp, #12
     e02:	af00      	add	r7, sp, #0
     e04:	6078      	str	r0, [r7, #4]
     e06:	460b      	mov	r3, r1
     e08:	70fb      	strb	r3, [r7, #3]
	return ((Port *)hw)->Group[submodule_index].IN.reg;
     e0a:	78fb      	ldrb	r3, [r7, #3]
     e0c:	687a      	ldr	r2, [r7, #4]
     e0e:	01db      	lsls	r3, r3, #7
     e10:	4413      	add	r3, r2
     e12:	3320      	adds	r3, #32
     e14:	681b      	ldr	r3, [r3, #0]
}
     e16:	4618      	mov	r0, r3
     e18:	370c      	adds	r7, #12
     e1a:	46bd      	mov	sp, r7
     e1c:	f85d 7b04 	ldr.w	r7, [sp], #4
     e20:	4770      	bx	lr
	...

00000e24 <_gpio_get_level>:

/**
 * \brief Get input levels on all port pins
 */
static inline uint32_t _gpio_get_level(const enum gpio_port port)
{
     e24:	b580      	push	{r7, lr}
     e26:	b086      	sub	sp, #24
     e28:	af00      	add	r7, sp, #0
     e2a:	4603      	mov	r3, r0
     e2c:	71fb      	strb	r3, [r7, #7]
	uint32_t tmp;

	CRITICAL_SECTION_ENTER();
     e2e:	f107 030c 	add.w	r3, r7, #12
     e32:	4618      	mov	r0, r3
     e34:	4b13      	ldr	r3, [pc, #76]	; (e84 <_gpio_get_level+0x60>)
     e36:	4798      	blx	r3

	uint32_t dir_tmp = hri_port_read_DIR_reg(PORT, port);
     e38:	79fb      	ldrb	r3, [r7, #7]
     e3a:	4619      	mov	r1, r3
     e3c:	4812      	ldr	r0, [pc, #72]	; (e88 <_gpio_get_level+0x64>)
     e3e:	4b13      	ldr	r3, [pc, #76]	; (e8c <_gpio_get_level+0x68>)
     e40:	4798      	blx	r3
     e42:	6178      	str	r0, [r7, #20]

	tmp = hri_port_read_IN_reg(PORT, port) & ~dir_tmp;
     e44:	79fb      	ldrb	r3, [r7, #7]
     e46:	4619      	mov	r1, r3
     e48:	480f      	ldr	r0, [pc, #60]	; (e88 <_gpio_get_level+0x64>)
     e4a:	4b11      	ldr	r3, [pc, #68]	; (e90 <_gpio_get_level+0x6c>)
     e4c:	4798      	blx	r3
     e4e:	4602      	mov	r2, r0
     e50:	697b      	ldr	r3, [r7, #20]
     e52:	43db      	mvns	r3, r3
     e54:	4013      	ands	r3, r2
     e56:	613b      	str	r3, [r7, #16]
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
     e58:	79fb      	ldrb	r3, [r7, #7]
     e5a:	4619      	mov	r1, r3
     e5c:	480a      	ldr	r0, [pc, #40]	; (e88 <_gpio_get_level+0x64>)
     e5e:	4b0d      	ldr	r3, [pc, #52]	; (e94 <_gpio_get_level+0x70>)
     e60:	4798      	blx	r3
     e62:	4602      	mov	r2, r0
     e64:	697b      	ldr	r3, [r7, #20]
     e66:	4013      	ands	r3, r2
     e68:	693a      	ldr	r2, [r7, #16]
     e6a:	4313      	orrs	r3, r2
     e6c:	613b      	str	r3, [r7, #16]

	CRITICAL_SECTION_LEAVE();
     e6e:	f107 030c 	add.w	r3, r7, #12
     e72:	4618      	mov	r0, r3
     e74:	4b08      	ldr	r3, [pc, #32]	; (e98 <_gpio_get_level+0x74>)
     e76:	4798      	blx	r3

	return tmp;
     e78:	693b      	ldr	r3, [r7, #16]
}
     e7a:	4618      	mov	r0, r3
     e7c:	3718      	adds	r7, #24
     e7e:	46bd      	mov	sp, r7
     e80:	bd80      	pop	{r7, pc}
     e82:	bf00      	nop
     e84:	00004989 	.word	0x00004989
     e88:	41008000 	.word	0x41008000
     e8c:	00000db9 	.word	0x00000db9
     e90:	00000dff 	.word	0x00000dff
     e94:	00000ddb 	.word	0x00000ddb
     e98:	000049b3 	.word	0x000049b3

00000e9c <gpio_get_pin_level>:
 * Reads the level on pins connected to a port
 *
 * \param[in] pin       The pin number for device
 */
static inline bool gpio_get_pin_level(const uint8_t pin)
{
     e9c:	b580      	push	{r7, lr}
     e9e:	b082      	sub	sp, #8
     ea0:	af00      	add	r7, sp, #0
     ea2:	4603      	mov	r3, r0
     ea4:	71fb      	strb	r3, [r7, #7]
	return (bool)(_gpio_get_level((enum gpio_port)GPIO_PORT(pin)) & (0x01U << GPIO_PIN(pin)));
     ea6:	79fb      	ldrb	r3, [r7, #7]
     ea8:	095b      	lsrs	r3, r3, #5
     eaa:	b2db      	uxtb	r3, r3
     eac:	4618      	mov	r0, r3
     eae:	4b09      	ldr	r3, [pc, #36]	; (ed4 <gpio_get_pin_level+0x38>)
     eb0:	4798      	blx	r3
     eb2:	4602      	mov	r2, r0
     eb4:	79fb      	ldrb	r3, [r7, #7]
     eb6:	f003 031f 	and.w	r3, r3, #31
     eba:	2101      	movs	r1, #1
     ebc:	fa01 f303 	lsl.w	r3, r1, r3
     ec0:	4013      	ands	r3, r2
     ec2:	2b00      	cmp	r3, #0
     ec4:	bf14      	ite	ne
     ec6:	2301      	movne	r3, #1
     ec8:	2300      	moveq	r3, #0
     eca:	b2db      	uxtb	r3, r3
}
     ecc:	4618      	mov	r0, r3
     ece:	3708      	adds	r7, #8
     ed0:	46bd      	mov	sp, r7
     ed2:	bd80      	pop	{r7, pc}
     ed4:	00000e25 	.word	0x00000e25

00000ed8 <init_rm3100>:
int32_t RM3100ReadReg(uint8_t addr, uint8_t *val);
int32_t RM3100WriteReg(uint8_t addr, uint8_t data);

//https://github.com/inventorandy/atmel-samd21/blob/master/07_I2CTSYS/07_I2CTSYS/ext_tsys01.h#L15

int init_rm3100(void) {
     ed8:	b580      	push	{r7, lr}
     eda:	b082      	sub	sp, #8
     edc:	af00      	add	r7, sp, #0
    //Initialize the I2C Communications
    i2c_m_sync_get_io_descriptor(&I2C_0, &rm3100_io);
     ede:	4915      	ldr	r1, [pc, #84]	; (f34 <init_rm3100+0x5c>)
     ee0:	4815      	ldr	r0, [pc, #84]	; (f38 <init_rm3100+0x60>)
     ee2:	4b16      	ldr	r3, [pc, #88]	; (f3c <init_rm3100+0x64>)
     ee4:	4798      	blx	r3
    i2c_m_sync_enable(&I2C_0);
     ee6:	4814      	ldr	r0, [pc, #80]	; (f38 <init_rm3100+0x60>)
     ee8:	4b15      	ldr	r3, [pc, #84]	; (f40 <init_rm3100+0x68>)
     eea:	4798      	blx	r3
    i2c_m_sync_set_slaveaddr(&I2C_0, RM3100Address, I2C_M_TEN);
     eec:	f44f 6280 	mov.w	r2, #1024	; 0x400
     ef0:	2120      	movs	r1, #32
     ef2:	4811      	ldr	r0, [pc, #68]	; (f38 <init_rm3100+0x60>)
     ef4:	4b13      	ldr	r3, [pc, #76]	; (f44 <init_rm3100+0x6c>)
     ef6:	4798      	blx	r3

    //TODO Check REVID
    uint8_t revid;
    uint32_t error = RM3100ReadReg(RM3100_REVID_REG, &revid);
     ef8:	1cfb      	adds	r3, r7, #3
     efa:	4619      	mov	r1, r3
     efc:	2036      	movs	r0, #54	; 0x36
     efe:	4b12      	ldr	r3, [pc, #72]	; (f48 <init_rm3100+0x70>)
     f00:	4798      	blx	r3
     f02:	4603      	mov	r3, r0
     f04:	607b      	str	r3, [r7, #4]
    if (revid != 0x22) {
     f06:	78fb      	ldrb	r3, [r7, #3]
     f08:	2b22      	cmp	r3, #34	; 0x22
     f0a:	d007      	beq.n	f1c <init_rm3100+0x44>
        printf("RM3100 not detected correctly! Errored with code: %ld\n", error);
     f0c:	687a      	ldr	r2, [r7, #4]
     f0e:	490f      	ldr	r1, [pc, #60]	; (f4c <init_rm3100+0x74>)
     f10:	2000      	movs	r0, #0
     f12:	4b0f      	ldr	r3, [pc, #60]	; (f50 <init_rm3100+0x78>)
     f14:	4798      	blx	r3
        return -1;
     f16:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
     f1a:	e007      	b.n	f2c <init_rm3100+0x54>
    }

    changeCycleCount(initialCC);
     f1c:	20c8      	movs	r0, #200	; 0xc8
     f1e:	4b0d      	ldr	r3, [pc, #52]	; (f54 <init_rm3100+0x7c>)
     f20:	4798      	blx	r3

    if (singleMode) {
        RM3100WriteReg(RM3100_CMM_REG, 0);
        RM3100WriteReg(RM3100_POLL_REG, 0x70);
    } else {
        RM3100WriteReg(RM3100_CMM_REG, 0x79);
     f22:	2179      	movs	r1, #121	; 0x79
     f24:	2001      	movs	r0, #1
     f26:	4b0c      	ldr	r3, [pc, #48]	; (f58 <init_rm3100+0x80>)
     f28:	4798      	blx	r3
    }
    return 0;
     f2a:	2300      	movs	r3, #0
}
     f2c:	4618      	mov	r0, r3
     f2e:	3708      	adds	r7, #8
     f30:	46bd      	mov	sp, r7
     f32:	bd80      	pop	{r7, pc}
     f34:	20000508 	.word	0x20000508
     f38:	20000550 	.word	0x20000550
     f3c:	00001a4f 	.word	0x00001a4f
     f40:	000019f5 	.word	0x000019f5
     f44:	00001a15 	.word	0x00001a15
     f48:	00001101 	.word	0x00001101
     f4c:	000054ec 	.word	0x000054ec
     f50:	00000d85 	.word	0x00000d85
     f54:	00001075 	.word	0x00001075
     f58:	00001175 	.word	0x00001175

00000f5c <values_loop>:

RM3100_return_t values_loop(void) {
     f5c:	b590      	push	{r4, r7, lr}
     f5e:	b089      	sub	sp, #36	; 0x24
     f60:	af00      	add	r7, sp, #0
     f62:	6078      	str	r0, [r7, #4]
    RM3100_return_t returnVals;

    if (useDRDYPin) {
        while(gpio_get_pin_level(DRDY_PIN) == 0) {
     f64:	e002      	b.n	f6c <values_loop+0x10>
            delay_ms(100);
     f66:	2064      	movs	r0, #100	; 0x64
     f68:	4b3f      	ldr	r3, [pc, #252]	; (1068 <values_loop+0x10c>)
     f6a:	4798      	blx	r3
        while(gpio_get_pin_level(DRDY_PIN) == 0) {
     f6c:	2074      	movs	r0, #116	; 0x74
     f6e:	4b3f      	ldr	r3, [pc, #252]	; (106c <values_loop+0x110>)
     f70:	4798      	blx	r3
     f72:	4603      	mov	r3, r0
     f74:	f083 0301 	eor.w	r3, r3, #1
     f78:	b2db      	uxtb	r3, r3
     f7a:	2b00      	cmp	r3, #0
     f7c:	d1f3      	bne.n	f66 <values_loop+0xa>
        //TO DO: WE HAVE NO IDEA HOW PINS WORK (STILL)
    }

    uint8_t x2,x1,x0,y2,y1,y0,z2,z1,z0;

    RM3100ReadReg(RM3100_MX2_REG, &x2);
     f7e:	f107 0313 	add.w	r3, r7, #19
     f82:	4619      	mov	r1, r3
     f84:	2024      	movs	r0, #36	; 0x24
     f86:	4b3a      	ldr	r3, [pc, #232]	; (1070 <values_loop+0x114>)
     f88:	4798      	blx	r3
    RM3100ReadReg(RM3100_MX1_REG, &x1);
     f8a:	f107 0312 	add.w	r3, r7, #18
     f8e:	4619      	mov	r1, r3
     f90:	2025      	movs	r0, #37	; 0x25
     f92:	4b37      	ldr	r3, [pc, #220]	; (1070 <values_loop+0x114>)
     f94:	4798      	blx	r3
    RM3100ReadReg(RM3100_MX0_REG, &x0);
     f96:	f107 0311 	add.w	r3, r7, #17
     f9a:	4619      	mov	r1, r3
     f9c:	2026      	movs	r0, #38	; 0x26
     f9e:	4b34      	ldr	r3, [pc, #208]	; (1070 <values_loop+0x114>)
     fa0:	4798      	blx	r3
    RM3100ReadReg(RM3100_MY2_REG, &y2);
     fa2:	f107 0310 	add.w	r3, r7, #16
     fa6:	4619      	mov	r1, r3
     fa8:	2027      	movs	r0, #39	; 0x27
     faa:	4b31      	ldr	r3, [pc, #196]	; (1070 <values_loop+0x114>)
     fac:	4798      	blx	r3
    RM3100ReadReg(RM3100_MY1_REG, &y1);
     fae:	f107 030f 	add.w	r3, r7, #15
     fb2:	4619      	mov	r1, r3
     fb4:	2028      	movs	r0, #40	; 0x28
     fb6:	4b2e      	ldr	r3, [pc, #184]	; (1070 <values_loop+0x114>)
     fb8:	4798      	blx	r3
    RM3100ReadReg(RM3100_MY0_REG, &y0);
     fba:	f107 030e 	add.w	r3, r7, #14
     fbe:	4619      	mov	r1, r3
     fc0:	2029      	movs	r0, #41	; 0x29
     fc2:	4b2b      	ldr	r3, [pc, #172]	; (1070 <values_loop+0x114>)
     fc4:	4798      	blx	r3
    RM3100ReadReg(RM3100_MZ2_REG, &z2);
     fc6:	f107 030d 	add.w	r3, r7, #13
     fca:	4619      	mov	r1, r3
     fcc:	202a      	movs	r0, #42	; 0x2a
     fce:	4b28      	ldr	r3, [pc, #160]	; (1070 <values_loop+0x114>)
     fd0:	4798      	blx	r3
    RM3100ReadReg(RM3100_MZ1_REG, &z1);
     fd2:	f107 030c 	add.w	r3, r7, #12
     fd6:	4619      	mov	r1, r3
     fd8:	202b      	movs	r0, #43	; 0x2b
     fda:	4b25      	ldr	r3, [pc, #148]	; (1070 <values_loop+0x114>)
     fdc:	4798      	blx	r3
    RM3100ReadReg(RM3100_MZ0_REG, &z0);
     fde:	f107 030b 	add.w	r3, r7, #11
     fe2:	4619      	mov	r1, r3
     fe4:	202c      	movs	r0, #44	; 0x2c
     fe6:	4b22      	ldr	r3, [pc, #136]	; (1070 <values_loop+0x114>)
     fe8:	4798      	blx	r3

    //Weird bit manipulation
    if (x2 & 0x80) {
     fea:	7cfb      	ldrb	r3, [r7, #19]
     fec:	b25b      	sxtb	r3, r3
     fee:	2b00      	cmp	r3, #0
     ff0:	da01      	bge.n	ff6 <values_loop+0x9a>
        returnVals.x = 0xFF;
     ff2:	23ff      	movs	r3, #255	; 0xff
     ff4:	617b      	str	r3, [r7, #20]
    }
    if (y2 & 0x80) {
     ff6:	7c3b      	ldrb	r3, [r7, #16]
     ff8:	b25b      	sxtb	r3, r3
     ffa:	2b00      	cmp	r3, #0
     ffc:	da01      	bge.n	1002 <values_loop+0xa6>
        returnVals.y = 0xFF;
     ffe:	23ff      	movs	r3, #255	; 0xff
    1000:	61bb      	str	r3, [r7, #24]
    }
    if (z2 & 0x80) {
    1002:	7b7b      	ldrb	r3, [r7, #13]
    1004:	b25b      	sxtb	r3, r3
    1006:	2b00      	cmp	r3, #0
    1008:	da01      	bge.n	100e <values_loop+0xb2>
        returnVals.z = 0xFF;
    100a:	23ff      	movs	r3, #255	; 0xff
    100c:	61fb      	str	r3, [r7, #28]
    }

    returnVals.x = (returnVals.x * 256 * 256 * 256) | (int32_t)(x2) * 256 * 256 | (uint16_t)(x1) * 256 | x0;
    100e:	697b      	ldr	r3, [r7, #20]
    1010:	061a      	lsls	r2, r3, #24
    1012:	7cfb      	ldrb	r3, [r7, #19]
    1014:	041b      	lsls	r3, r3, #16
    1016:	431a      	orrs	r2, r3
    1018:	7cbb      	ldrb	r3, [r7, #18]
    101a:	021b      	lsls	r3, r3, #8
    101c:	4313      	orrs	r3, r2
    101e:	7c7a      	ldrb	r2, [r7, #17]
    1020:	4313      	orrs	r3, r2
    1022:	617b      	str	r3, [r7, #20]
    returnVals.y = (returnVals.y * 256 * 256 * 256) | (int32_t)(y2) * 256 * 256 | (uint16_t)(y1) * 256 | y0;
    1024:	69bb      	ldr	r3, [r7, #24]
    1026:	061a      	lsls	r2, r3, #24
    1028:	7c3b      	ldrb	r3, [r7, #16]
    102a:	041b      	lsls	r3, r3, #16
    102c:	431a      	orrs	r2, r3
    102e:	7bfb      	ldrb	r3, [r7, #15]
    1030:	021b      	lsls	r3, r3, #8
    1032:	4313      	orrs	r3, r2
    1034:	7bba      	ldrb	r2, [r7, #14]
    1036:	4313      	orrs	r3, r2
    1038:	61bb      	str	r3, [r7, #24]
    returnVals.z = (returnVals.z * 256 * 256 * 256) | (int32_t)(z2) * 256 * 256 | (uint16_t)(z1) * 256 | z0;
    103a:	69fb      	ldr	r3, [r7, #28]
    103c:	061a      	lsls	r2, r3, #24
    103e:	7b7b      	ldrb	r3, [r7, #13]
    1040:	041b      	lsls	r3, r3, #16
    1042:	431a      	orrs	r2, r3
    1044:	7b3b      	ldrb	r3, [r7, #12]
    1046:	021b      	lsls	r3, r3, #8
    1048:	4313      	orrs	r3, r2
    104a:	7afa      	ldrb	r2, [r7, #11]
    104c:	4313      	orrs	r3, r2
    104e:	61fb      	str	r3, [r7, #28]

    return returnVals;
    1050:	687b      	ldr	r3, [r7, #4]
    1052:	461c      	mov	r4, r3
    1054:	f107 0314 	add.w	r3, r7, #20
    1058:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
    105c:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
    1060:	6878      	ldr	r0, [r7, #4]
    1062:	3724      	adds	r7, #36	; 0x24
    1064:	46bd      	mov	sp, r7
    1066:	bd90      	pop	{r4, r7, pc}
    1068:	00001a99 	.word	0x00001a99
    106c:	00000e9d 	.word	0x00000e9d
    1070:	00001101 	.word	0x00001101

00001074 <changeCycleCount>:

void changeCycleCount(uint16_t newCC) {
    1074:	b580      	push	{r7, lr}
    1076:	b084      	sub	sp, #16
    1078:	af00      	add	r7, sp, #0
    107a:	4603      	mov	r3, r0
    107c:	80fb      	strh	r3, [r7, #6]
    // Cycle count most sig byte
    uint8_t CCMSB = (newCC & 0xFF00) >> 8;
    107e:	88fb      	ldrh	r3, [r7, #6]
    1080:	0a1b      	lsrs	r3, r3, #8
    1082:	b29b      	uxth	r3, r3
    1084:	73fb      	strb	r3, [r7, #15]
    // Cycle count least sig byte
    uint8_t CCLSB = newCC & 0xFF;
    1086:	88fb      	ldrh	r3, [r7, #6]
    1088:	73bb      	strb	r3, [r7, #14]

    //Todo change this to do it 1 by 1
    uint32_t returnVal = RM3100WriteReg(RM3100_CCX1_REG, CCMSB);
    108a:	7bfb      	ldrb	r3, [r7, #15]
    108c:	4619      	mov	r1, r3
    108e:	2004      	movs	r0, #4
    1090:	4b18      	ldr	r3, [pc, #96]	; (10f4 <changeCycleCount+0x80>)
    1092:	4798      	blx	r3
    1094:	4603      	mov	r3, r0
    1096:	60bb      	str	r3, [r7, #8]
    returnVal = RM3100WriteReg(RM3100_CCX0_REG, CCLSB);
    1098:	7bbb      	ldrb	r3, [r7, #14]
    109a:	4619      	mov	r1, r3
    109c:	2005      	movs	r0, #5
    109e:	4b15      	ldr	r3, [pc, #84]	; (10f4 <changeCycleCount+0x80>)
    10a0:	4798      	blx	r3
    10a2:	4603      	mov	r3, r0
    10a4:	60bb      	str	r3, [r7, #8]
    returnVal = RM3100WriteReg(RM3100_CCY1_REG, CCMSB);
    10a6:	7bfb      	ldrb	r3, [r7, #15]
    10a8:	4619      	mov	r1, r3
    10aa:	2006      	movs	r0, #6
    10ac:	4b11      	ldr	r3, [pc, #68]	; (10f4 <changeCycleCount+0x80>)
    10ae:	4798      	blx	r3
    10b0:	4603      	mov	r3, r0
    10b2:	60bb      	str	r3, [r7, #8]
    returnVal = RM3100WriteReg(RM3100_CCY0_REG, CCLSB);
    10b4:	7bbb      	ldrb	r3, [r7, #14]
    10b6:	4619      	mov	r1, r3
    10b8:	2007      	movs	r0, #7
    10ba:	4b0e      	ldr	r3, [pc, #56]	; (10f4 <changeCycleCount+0x80>)
    10bc:	4798      	blx	r3
    10be:	4603      	mov	r3, r0
    10c0:	60bb      	str	r3, [r7, #8]
    returnVal = RM3100WriteReg(RM3100_CCZ1_REG, CCMSB);
    10c2:	7bfb      	ldrb	r3, [r7, #15]
    10c4:	4619      	mov	r1, r3
    10c6:	2008      	movs	r0, #8
    10c8:	4b0a      	ldr	r3, [pc, #40]	; (10f4 <changeCycleCount+0x80>)
    10ca:	4798      	blx	r3
    10cc:	4603      	mov	r3, r0
    10ce:	60bb      	str	r3, [r7, #8]
    returnVal = RM3100WriteReg(RM3100_CCZ0_REG, CCLSB);
    10d0:	7bbb      	ldrb	r3, [r7, #14]
    10d2:	4619      	mov	r1, r3
    10d4:	2009      	movs	r0, #9
    10d6:	4b07      	ldr	r3, [pc, #28]	; (10f4 <changeCycleCount+0x80>)
    10d8:	4798      	blx	r3
    10da:	4603      	mov	r3, r0
    10dc:	60bb      	str	r3, [r7, #8]

    if ((int32_t) returnVal < 0) {
    10de:	68bb      	ldr	r3, [r7, #8]
    10e0:	2b00      	cmp	r3, #0
    10e2:	da03      	bge.n	10ec <changeCycleCount+0x78>
        printf("It errored\n");
    10e4:	4904      	ldr	r1, [pc, #16]	; (10f8 <changeCycleCount+0x84>)
    10e6:	2000      	movs	r0, #0
    10e8:	4b04      	ldr	r3, [pc, #16]	; (10fc <changeCycleCount+0x88>)
    10ea:	4798      	blx	r3
    }
}
    10ec:	bf00      	nop
    10ee:	3710      	adds	r7, #16
    10f0:	46bd      	mov	sp, r7
    10f2:	bd80      	pop	{r7, pc}
    10f4:	00001175 	.word	0x00001175
    10f8:	00005524 	.word	0x00005524
    10fc:	00000d85 	.word	0x00000d85

00001100 <RM3100ReadReg>:

int32_t RM3100ReadReg(uint8_t addr, uint8_t *val) {
    1100:	b580      	push	{r7, lr}
    1102:	b084      	sub	sp, #16
    1104:	af00      	add	r7, sp, #0
    1106:	4603      	mov	r3, r0
    1108:	6039      	str	r1, [r7, #0]
    110a:	71fb      	strb	r3, [r7, #7]
    static uint8_t writeBuf[1];
    writeBuf[0] = addr;
    110c:	4a13      	ldr	r2, [pc, #76]	; (115c <RM3100ReadReg+0x5c>)
    110e:	79fb      	ldrb	r3, [r7, #7]
    1110:	7013      	strb	r3, [r2, #0]
    int32_t rv;
    if ((rv = io_write(rm3100_io, writeBuf, 1)) != 0){
    1112:	4b13      	ldr	r3, [pc, #76]	; (1160 <RM3100ReadReg+0x60>)
    1114:	681b      	ldr	r3, [r3, #0]
    1116:	2201      	movs	r2, #1
    1118:	4910      	ldr	r1, [pc, #64]	; (115c <RM3100ReadReg+0x5c>)
    111a:	4618      	mov	r0, r3
    111c:	4b11      	ldr	r3, [pc, #68]	; (1164 <RM3100ReadReg+0x64>)
    111e:	4798      	blx	r3
    1120:	60f8      	str	r0, [r7, #12]
    1122:	68fb      	ldr	r3, [r7, #12]
    1124:	2b00      	cmp	r3, #0
    1126:	d004      	beq.n	1132 <RM3100ReadReg+0x32>
        printf("Error in RM3100 Write");
    1128:	490f      	ldr	r1, [pc, #60]	; (1168 <RM3100ReadReg+0x68>)
    112a:	2000      	movs	r0, #0
    112c:	4b0f      	ldr	r3, [pc, #60]	; (116c <RM3100ReadReg+0x6c>)
    112e:	4798      	blx	r3
    1130:	e00e      	b.n	1150 <RM3100ReadReg+0x50>
    } else {
        if ((rv = io_read(rm3100_io, val, 1)) != 0) {
    1132:	4b0b      	ldr	r3, [pc, #44]	; (1160 <RM3100ReadReg+0x60>)
    1134:	681b      	ldr	r3, [r3, #0]
    1136:	2201      	movs	r2, #1
    1138:	6839      	ldr	r1, [r7, #0]
    113a:	4618      	mov	r0, r3
    113c:	4b0c      	ldr	r3, [pc, #48]	; (1170 <RM3100ReadReg+0x70>)
    113e:	4798      	blx	r3
    1140:	60f8      	str	r0, [r7, #12]
    1142:	68fb      	ldr	r3, [r7, #12]
    1144:	2b00      	cmp	r3, #0
    1146:	d003      	beq.n	1150 <RM3100ReadReg+0x50>
            printf("Error in RM3100 Write");
    1148:	4907      	ldr	r1, [pc, #28]	; (1168 <RM3100ReadReg+0x68>)
    114a:	2000      	movs	r0, #0
    114c:	4b07      	ldr	r3, [pc, #28]	; (116c <RM3100ReadReg+0x6c>)
    114e:	4798      	blx	r3
        }
    }
    return rv;
    1150:	68fb      	ldr	r3, [r7, #12]
}
    1152:	4618      	mov	r0, r3
    1154:	3710      	adds	r7, #16
    1156:	46bd      	mov	sp, r7
    1158:	bd80      	pop	{r7, pc}
    115a:	bf00      	nop
    115c:	2000050c 	.word	0x2000050c
    1160:	20000508 	.word	0x20000508
    1164:	000011c1 	.word	0x000011c1
    1168:	00005530 	.word	0x00005530
    116c:	00000d85 	.word	0x00000d85
    1170:	00001211 	.word	0x00001211

00001174 <RM3100WriteReg>:

int32_t RM3100WriteReg(uint8_t addr, uint8_t data) {
    1174:	b580      	push	{r7, lr}
    1176:	b084      	sub	sp, #16
    1178:	af00      	add	r7, sp, #0
    117a:	4603      	mov	r3, r0
    117c:	460a      	mov	r2, r1
    117e:	71fb      	strb	r3, [r7, #7]
    1180:	4613      	mov	r3, r2
    1182:	71bb      	strb	r3, [r7, #6]
    uint8_t writeBuf1[2] = {addr, data};
    1184:	79fb      	ldrb	r3, [r7, #7]
    1186:	733b      	strb	r3, [r7, #12]
    1188:	79bb      	ldrb	r3, [r7, #6]
    118a:	737b      	strb	r3, [r7, #13]

    io_write(rm3100_io, writeBuf1, 1);
    118c:	4b0a      	ldr	r3, [pc, #40]	; (11b8 <RM3100WriteReg+0x44>)
    118e:	681b      	ldr	r3, [r3, #0]
    1190:	f107 010c 	add.w	r1, r7, #12
    1194:	2201      	movs	r2, #1
    1196:	4618      	mov	r0, r3
    1198:	4b08      	ldr	r3, [pc, #32]	; (11bc <RM3100WriteReg+0x48>)
    119a:	4798      	blx	r3
    return io_write(rm3100_io, writeBuf1 + 1, 1);
    119c:	4b06      	ldr	r3, [pc, #24]	; (11b8 <RM3100WriteReg+0x44>)
    119e:	6818      	ldr	r0, [r3, #0]
    11a0:	f107 030c 	add.w	r3, r7, #12
    11a4:	3301      	adds	r3, #1
    11a6:	2201      	movs	r2, #1
    11a8:	4619      	mov	r1, r3
    11aa:	4b04      	ldr	r3, [pc, #16]	; (11bc <RM3100WriteReg+0x48>)
    11ac:	4798      	blx	r3
    11ae:	4603      	mov	r3, r0
}
    11b0:	4618      	mov	r0, r3
    11b2:	3710      	adds	r7, #16
    11b4:	46bd      	mov	sp, r7
    11b6:	bd80      	pop	{r7, pc}
    11b8:	20000508 	.word	0x20000508
    11bc:	000011c1 	.word	0x000011c1

000011c0 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    11c0:	b580      	push	{r7, lr}
    11c2:	b084      	sub	sp, #16
    11c4:	af00      	add	r7, sp, #0
    11c6:	60f8      	str	r0, [r7, #12]
    11c8:	60b9      	str	r1, [r7, #8]
    11ca:	4613      	mov	r3, r2
    11cc:	80fb      	strh	r3, [r7, #6]
	ASSERT(io_descr && buf);
    11ce:	68fb      	ldr	r3, [r7, #12]
    11d0:	2b00      	cmp	r3, #0
    11d2:	d004      	beq.n	11de <io_write+0x1e>
    11d4:	68bb      	ldr	r3, [r7, #8]
    11d6:	2b00      	cmp	r3, #0
    11d8:	d001      	beq.n	11de <io_write+0x1e>
    11da:	2301      	movs	r3, #1
    11dc:	e000      	b.n	11e0 <io_write+0x20>
    11de:	2300      	movs	r3, #0
    11e0:	f003 0301 	and.w	r3, r3, #1
    11e4:	b2db      	uxtb	r3, r3
    11e6:	2234      	movs	r2, #52	; 0x34
    11e8:	4907      	ldr	r1, [pc, #28]	; (1208 <io_write+0x48>)
    11ea:	4618      	mov	r0, r3
    11ec:	4b07      	ldr	r3, [pc, #28]	; (120c <io_write+0x4c>)
    11ee:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
    11f0:	68fb      	ldr	r3, [r7, #12]
    11f2:	681b      	ldr	r3, [r3, #0]
    11f4:	88fa      	ldrh	r2, [r7, #6]
    11f6:	68b9      	ldr	r1, [r7, #8]
    11f8:	68f8      	ldr	r0, [r7, #12]
    11fa:	4798      	blx	r3
    11fc:	4603      	mov	r3, r0
}
    11fe:	4618      	mov	r0, r3
    1200:	3710      	adds	r7, #16
    1202:	46bd      	mov	sp, r7
    1204:	bd80      	pop	{r7, pc}
    1206:	bf00      	nop
    1208:	00005548 	.word	0x00005548
    120c:	00001c39 	.word	0x00001c39

00001210 <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    1210:	b580      	push	{r7, lr}
    1212:	b084      	sub	sp, #16
    1214:	af00      	add	r7, sp, #0
    1216:	60f8      	str	r0, [r7, #12]
    1218:	60b9      	str	r1, [r7, #8]
    121a:	4613      	mov	r3, r2
    121c:	80fb      	strh	r3, [r7, #6]
	ASSERT(io_descr && buf);
    121e:	68fb      	ldr	r3, [r7, #12]
    1220:	2b00      	cmp	r3, #0
    1222:	d004      	beq.n	122e <io_read+0x1e>
    1224:	68bb      	ldr	r3, [r7, #8]
    1226:	2b00      	cmp	r3, #0
    1228:	d001      	beq.n	122e <io_read+0x1e>
    122a:	2301      	movs	r3, #1
    122c:	e000      	b.n	1230 <io_read+0x20>
    122e:	2300      	movs	r3, #0
    1230:	f003 0301 	and.w	r3, r3, #1
    1234:	b2db      	uxtb	r3, r3
    1236:	223d      	movs	r2, #61	; 0x3d
    1238:	4907      	ldr	r1, [pc, #28]	; (1258 <io_read+0x48>)
    123a:	4618      	mov	r0, r3
    123c:	4b07      	ldr	r3, [pc, #28]	; (125c <io_read+0x4c>)
    123e:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
    1240:	68fb      	ldr	r3, [r7, #12]
    1242:	685b      	ldr	r3, [r3, #4]
    1244:	88fa      	ldrh	r2, [r7, #6]
    1246:	68b9      	ldr	r1, [r7, #8]
    1248:	68f8      	ldr	r0, [r7, #12]
    124a:	4798      	blx	r3
    124c:	4603      	mov	r3, r0
}
    124e:	4618      	mov	r0, r3
    1250:	3710      	adds	r7, #16
    1252:	46bd      	mov	sp, r7
    1254:	bd80      	pop	{r7, pc}
    1256:	bf00      	nop
    1258:	00005548 	.word	0x00005548
    125c:	00001c39 	.word	0x00001c39

00001260 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
}
/*-----------------------------------------------------------*/

void vListInsertEnd(List_t *const pxList, ListItem_t *const pxNewListItem)
{
    1260:	b480      	push	{r7}
    1262:	b085      	sub	sp, #20
    1264:	af00      	add	r7, sp, #0
    1266:	6078      	str	r0, [r7, #4]
    1268:	6039      	str	r1, [r7, #0]
	ListItem_t *const pxIndex = pxList->pxIndex;
    126a:	687b      	ldr	r3, [r7, #4]
    126c:	685b      	ldr	r3, [r3, #4]
    126e:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY(pxNewListItem);

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext     = pxIndex;
    1270:	683b      	ldr	r3, [r7, #0]
    1272:	68fa      	ldr	r2, [r7, #12]
    1274:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1276:	68fb      	ldr	r3, [r7, #12]
    1278:	689a      	ldr	r2, [r3, #8]
    127a:	683b      	ldr	r3, [r7, #0]
    127c:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    127e:	68fb      	ldr	r3, [r7, #12]
    1280:	689b      	ldr	r3, [r3, #8]
    1282:	683a      	ldr	r2, [r7, #0]
    1284:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious         = pxNewListItem;
    1286:	68fb      	ldr	r3, [r7, #12]
    1288:	683a      	ldr	r2, [r7, #0]
    128a:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = (void *)pxList;
    128c:	683b      	ldr	r3, [r7, #0]
    128e:	687a      	ldr	r2, [r7, #4]
    1290:	611a      	str	r2, [r3, #16]

	(pxList->uxNumberOfItems)++;
    1292:	687b      	ldr	r3, [r7, #4]
    1294:	681b      	ldr	r3, [r3, #0]
    1296:	1c5a      	adds	r2, r3, #1
    1298:	687b      	ldr	r3, [r7, #4]
    129a:	601a      	str	r2, [r3, #0]
}
    129c:	bf00      	nop
    129e:	3714      	adds	r7, #20
    12a0:	46bd      	mov	sp, r7
    12a2:	f85d 7b04 	ldr.w	r7, [sp], #4
    12a6:	4770      	bx	lr

000012a8 <uxListRemove>:
	(pxList->uxNumberOfItems)++;
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove(ListItem_t *const pxItemToRemove)
{
    12a8:	b480      	push	{r7}
    12aa:	b085      	sub	sp, #20
    12ac:	af00      	add	r7, sp, #0
    12ae:	6078      	str	r0, [r7, #4]
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;
    12b0:	687b      	ldr	r3, [r7, #4]
    12b2:	691b      	ldr	r3, [r3, #16]
    12b4:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    12b6:	687b      	ldr	r3, [r7, #4]
    12b8:	685b      	ldr	r3, [r3, #4]
    12ba:	687a      	ldr	r2, [r7, #4]
    12bc:	6892      	ldr	r2, [r2, #8]
    12be:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    12c0:	687b      	ldr	r3, [r7, #4]
    12c2:	689b      	ldr	r3, [r3, #8]
    12c4:	687a      	ldr	r2, [r7, #4]
    12c6:	6852      	ldr	r2, [r2, #4]
    12c8:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if (pxList->pxIndex == pxItemToRemove) {
    12ca:	68fb      	ldr	r3, [r7, #12]
    12cc:	685b      	ldr	r3, [r3, #4]
    12ce:	687a      	ldr	r2, [r7, #4]
    12d0:	429a      	cmp	r2, r3
    12d2:	d103      	bne.n	12dc <uxListRemove+0x34>
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    12d4:	687b      	ldr	r3, [r7, #4]
    12d6:	689a      	ldr	r2, [r3, #8]
    12d8:	68fb      	ldr	r3, [r7, #12]
    12da:	605a      	str	r2, [r3, #4]
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    12dc:	687b      	ldr	r3, [r7, #4]
    12de:	2200      	movs	r2, #0
    12e0:	611a      	str	r2, [r3, #16]
	(pxList->uxNumberOfItems)--;
    12e2:	68fb      	ldr	r3, [r7, #12]
    12e4:	681b      	ldr	r3, [r3, #0]
    12e6:	1e5a      	subs	r2, r3, #1
    12e8:	68fb      	ldr	r3, [r7, #12]
    12ea:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
    12ec:	68fb      	ldr	r3, [r7, #12]
    12ee:	681b      	ldr	r3, [r3, #0]
}
    12f0:	4618      	mov	r0, r3
    12f2:	3714      	adds	r7, #20
    12f4:	46bd      	mov	sp, r7
    12f6:	f85d 7b04 	ldr.w	r7, [sp], #4
    12fa:	4770      	bx	lr

000012fc <_system_time_init>:

/**
 * \brief Initialize system time module
 */
void _system_time_init(void *const hw)
{
    12fc:	b480      	push	{r7}
    12fe:	b083      	sub	sp, #12
    1300:	af00      	add	r7, sp, #0
    1302:	6078      	str	r0, [r7, #4]
	(void)hw;
	SysTick->LOAD = (0xFFFFFF << SysTick_LOAD_RELOAD_Pos);
    1304:	4b06      	ldr	r3, [pc, #24]	; (1320 <_system_time_init+0x24>)
    1306:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
    130a:	605a      	str	r2, [r3, #4]
	SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos) | (CONF_SYSTICK_TICKINT << SysTick_CTRL_TICKINT_Pos)
    130c:	4b04      	ldr	r3, [pc, #16]	; (1320 <_system_time_init+0x24>)
    130e:	2205      	movs	r2, #5
    1310:	601a      	str	r2, [r3, #0]
	                | (1 << SysTick_CTRL_CLKSOURCE_Pos);
}
    1312:	bf00      	nop
    1314:	370c      	adds	r7, #12
    1316:	46bd      	mov	sp, r7
    1318:	f85d 7b04 	ldr.w	r7, [sp], #4
    131c:	4770      	bx	lr
    131e:	bf00      	nop
    1320:	e000e010 	.word	0xe000e010

00001324 <_delay_init>:
/**
 * \brief Initialize delay functionality
 */
void _delay_init(void *const hw)
{
    1324:	b580      	push	{r7, lr}
    1326:	b082      	sub	sp, #8
    1328:	af00      	add	r7, sp, #0
    132a:	6078      	str	r0, [r7, #4]
	_system_time_init(hw);
    132c:	6878      	ldr	r0, [r7, #4]
    132e:	4b03      	ldr	r3, [pc, #12]	; (133c <_delay_init+0x18>)
    1330:	4798      	blx	r3
}
    1332:	bf00      	nop
    1334:	3708      	adds	r7, #8
    1336:	46bd      	mov	sp, r7
    1338:	bd80      	pop	{r7, pc}
    133a:	bf00      	nop
    133c:	000012fd 	.word	0x000012fd

00001340 <_delay_cycles>:
}
/**
 * \brief Delay loop to delay n number of cycles
 */
void _delay_cycles(void *const hw, uint32_t cycles)
{
    1340:	b480      	push	{r7}
    1342:	b085      	sub	sp, #20
    1344:	af00      	add	r7, sp, #0
    1346:	6078      	str	r0, [r7, #4]
    1348:	6039      	str	r1, [r7, #0]
	(void)hw;
	uint8_t  n   = cycles >> 24;
    134a:	683b      	ldr	r3, [r7, #0]
    134c:	0e1b      	lsrs	r3, r3, #24
    134e:	73fb      	strb	r3, [r7, #15]
	uint32_t buf = cycles;
    1350:	683b      	ldr	r3, [r7, #0]
    1352:	60bb      	str	r3, [r7, #8]

	while (n--) {
    1354:	e013      	b.n	137e <_delay_cycles+0x3e>
		SysTick->LOAD = 0xFFFFFF;
    1356:	4b16      	ldr	r3, [pc, #88]	; (13b0 <_delay_cycles+0x70>)
    1358:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
    135c:	605a      	str	r2, [r3, #4]
		SysTick->VAL  = 0xFFFFFF;
    135e:	4b14      	ldr	r3, [pc, #80]	; (13b0 <_delay_cycles+0x70>)
    1360:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
    1364:	609a      	str	r2, [r3, #8]
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
    1366:	bf00      	nop
    1368:	4b11      	ldr	r3, [pc, #68]	; (13b0 <_delay_cycles+0x70>)
    136a:	681b      	ldr	r3, [r3, #0]
    136c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
    1370:	2b00      	cmp	r3, #0
    1372:	d0f9      	beq.n	1368 <_delay_cycles+0x28>
			;
		buf -= 0xFFFFFF;
    1374:	68bb      	ldr	r3, [r7, #8]
    1376:	f103 437f 	add.w	r3, r3, #4278190080	; 0xff000000
    137a:	3301      	adds	r3, #1
    137c:	60bb      	str	r3, [r7, #8]
	while (n--) {
    137e:	7bfb      	ldrb	r3, [r7, #15]
    1380:	1e5a      	subs	r2, r3, #1
    1382:	73fa      	strb	r2, [r7, #15]
    1384:	2b00      	cmp	r3, #0
    1386:	d1e6      	bne.n	1356 <_delay_cycles+0x16>
	}

	SysTick->LOAD = buf;
    1388:	4a09      	ldr	r2, [pc, #36]	; (13b0 <_delay_cycles+0x70>)
    138a:	68bb      	ldr	r3, [r7, #8]
    138c:	6053      	str	r3, [r2, #4]
	SysTick->VAL  = buf;
    138e:	4a08      	ldr	r2, [pc, #32]	; (13b0 <_delay_cycles+0x70>)
    1390:	68bb      	ldr	r3, [r7, #8]
    1392:	6093      	str	r3, [r2, #8]
	while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
    1394:	bf00      	nop
    1396:	4b06      	ldr	r3, [pc, #24]	; (13b0 <_delay_cycles+0x70>)
    1398:	681b      	ldr	r3, [r3, #0]
    139a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
    139e:	2b00      	cmp	r3, #0
    13a0:	d0f9      	beq.n	1396 <_delay_cycles+0x56>
		;
}
    13a2:	bf00      	nop
    13a4:	bf00      	nop
    13a6:	3714      	adds	r7, #20
    13a8:	46bd      	mov	sp, r7
    13aa:	f85d 7b04 	ldr.w	r7, [sp], #4
    13ae:	4770      	bx	lr
    13b0:	e000e010 	.word	0xe000e010
	...

000013c0 <SVCall_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler(void)
{
	__asm volatile("	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
    13c0:	4b07      	ldr	r3, [pc, #28]	; (13e0 <pxCurrentTCBConst2>)
    13c2:	6819      	ldr	r1, [r3, #0]
    13c4:	6808      	ldr	r0, [r1, #0]
    13c6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    13ca:	f380 8809 	msr	PSP, r0
    13ce:	f3bf 8f6f 	isb	sy
    13d2:	f04f 0000 	mov.w	r0, #0
    13d6:	f380 8811 	msr	BASEPRI, r0
    13da:	4770      	bx	lr
    13dc:	f3af 8000 	nop.w

000013e0 <pxCurrentTCBConst2>:
    13e0:	20000574 	.word	0x20000574
	               "	msr	basepri, r0					\n"
	               "	bx r14							\n"
	               "									\n"
	               "	.align 4						\n"
	               "pxCurrentTCBConst2: .word pxCurrentTCB				\n");
}
    13e4:	bf00      	nop
    13e6:	bf00      	nop
	...

000013f0 <PendSV_Handler>:

void xPortPendSVHandler(void)
{
	/* This is a naked function. */

	__asm volatile(
    13f0:	f3ef 8009 	mrs	r0, PSP
    13f4:	f3bf 8f6f 	isb	sy
    13f8:	4b15      	ldr	r3, [pc, #84]	; (1450 <pxCurrentTCBConst>)
    13fa:	681a      	ldr	r2, [r3, #0]
    13fc:	f01e 0f10 	tst.w	lr, #16
    1400:	bf08      	it	eq
    1402:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
    1406:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    140a:	6010      	str	r0, [r2, #0]
    140c:	e92d 0009 	stmdb	sp!, {r0, r3}
    1410:	f04f 0080 	mov.w	r0, #128	; 0x80
    1414:	f380 8811 	msr	BASEPRI, r0
    1418:	f3bf 8f4f 	dsb	sy
    141c:	f3bf 8f6f 	isb	sy
    1420:	f003 fba0 	bl	4b64 <vTaskSwitchContext>
    1424:	f04f 0000 	mov.w	r0, #0
    1428:	f380 8811 	msr	BASEPRI, r0
    142c:	bc09      	pop	{r0, r3}
    142e:	6819      	ldr	r1, [r3, #0]
    1430:	6808      	ldr	r0, [r1, #0]
    1432:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1436:	f01e 0f10 	tst.w	lr, #16
    143a:	bf08      	it	eq
    143c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
    1440:	f380 8809 	msr	PSP, r0
    1444:	f3bf 8f6f 	isb	sy
    1448:	4770      	bx	lr
    144a:	bf00      	nop
    144c:	f3af 8000 	nop.w

00001450 <pxCurrentTCBConst>:
    1450:	20000574 	.word	0x20000574
	    "										\n"
	    "	bx r14								\n"
	    "										\n"
	    "	.align 4							\n"
	    "pxCurrentTCBConst: .word pxCurrentTCB	\n" ::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY));
}
    1454:	bf00      	nop
    1456:	bf00      	nop

00001458 <SysTick_Handler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler(void)
{
    1458:	b580      	push	{r7, lr}
    145a:	b082      	sub	sp, #8
    145c:	af00      	add	r7, sp, #0

portFORCE_INLINE static void vPortRaiseBASEPRI(void)
{
	uint32_t ulNewBASEPRI;

	__asm volatile("	mov %0, %1												\n"
    145e:	f04f 0380 	mov.w	r3, #128	; 0x80
    1462:	f383 8811 	msr	BASEPRI, r3
    1466:	f3bf 8f6f 	isb	sy
    146a:	f3bf 8f4f 	dsb	sy
    146e:	607b      	str	r3, [r7, #4]
	               "	isb														\n"
	               "	dsb														\n"
	               : "=r"(ulNewBASEPRI)
	               : "i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	               : "memory");
}
    1470:	bf00      	nop
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if (xTaskIncrementTick() != pdFALSE) {
    1472:	4b09      	ldr	r3, [pc, #36]	; (1498 <SysTick_Handler+0x40>)
    1474:	4798      	blx	r3
    1476:	4603      	mov	r3, r0
    1478:	2b00      	cmp	r3, #0
    147a:	d003      	beq.n	1484 <SysTick_Handler+0x2c>
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
    147c:	4b07      	ldr	r3, [pc, #28]	; (149c <SysTick_Handler+0x44>)
    147e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    1482:	601a      	str	r2, [r3, #0]
    1484:	2300      	movs	r3, #0
    1486:	603b      	str	r3, [r7, #0]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI(uint32_t ulNewMaskValue)
{
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
    1488:	683b      	ldr	r3, [r7, #0]
    148a:	f383 8811 	msr	BASEPRI, r3
}
    148e:	bf00      	nop
		}
	}
	portENABLE_INTERRUPTS();
}
    1490:	bf00      	nop
    1492:	3708      	adds	r7, #8
    1494:	46bd      	mov	sp, r7
    1496:	bd80      	pop	{r7, pc}
    1498:	000049dd 	.word	0x000049dd
    149c:	e000ed04 	.word	0xe000ed04

000014a0 <hri_wdt_wait_for_sync>:
typedef uint8_t  hri_wdt_ewctrl_reg_t;
typedef uint8_t  hri_wdt_intenset_reg_t;
typedef uint8_t  hri_wdt_intflag_reg_t;

static inline void hri_wdt_wait_for_sync(const void *const hw, hri_wdt_syncbusy_reg_t reg)
{
    14a0:	b480      	push	{r7}
    14a2:	b083      	sub	sp, #12
    14a4:	af00      	add	r7, sp, #0
    14a6:	6078      	str	r0, [r7, #4]
    14a8:	6039      	str	r1, [r7, #0]
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
    14aa:	bf00      	nop
    14ac:	687b      	ldr	r3, [r7, #4]
    14ae:	689a      	ldr	r2, [r3, #8]
    14b0:	683b      	ldr	r3, [r7, #0]
    14b2:	4013      	ands	r3, r2
    14b4:	2b00      	cmp	r3, #0
    14b6:	d1f9      	bne.n	14ac <hri_wdt_wait_for_sync+0xc>
	};
}
    14b8:	bf00      	nop
    14ba:	bf00      	nop
    14bc:	370c      	adds	r7, #12
    14be:	46bd      	mov	sp, r7
    14c0:	f85d 7b04 	ldr.w	r7, [sp], #4
    14c4:	4770      	bx	lr
	...

000014c8 <hri_wdt_get_CTRLA_ENABLE_bit>:
	hri_wdt_wait_for_sync(hw, WDT_SYNCBUSY_ENABLE | WDT_SYNCBUSY_WEN | WDT_SYNCBUSY_ALWAYSON);
	WDT_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_wdt_get_CTRLA_ENABLE_bit(const void *const hw)
{
    14c8:	b580      	push	{r7, lr}
    14ca:	b084      	sub	sp, #16
    14cc:	af00      	add	r7, sp, #0
    14ce:	6078      	str	r0, [r7, #4]
	uint8_t tmp;
	hri_wdt_wait_for_sync(hw, WDT_SYNCBUSY_ENABLE | WDT_SYNCBUSY_WEN | WDT_SYNCBUSY_ALWAYSON);
    14d0:	210e      	movs	r1, #14
    14d2:	6878      	ldr	r0, [r7, #4]
    14d4:	4b0a      	ldr	r3, [pc, #40]	; (1500 <hri_wdt_get_CTRLA_ENABLE_bit+0x38>)
    14d6:	4798      	blx	r3
	tmp = ((Wdt *)hw)->CTRLA.reg;
    14d8:	687b      	ldr	r3, [r7, #4]
    14da:	781b      	ldrb	r3, [r3, #0]
    14dc:	73fb      	strb	r3, [r7, #15]
	tmp = (tmp & WDT_CTRLA_ENABLE) >> WDT_CTRLA_ENABLE_Pos;
    14de:	7bfb      	ldrb	r3, [r7, #15]
    14e0:	085b      	lsrs	r3, r3, #1
    14e2:	b2db      	uxtb	r3, r3
    14e4:	f003 0301 	and.w	r3, r3, #1
    14e8:	73fb      	strb	r3, [r7, #15]
	return (bool)tmp;
    14ea:	7bfb      	ldrb	r3, [r7, #15]
    14ec:	2b00      	cmp	r3, #0
    14ee:	bf14      	ite	ne
    14f0:	2301      	movne	r3, #1
    14f2:	2300      	moveq	r3, #0
    14f4:	b2db      	uxtb	r3, r3
}
    14f6:	4618      	mov	r0, r3
    14f8:	3710      	adds	r7, #16
    14fa:	46bd      	mov	sp, r7
    14fc:	bd80      	pop	{r7, pc}
    14fe:	bf00      	nop
    1500:	000014a1 	.word	0x000014a1

00001504 <hri_wdt_clear_CTRLA_WEN_bit>:
	hri_wdt_wait_for_sync(hw, WDT_SYNCBUSY_ENABLE | WDT_SYNCBUSY_WEN | WDT_SYNCBUSY_ALWAYSON);
	WDT_CRITICAL_SECTION_LEAVE();
}

static inline void hri_wdt_clear_CTRLA_WEN_bit(const void *const hw)
{
    1504:	b580      	push	{r7, lr}
    1506:	b082      	sub	sp, #8
    1508:	af00      	add	r7, sp, #0
    150a:	6078      	str	r0, [r7, #4]
	WDT_CRITICAL_SECTION_ENTER();
	((Wdt *)hw)->CTRLA.reg &= ~WDT_CTRLA_WEN;
    150c:	687b      	ldr	r3, [r7, #4]
    150e:	781b      	ldrb	r3, [r3, #0]
    1510:	b2db      	uxtb	r3, r3
    1512:	f023 0304 	bic.w	r3, r3, #4
    1516:	b2da      	uxtb	r2, r3
    1518:	687b      	ldr	r3, [r7, #4]
    151a:	701a      	strb	r2, [r3, #0]
	hri_wdt_wait_for_sync(hw, WDT_SYNCBUSY_ENABLE | WDT_SYNCBUSY_WEN | WDT_SYNCBUSY_ALWAYSON);
    151c:	210e      	movs	r1, #14
    151e:	6878      	ldr	r0, [r7, #4]
    1520:	4b02      	ldr	r3, [pc, #8]	; (152c <hri_wdt_clear_CTRLA_WEN_bit+0x28>)
    1522:	4798      	blx	r3
	WDT_CRITICAL_SECTION_LEAVE();
}
    1524:	bf00      	nop
    1526:	3708      	adds	r7, #8
    1528:	46bd      	mov	sp, r7
    152a:	bd80      	pop	{r7, pc}
    152c:	000014a1 	.word	0x000014a1

00001530 <hri_wdt_get_CTRLA_ALWAYSON_bit>:
	hri_wdt_wait_for_sync(hw, WDT_SYNCBUSY_ENABLE | WDT_SYNCBUSY_WEN | WDT_SYNCBUSY_ALWAYSON);
	WDT_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_wdt_get_CTRLA_ALWAYSON_bit(const void *const hw)
{
    1530:	b580      	push	{r7, lr}
    1532:	b084      	sub	sp, #16
    1534:	af00      	add	r7, sp, #0
    1536:	6078      	str	r0, [r7, #4]
	uint8_t tmp;
	hri_wdt_wait_for_sync(hw, WDT_SYNCBUSY_ENABLE | WDT_SYNCBUSY_WEN | WDT_SYNCBUSY_ALWAYSON);
    1538:	210e      	movs	r1, #14
    153a:	6878      	ldr	r0, [r7, #4]
    153c:	4b08      	ldr	r3, [pc, #32]	; (1560 <hri_wdt_get_CTRLA_ALWAYSON_bit+0x30>)
    153e:	4798      	blx	r3
	tmp = ((Wdt *)hw)->CTRLA.reg;
    1540:	687b      	ldr	r3, [r7, #4]
    1542:	781b      	ldrb	r3, [r3, #0]
    1544:	73fb      	strb	r3, [r7, #15]
	tmp = (tmp & WDT_CTRLA_ALWAYSON) >> WDT_CTRLA_ALWAYSON_Pos;
    1546:	7bfb      	ldrb	r3, [r7, #15]
    1548:	09db      	lsrs	r3, r3, #7
    154a:	73fb      	strb	r3, [r7, #15]
	return (bool)tmp;
    154c:	7bfb      	ldrb	r3, [r7, #15]
    154e:	2b00      	cmp	r3, #0
    1550:	bf14      	ite	ne
    1552:	2301      	movne	r3, #1
    1554:	2300      	moveq	r3, #0
    1556:	b2db      	uxtb	r3, r3
}
    1558:	4618      	mov	r0, r3
    155a:	3710      	adds	r7, #16
    155c:	46bd      	mov	sp, r7
    155e:	bd80      	pop	{r7, pc}
    1560:	000014a1 	.word	0x000014a1

00001564 <hri_wdt_write_CONFIG_PER_bf>:
	tmp = (tmp & WDT_CONFIG_PER(mask)) >> WDT_CONFIG_PER_Pos;
	return tmp;
}

static inline void hri_wdt_write_CONFIG_PER_bf(const void *const hw, hri_wdt_config_reg_t data)
{
    1564:	b480      	push	{r7}
    1566:	b085      	sub	sp, #20
    1568:	af00      	add	r7, sp, #0
    156a:	6078      	str	r0, [r7, #4]
    156c:	460b      	mov	r3, r1
    156e:	70fb      	strb	r3, [r7, #3]
	uint8_t tmp;
	WDT_CRITICAL_SECTION_ENTER();
	tmp = ((Wdt *)hw)->CONFIG.reg;
    1570:	687b      	ldr	r3, [r7, #4]
    1572:	785b      	ldrb	r3, [r3, #1]
    1574:	73fb      	strb	r3, [r7, #15]
	tmp &= ~WDT_CONFIG_PER_Msk;
    1576:	7bfb      	ldrb	r3, [r7, #15]
    1578:	f023 030f 	bic.w	r3, r3, #15
    157c:	73fb      	strb	r3, [r7, #15]
	tmp |= WDT_CONFIG_PER(data);
    157e:	78fb      	ldrb	r3, [r7, #3]
    1580:	f003 030f 	and.w	r3, r3, #15
    1584:	b2da      	uxtb	r2, r3
    1586:	7bfb      	ldrb	r3, [r7, #15]
    1588:	4313      	orrs	r3, r2
    158a:	73fb      	strb	r3, [r7, #15]
	((Wdt *)hw)->CONFIG.reg = tmp;
    158c:	687b      	ldr	r3, [r7, #4]
    158e:	7bfa      	ldrb	r2, [r7, #15]
    1590:	705a      	strb	r2, [r3, #1]
	WDT_CRITICAL_SECTION_LEAVE();
}
    1592:	bf00      	nop
    1594:	3714      	adds	r7, #20
    1596:	46bd      	mov	sp, r7
    1598:	f85d 7b04 	ldr.w	r7, [sp], #4
    159c:	4770      	bx	lr
	...

000015a0 <_wdt_init>:

/**
 * \brief WDT initialization function
 */
int32_t _wdt_init(struct wdt_dev *const dev)
{
    15a0:	b580      	push	{r7, lr}
    15a2:	b082      	sub	sp, #8
    15a4:	af00      	add	r7, sp, #0
    15a6:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	ASSERT(dev && dev->hw);
    15a8:	687b      	ldr	r3, [r7, #4]
    15aa:	2b00      	cmp	r3, #0
    15ac:	d005      	beq.n	15ba <_wdt_init+0x1a>
    15ae:	687b      	ldr	r3, [r7, #4]
    15b0:	681b      	ldr	r3, [r3, #0]
    15b2:	2b00      	cmp	r3, #0
    15b4:	d001      	beq.n	15ba <_wdt_init+0x1a>
    15b6:	2301      	movs	r3, #1
    15b8:	e000      	b.n	15bc <_wdt_init+0x1c>
    15ba:	2300      	movs	r3, #0
    15bc:	f003 0301 	and.w	r3, r3, #1
    15c0:	b2db      	uxtb	r3, r3
    15c2:	2250      	movs	r2, #80	; 0x50
    15c4:	4913      	ldr	r1, [pc, #76]	; (1614 <_wdt_init+0x74>)
    15c6:	4618      	mov	r0, r3
    15c8:	4b13      	ldr	r3, [pc, #76]	; (1618 <_wdt_init+0x78>)
    15ca:	4798      	blx	r3

	if (hri_wdt_get_CTRLA_ALWAYSON_bit(dev->hw) || hri_wdt_get_CTRLA_ENABLE_bit(dev->hw)) {
    15cc:	687b      	ldr	r3, [r7, #4]
    15ce:	681b      	ldr	r3, [r3, #0]
    15d0:	4618      	mov	r0, r3
    15d2:	4b12      	ldr	r3, [pc, #72]	; (161c <_wdt_init+0x7c>)
    15d4:	4798      	blx	r3
    15d6:	4603      	mov	r3, r0
    15d8:	2b00      	cmp	r3, #0
    15da:	d107      	bne.n	15ec <_wdt_init+0x4c>
    15dc:	687b      	ldr	r3, [r7, #4]
    15de:	681b      	ldr	r3, [r3, #0]
    15e0:	4618      	mov	r0, r3
    15e2:	4b0f      	ldr	r3, [pc, #60]	; (1620 <_wdt_init+0x80>)
    15e4:	4798      	blx	r3
    15e6:	4603      	mov	r3, r0
    15e8:	2b00      	cmp	r3, #0
    15ea:	d002      	beq.n	15f2 <_wdt_init+0x52>
		return ERR_DENIED;
    15ec:	f06f 0310 	mvn.w	r3, #16
    15f0:	e00b      	b.n	160a <_wdt_init+0x6a>
	} else {
		if (CONF_WDT_WINDOW_EN) {
			hri_wdt_write_CONFIG_WINDOW_bf(dev->hw, CONF_WDT_WINDOW);
		} else {
			hri_wdt_clear_CTRLA_WEN_bit(dev->hw);
    15f2:	687b      	ldr	r3, [r7, #4]
    15f4:	681b      	ldr	r3, [r3, #0]
    15f6:	4618      	mov	r0, r3
    15f8:	4b0a      	ldr	r3, [pc, #40]	; (1624 <_wdt_init+0x84>)
    15fa:	4798      	blx	r3
		}

		hri_wdt_write_CONFIG_PER_bf(dev->hw, CONF_WDT_PER);
    15fc:	687b      	ldr	r3, [r7, #4]
    15fe:	681b      	ldr	r3, [r3, #0]
    1600:	2100      	movs	r1, #0
    1602:	4618      	mov	r0, r3
    1604:	4b08      	ldr	r3, [pc, #32]	; (1628 <_wdt_init+0x88>)
    1606:	4798      	blx	r3
	}

	return ERR_NONE;
    1608:	2300      	movs	r3, #0
}
    160a:	4618      	mov	r0, r3
    160c:	3708      	adds	r7, #8
    160e:	46bd      	mov	sp, r7
    1610:	bd80      	pop	{r7, pc}
    1612:	bf00      	nop
    1614:	0000555c 	.word	0x0000555c
    1618:	00001c39 	.word	0x00001c39
    161c:	00001531 	.word	0x00001531
    1620:	000014c9 	.word	0x000014c9
    1624:	00001505 	.word	0x00001505
    1628:	00001565 	.word	0x00001565

0000162c <_get_cycles_for_ms_internal>:

/**
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
static inline uint32_t _get_cycles_for_ms_internal(const uint16_t ms, const uint32_t freq, const uint8_t power)
{
    162c:	b480      	push	{r7}
    162e:	b083      	sub	sp, #12
    1630:	af00      	add	r7, sp, #0
    1632:	4603      	mov	r3, r0
    1634:	6039      	str	r1, [r7, #0]
    1636:	80fb      	strh	r3, [r7, #6]
    1638:	4613      	mov	r3, r2
    163a:	717b      	strb	r3, [r7, #5]
	switch (power) {
    163c:	797b      	ldrb	r3, [r7, #5]
    163e:	3b04      	subs	r3, #4
    1640:	2b05      	cmp	r3, #5
    1642:	d85d      	bhi.n	1700 <_get_cycles_for_ms_internal+0xd4>
    1644:	a201      	add	r2, pc, #4	; (adr r2, 164c <_get_cycles_for_ms_internal+0x20>)
    1646:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    164a:	bf00      	nop
    164c:	000016e3 	.word	0x000016e3
    1650:	000016c5 	.word	0x000016c5
    1654:	000016b3 	.word	0x000016b3
    1658:	00001699 	.word	0x00001699
    165c:	0000167f 	.word	0x0000167f
    1660:	00001665 	.word	0x00001665
	case 9:
		return (ms * (freq / 1000000)) * 1000;
    1664:	88fb      	ldrh	r3, [r7, #6]
    1666:	683a      	ldr	r2, [r7, #0]
    1668:	492d      	ldr	r1, [pc, #180]	; (1720 <_get_cycles_for_ms_internal+0xf4>)
    166a:	fba1 1202 	umull	r1, r2, r1, r2
    166e:	0c92      	lsrs	r2, r2, #18
    1670:	fb02 f303 	mul.w	r3, r2, r3
    1674:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    1678:	fb02 f303 	mul.w	r3, r2, r3
    167c:	e04a      	b.n	1714 <_get_cycles_for_ms_internal+0xe8>
	case 8:
		return (ms * (freq / 100000)) * 100;
    167e:	88fb      	ldrh	r3, [r7, #6]
    1680:	683a      	ldr	r2, [r7, #0]
    1682:	0952      	lsrs	r2, r2, #5
    1684:	4927      	ldr	r1, [pc, #156]	; (1724 <_get_cycles_for_ms_internal+0xf8>)
    1686:	fba1 1202 	umull	r1, r2, r1, r2
    168a:	09d2      	lsrs	r2, r2, #7
    168c:	fb02 f303 	mul.w	r3, r2, r3
    1690:	2264      	movs	r2, #100	; 0x64
    1692:	fb02 f303 	mul.w	r3, r2, r3
    1696:	e03d      	b.n	1714 <_get_cycles_for_ms_internal+0xe8>
	case 7:
		return (ms * (freq / 10000)) * 10;
    1698:	88fb      	ldrh	r3, [r7, #6]
    169a:	683a      	ldr	r2, [r7, #0]
    169c:	4922      	ldr	r1, [pc, #136]	; (1728 <_get_cycles_for_ms_internal+0xfc>)
    169e:	fba1 1202 	umull	r1, r2, r1, r2
    16a2:	0b52      	lsrs	r2, r2, #13
    16a4:	fb03 f202 	mul.w	r2, r3, r2
    16a8:	4613      	mov	r3, r2
    16aa:	009b      	lsls	r3, r3, #2
    16ac:	4413      	add	r3, r2
    16ae:	005b      	lsls	r3, r3, #1
    16b0:	e030      	b.n	1714 <_get_cycles_for_ms_internal+0xe8>
	case 6:
		return (ms * (freq / 1000));
    16b2:	88fb      	ldrh	r3, [r7, #6]
    16b4:	683a      	ldr	r2, [r7, #0]
    16b6:	491d      	ldr	r1, [pc, #116]	; (172c <_get_cycles_for_ms_internal+0x100>)
    16b8:	fba1 1202 	umull	r1, r2, r1, r2
    16bc:	0992      	lsrs	r2, r2, #6
    16be:	fb02 f303 	mul.w	r3, r2, r3
    16c2:	e027      	b.n	1714 <_get_cycles_for_ms_internal+0xe8>
	case 5:
		return (ms * (freq / 100) - 1) / 10 + 1;
    16c4:	88fb      	ldrh	r3, [r7, #6]
    16c6:	683a      	ldr	r2, [r7, #0]
    16c8:	4919      	ldr	r1, [pc, #100]	; (1730 <_get_cycles_for_ms_internal+0x104>)
    16ca:	fba1 1202 	umull	r1, r2, r1, r2
    16ce:	0952      	lsrs	r2, r2, #5
    16d0:	fb02 f303 	mul.w	r3, r2, r3
    16d4:	3b01      	subs	r3, #1
    16d6:	4a17      	ldr	r2, [pc, #92]	; (1734 <_get_cycles_for_ms_internal+0x108>)
    16d8:	fba2 2303 	umull	r2, r3, r2, r3
    16dc:	08db      	lsrs	r3, r3, #3
    16de:	3301      	adds	r3, #1
    16e0:	e018      	b.n	1714 <_get_cycles_for_ms_internal+0xe8>
	case 4:
		return (ms * (freq / 10) - 1) / 100 + 1;
    16e2:	88fb      	ldrh	r3, [r7, #6]
    16e4:	683a      	ldr	r2, [r7, #0]
    16e6:	4913      	ldr	r1, [pc, #76]	; (1734 <_get_cycles_for_ms_internal+0x108>)
    16e8:	fba1 1202 	umull	r1, r2, r1, r2
    16ec:	08d2      	lsrs	r2, r2, #3
    16ee:	fb02 f303 	mul.w	r3, r2, r3
    16f2:	3b01      	subs	r3, #1
    16f4:	4a0e      	ldr	r2, [pc, #56]	; (1730 <_get_cycles_for_ms_internal+0x104>)
    16f6:	fba2 2303 	umull	r2, r3, r2, r3
    16fa:	095b      	lsrs	r3, r3, #5
    16fc:	3301      	adds	r3, #1
    16fe:	e009      	b.n	1714 <_get_cycles_for_ms_internal+0xe8>
	default:
		return (ms * freq - 1) / 1000 + 1;
    1700:	88fb      	ldrh	r3, [r7, #6]
    1702:	683a      	ldr	r2, [r7, #0]
    1704:	fb02 f303 	mul.w	r3, r2, r3
    1708:	3b01      	subs	r3, #1
    170a:	4a08      	ldr	r2, [pc, #32]	; (172c <_get_cycles_for_ms_internal+0x100>)
    170c:	fba2 2303 	umull	r2, r3, r2, r3
    1710:	099b      	lsrs	r3, r3, #6
    1712:	3301      	adds	r3, #1
	}
}
    1714:	4618      	mov	r0, r3
    1716:	370c      	adds	r7, #12
    1718:	46bd      	mov	sp, r7
    171a:	f85d 7b04 	ldr.w	r7, [sp], #4
    171e:	4770      	bx	lr
    1720:	431bde83 	.word	0x431bde83
    1724:	0a7c5ac5 	.word	0x0a7c5ac5
    1728:	d1b71759 	.word	0xd1b71759
    172c:	10624dd3 	.word	0x10624dd3
    1730:	51eb851f 	.word	0x51eb851f
    1734:	cccccccd 	.word	0xcccccccd

00001738 <_get_cycles_for_ms>:

/**
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
    1738:	b580      	push	{r7, lr}
    173a:	b082      	sub	sp, #8
    173c:	af00      	add	r7, sp, #0
    173e:	4603      	mov	r3, r0
    1740:	80fb      	strh	r3, [r7, #6]
	return _get_cycles_for_ms_internal(ms, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
    1742:	88fb      	ldrh	r3, [r7, #6]
    1744:	2207      	movs	r2, #7
    1746:	4904      	ldr	r1, [pc, #16]	; (1758 <_get_cycles_for_ms+0x20>)
    1748:	4618      	mov	r0, r3
    174a:	4b04      	ldr	r3, [pc, #16]	; (175c <_get_cycles_for_ms+0x24>)
    174c:	4798      	blx	r3
    174e:	4603      	mov	r3, r0
}
    1750:	4618      	mov	r0, r3
    1752:	3708      	adds	r7, #8
    1754:	46bd      	mov	sp, r7
    1756:	bd80      	pop	{r7, pc}
    1758:	0016e360 	.word	0x0016e360
    175c:	0000162d 	.word	0x0000162d

00001760 <spi_m_sync_init>:
	ASSERT(spi);
	spi->func = (struct _spi_m_sync_hpl_interface *)func;
}

int32_t spi_m_sync_init(struct spi_m_sync_descriptor *spi, void *const hw)
{
    1760:	b580      	push	{r7, lr}
    1762:	b084      	sub	sp, #16
    1764:	af00      	add	r7, sp, #0
    1766:	6078      	str	r0, [r7, #4]
    1768:	6039      	str	r1, [r7, #0]
	int32_t rc = 0;
    176a:	2300      	movs	r3, #0
    176c:	60fb      	str	r3, [r7, #12]
	ASSERT(spi && hw);
    176e:	687b      	ldr	r3, [r7, #4]
    1770:	2b00      	cmp	r3, #0
    1772:	d004      	beq.n	177e <spi_m_sync_init+0x1e>
    1774:	683b      	ldr	r3, [r7, #0]
    1776:	2b00      	cmp	r3, #0
    1778:	d001      	beq.n	177e <spi_m_sync_init+0x1e>
    177a:	2301      	movs	r3, #1
    177c:	e000      	b.n	1780 <spi_m_sync_init+0x20>
    177e:	2300      	movs	r3, #0
    1780:	f003 0301 	and.w	r3, r3, #1
    1784:	b2db      	uxtb	r3, r3
    1786:	2240      	movs	r2, #64	; 0x40
    1788:	4910      	ldr	r1, [pc, #64]	; (17cc <spi_m_sync_init+0x6c>)
    178a:	4618      	mov	r0, r3
    178c:	4b10      	ldr	r3, [pc, #64]	; (17d0 <spi_m_sync_init+0x70>)
    178e:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
    1790:	687b      	ldr	r3, [r7, #4]
    1792:	683a      	ldr	r2, [r7, #0]
    1794:	605a      	str	r2, [r3, #4]
	rc            = _spi_m_sync_init(&spi->dev, hw);
    1796:	687b      	ldr	r3, [r7, #4]
    1798:	3304      	adds	r3, #4
    179a:	6839      	ldr	r1, [r7, #0]
    179c:	4618      	mov	r0, r3
    179e:	4b0d      	ldr	r3, [pc, #52]	; (17d4 <spi_m_sync_init+0x74>)
    17a0:	4798      	blx	r3
    17a2:	60f8      	str	r0, [r7, #12]

	if (rc < 0) {
    17a4:	68fb      	ldr	r3, [r7, #12]
    17a6:	2b00      	cmp	r3, #0
    17a8:	da01      	bge.n	17ae <spi_m_sync_init+0x4e>
		return rc;
    17aa:	68fb      	ldr	r3, [r7, #12]
    17ac:	e00a      	b.n	17c4 <spi_m_sync_init+0x64>
	}

	spi->flags    = SPI_DEACTIVATE_NEXT;
    17ae:	687b      	ldr	r3, [r7, #4]
    17b0:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    17b4:	829a      	strh	r2, [r3, #20]
	spi->io.read  = _spi_m_sync_io_read;
    17b6:	687b      	ldr	r3, [r7, #4]
    17b8:	4a07      	ldr	r2, [pc, #28]	; (17d8 <spi_m_sync_init+0x78>)
    17ba:	611a      	str	r2, [r3, #16]
	spi->io.write = _spi_m_sync_io_write;
    17bc:	687b      	ldr	r3, [r7, #4]
    17be:	4a07      	ldr	r2, [pc, #28]	; (17dc <spi_m_sync_init+0x7c>)
    17c0:	60da      	str	r2, [r3, #12]

	return ERR_NONE;
    17c2:	2300      	movs	r3, #0
}
    17c4:	4618      	mov	r0, r3
    17c6:	3710      	adds	r7, #16
    17c8:	46bd      	mov	sp, r7
    17ca:	bd80      	pop	{r7, pc}
    17cc:	00005574 	.word	0x00005574
    17d0:	00001c39 	.word	0x00001c39
    17d4:	000043a1 	.word	0x000043a1
    17d8:	000017e1 	.word	0x000017e1
    17dc:	00001839 	.word	0x00001839

000017e0 <_spi_m_sync_io_read>:
 *  \return Operation status.
 *  \retval size Success.
 *  \retval >=0 Time out, with number of characters read.
 */
static int32_t _spi_m_sync_io_read(struct io_descriptor *io, uint8_t *buf, const uint16_t length)
{
    17e0:	b580      	push	{r7, lr}
    17e2:	b088      	sub	sp, #32
    17e4:	af00      	add	r7, sp, #0
    17e6:	60f8      	str	r0, [r7, #12]
    17e8:	60b9      	str	r1, [r7, #8]
    17ea:	4613      	mov	r3, r2
    17ec:	80fb      	strh	r3, [r7, #6]
	ASSERT(io);
    17ee:	68fb      	ldr	r3, [r7, #12]
    17f0:	2b00      	cmp	r3, #0
    17f2:	bf14      	ite	ne
    17f4:	2301      	movne	r3, #1
    17f6:	2300      	moveq	r3, #0
    17f8:	b2db      	uxtb	r3, r3
    17fa:	2287      	movs	r2, #135	; 0x87
    17fc:	490b      	ldr	r1, [pc, #44]	; (182c <_spi_m_sync_io_read+0x4c>)
    17fe:	4618      	mov	r0, r3
    1800:	4b0b      	ldr	r3, [pc, #44]	; (1830 <_spi_m_sync_io_read+0x50>)
    1802:	4798      	blx	r3

	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
    1804:	68fb      	ldr	r3, [r7, #12]
    1806:	3b0c      	subs	r3, #12
    1808:	61fb      	str	r3, [r7, #28]
	struct spi_xfer               xfer;

	xfer.rxbuf = buf;
    180a:	68bb      	ldr	r3, [r7, #8]
    180c:	617b      	str	r3, [r7, #20]
	xfer.txbuf = 0;
    180e:	2300      	movs	r3, #0
    1810:	613b      	str	r3, [r7, #16]
	xfer.size  = length;
    1812:	88fb      	ldrh	r3, [r7, #6]
    1814:	61bb      	str	r3, [r7, #24]

	return spi_m_sync_transfer(spi, &xfer);
    1816:	f107 0310 	add.w	r3, r7, #16
    181a:	4619      	mov	r1, r3
    181c:	69f8      	ldr	r0, [r7, #28]
    181e:	4b05      	ldr	r3, [pc, #20]	; (1834 <_spi_m_sync_io_read+0x54>)
    1820:	4798      	blx	r3
    1822:	4603      	mov	r3, r0
}
    1824:	4618      	mov	r0, r3
    1826:	3720      	adds	r7, #32
    1828:	46bd      	mov	sp, r7
    182a:	bd80      	pop	{r7, pc}
    182c:	00005574 	.word	0x00005574
    1830:	00001c39 	.word	0x00001c39
    1834:	00001891 	.word	0x00001891

00001838 <_spi_m_sync_io_write>:
 *  \return Operation status.
 *  \retval size Success.
 *  \retval >=0 Timeout, with number of characters transferred.
 */
static int32_t _spi_m_sync_io_write(struct io_descriptor *const io, const uint8_t *const buf, const uint16_t length)
{
    1838:	b580      	push	{r7, lr}
    183a:	b088      	sub	sp, #32
    183c:	af00      	add	r7, sp, #0
    183e:	60f8      	str	r0, [r7, #12]
    1840:	60b9      	str	r1, [r7, #8]
    1842:	4613      	mov	r3, r2
    1844:	80fb      	strh	r3, [r7, #6]
	ASSERT(io);
    1846:	68fb      	ldr	r3, [r7, #12]
    1848:	2b00      	cmp	r3, #0
    184a:	bf14      	ite	ne
    184c:	2301      	movne	r3, #1
    184e:	2300      	moveq	r3, #0
    1850:	b2db      	uxtb	r3, r3
    1852:	22a3      	movs	r2, #163	; 0xa3
    1854:	490b      	ldr	r1, [pc, #44]	; (1884 <_spi_m_sync_io_write+0x4c>)
    1856:	4618      	mov	r0, r3
    1858:	4b0b      	ldr	r3, [pc, #44]	; (1888 <_spi_m_sync_io_write+0x50>)
    185a:	4798      	blx	r3

	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
    185c:	68fb      	ldr	r3, [r7, #12]
    185e:	3b0c      	subs	r3, #12
    1860:	61fb      	str	r3, [r7, #28]
	struct spi_xfer               xfer;

	xfer.rxbuf = 0;
    1862:	2300      	movs	r3, #0
    1864:	617b      	str	r3, [r7, #20]
	xfer.txbuf = (uint8_t *)buf;
    1866:	68bb      	ldr	r3, [r7, #8]
    1868:	613b      	str	r3, [r7, #16]
	xfer.size  = length;
    186a:	88fb      	ldrh	r3, [r7, #6]
    186c:	61bb      	str	r3, [r7, #24]

	return spi_m_sync_transfer(spi, &xfer);
    186e:	f107 0310 	add.w	r3, r7, #16
    1872:	4619      	mov	r1, r3
    1874:	69f8      	ldr	r0, [r7, #28]
    1876:	4b05      	ldr	r3, [pc, #20]	; (188c <_spi_m_sync_io_write+0x54>)
    1878:	4798      	blx	r3
    187a:	4603      	mov	r3, r0
}
    187c:	4618      	mov	r0, r3
    187e:	3720      	adds	r7, #32
    1880:	46bd      	mov	sp, r7
    1882:	bd80      	pop	{r7, pc}
    1884:	00005574 	.word	0x00005574
    1888:	00001c39 	.word	0x00001c39
    188c:	00001891 	.word	0x00001891

00001890 <spi_m_sync_transfer>:

int32_t spi_m_sync_transfer(struct spi_m_sync_descriptor *spi, const struct spi_xfer *p_xfer)
{
    1890:	b580      	push	{r7, lr}
    1892:	b086      	sub	sp, #24
    1894:	af00      	add	r7, sp, #0
    1896:	6078      	str	r0, [r7, #4]
    1898:	6039      	str	r1, [r7, #0]
	struct spi_msg msg;

	ASSERT(spi && p_xfer);
    189a:	687b      	ldr	r3, [r7, #4]
    189c:	2b00      	cmp	r3, #0
    189e:	d004      	beq.n	18aa <spi_m_sync_transfer+0x1a>
    18a0:	683b      	ldr	r3, [r7, #0]
    18a2:	2b00      	cmp	r3, #0
    18a4:	d001      	beq.n	18aa <spi_m_sync_transfer+0x1a>
    18a6:	2301      	movs	r3, #1
    18a8:	e000      	b.n	18ac <spi_m_sync_transfer+0x1c>
    18aa:	2300      	movs	r3, #0
    18ac:	f003 0301 	and.w	r3, r3, #1
    18b0:	b2db      	uxtb	r3, r3
    18b2:	22b3      	movs	r2, #179	; 0xb3
    18b4:	490c      	ldr	r1, [pc, #48]	; (18e8 <spi_m_sync_transfer+0x58>)
    18b6:	4618      	mov	r0, r3
    18b8:	4b0c      	ldr	r3, [pc, #48]	; (18ec <spi_m_sync_transfer+0x5c>)
    18ba:	4798      	blx	r3

	msg.txbuf = p_xfer->txbuf;
    18bc:	683b      	ldr	r3, [r7, #0]
    18be:	681b      	ldr	r3, [r3, #0]
    18c0:	60fb      	str	r3, [r7, #12]
	msg.rxbuf = p_xfer->rxbuf;
    18c2:	683b      	ldr	r3, [r7, #0]
    18c4:	685b      	ldr	r3, [r3, #4]
    18c6:	613b      	str	r3, [r7, #16]
	msg.size  = p_xfer->size;
    18c8:	683b      	ldr	r3, [r7, #0]
    18ca:	689b      	ldr	r3, [r3, #8]
    18cc:	617b      	str	r3, [r7, #20]
	return _spi_m_sync_trans(&spi->dev, &msg);
    18ce:	687b      	ldr	r3, [r7, #4]
    18d0:	3304      	adds	r3, #4
    18d2:	f107 020c 	add.w	r2, r7, #12
    18d6:	4611      	mov	r1, r2
    18d8:	4618      	mov	r0, r3
    18da:	4b05      	ldr	r3, [pc, #20]	; (18f0 <spi_m_sync_transfer+0x60>)
    18dc:	4798      	blx	r3
    18de:	4603      	mov	r3, r0
}
    18e0:	4618      	mov	r0, r3
    18e2:	3718      	adds	r7, #24
    18e4:	46bd      	mov	sp, r7
    18e6:	bd80      	pop	{r7, pc}
    18e8:	00005574 	.word	0x00005574
    18ec:	00001c39 	.word	0x00001c39
    18f0:	00004601 	.word	0x00004601

000018f4 <i2c_m_sync_read>:

/**
 * \brief Sync version of I2C I/O read
 */
static int32_t i2c_m_sync_read(struct io_descriptor *io, uint8_t *buf, const uint16_t n)
{
    18f4:	b580      	push	{r7, lr}
    18f6:	b08a      	sub	sp, #40	; 0x28
    18f8:	af00      	add	r7, sp, #0
    18fa:	60f8      	str	r0, [r7, #12]
    18fc:	60b9      	str	r1, [r7, #8]
    18fe:	4613      	mov	r3, r2
    1900:	80fb      	strh	r3, [r7, #6]
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
    1902:	68fb      	ldr	r3, [r7, #12]
    1904:	3b14      	subs	r3, #20
    1906:	627b      	str	r3, [r7, #36]	; 0x24
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
    1908:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    190a:	8b9b      	ldrh	r3, [r3, #28]
    190c:	82bb      	strh	r3, [r7, #20]
	msg.len    = n;
    190e:	88fb      	ldrh	r3, [r7, #6]
    1910:	61bb      	str	r3, [r7, #24]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
    1912:	f248 0301 	movw	r3, #32769	; 0x8001
    1916:	82fb      	strh	r3, [r7, #22]
	msg.buffer = buf;
    1918:	68bb      	ldr	r3, [r7, #8]
    191a:	61fb      	str	r3, [r7, #28]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
    191c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    191e:	f107 0214 	add.w	r2, r7, #20
    1922:	4611      	mov	r1, r2
    1924:	4618      	mov	r0, r3
    1926:	4b06      	ldr	r3, [pc, #24]	; (1940 <i2c_m_sync_read+0x4c>)
    1928:	4798      	blx	r3
    192a:	6238      	str	r0, [r7, #32]

	if (ret) {
    192c:	6a3b      	ldr	r3, [r7, #32]
    192e:	2b00      	cmp	r3, #0
    1930:	d001      	beq.n	1936 <i2c_m_sync_read+0x42>
		return ret;
    1932:	6a3b      	ldr	r3, [r7, #32]
    1934:	e000      	b.n	1938 <i2c_m_sync_read+0x44>
	}

	return n;
    1936:	88fb      	ldrh	r3, [r7, #6]
}
    1938:	4618      	mov	r0, r3
    193a:	3728      	adds	r7, #40	; 0x28
    193c:	46bd      	mov	sp, r7
    193e:	bd80      	pop	{r7, pc}
    1940:	00003f15 	.word	0x00003f15

00001944 <i2c_m_sync_write>:

/**
 * \brief Sync version of I2C I/O write
 */
static int32_t i2c_m_sync_write(struct io_descriptor *io, const uint8_t *buf, const uint16_t n)
{
    1944:	b580      	push	{r7, lr}
    1946:	b08a      	sub	sp, #40	; 0x28
    1948:	af00      	add	r7, sp, #0
    194a:	60f8      	str	r0, [r7, #12]
    194c:	60b9      	str	r1, [r7, #8]
    194e:	4613      	mov	r3, r2
    1950:	80fb      	strh	r3, [r7, #6]
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
    1952:	68fb      	ldr	r3, [r7, #12]
    1954:	3b14      	subs	r3, #20
    1956:	627b      	str	r3, [r7, #36]	; 0x24
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
    1958:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    195a:	8b9b      	ldrh	r3, [r3, #28]
    195c:	82bb      	strh	r3, [r7, #20]
	msg.len    = n;
    195e:	88fb      	ldrh	r3, [r7, #6]
    1960:	61bb      	str	r3, [r7, #24]
	msg.flags  = I2C_M_STOP;
    1962:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    1966:	82fb      	strh	r3, [r7, #22]
	msg.buffer = (uint8_t *)buf;
    1968:	68bb      	ldr	r3, [r7, #8]
    196a:	61fb      	str	r3, [r7, #28]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
    196c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    196e:	f107 0214 	add.w	r2, r7, #20
    1972:	4611      	mov	r1, r2
    1974:	4618      	mov	r0, r3
    1976:	4b06      	ldr	r3, [pc, #24]	; (1990 <i2c_m_sync_write+0x4c>)
    1978:	4798      	blx	r3
    197a:	6238      	str	r0, [r7, #32]

	if (ret) {
    197c:	6a3b      	ldr	r3, [r7, #32]
    197e:	2b00      	cmp	r3, #0
    1980:	d001      	beq.n	1986 <i2c_m_sync_write+0x42>
		return ret;
    1982:	6a3b      	ldr	r3, [r7, #32]
    1984:	e000      	b.n	1988 <i2c_m_sync_write+0x44>
	}

	return n;
    1986:	88fb      	ldrh	r3, [r7, #6]
}
    1988:	4618      	mov	r0, r3
    198a:	3728      	adds	r7, #40	; 0x28
    198c:	46bd      	mov	sp, r7
    198e:	bd80      	pop	{r7, pc}
    1990:	00003f15 	.word	0x00003f15

00001994 <i2c_m_sync_init>:

/**
 * \brief Sync version of i2c initialize
 */
int32_t i2c_m_sync_init(struct i2c_m_sync_desc *i2c, void *hw)
{
    1994:	b580      	push	{r7, lr}
    1996:	b084      	sub	sp, #16
    1998:	af00      	add	r7, sp, #0
    199a:	6078      	str	r0, [r7, #4]
    199c:	6039      	str	r1, [r7, #0]
	int32_t init_status;
	ASSERT(i2c);
    199e:	687b      	ldr	r3, [r7, #4]
    19a0:	2b00      	cmp	r3, #0
    19a2:	bf14      	ite	ne
    19a4:	2301      	movne	r3, #1
    19a6:	2300      	moveq	r3, #0
    19a8:	b2db      	uxtb	r3, r3
    19aa:	225e      	movs	r2, #94	; 0x5e
    19ac:	490c      	ldr	r1, [pc, #48]	; (19e0 <i2c_m_sync_init+0x4c>)
    19ae:	4618      	mov	r0, r3
    19b0:	4b0c      	ldr	r3, [pc, #48]	; (19e4 <i2c_m_sync_init+0x50>)
    19b2:	4798      	blx	r3

	init_status = _i2c_m_sync_init(&i2c->device, hw);
    19b4:	687b      	ldr	r3, [r7, #4]
    19b6:	6839      	ldr	r1, [r7, #0]
    19b8:	4618      	mov	r0, r3
    19ba:	4b0b      	ldr	r3, [pc, #44]	; (19e8 <i2c_m_sync_init+0x54>)
    19bc:	4798      	blx	r3
    19be:	60f8      	str	r0, [r7, #12]
	if (init_status) {
    19c0:	68fb      	ldr	r3, [r7, #12]
    19c2:	2b00      	cmp	r3, #0
    19c4:	d001      	beq.n	19ca <i2c_m_sync_init+0x36>
		return init_status;
    19c6:	68fb      	ldr	r3, [r7, #12]
    19c8:	e006      	b.n	19d8 <i2c_m_sync_init+0x44>
	}

	/* Init I/O */
	i2c->io.read  = i2c_m_sync_read;
    19ca:	687b      	ldr	r3, [r7, #4]
    19cc:	4a07      	ldr	r2, [pc, #28]	; (19ec <i2c_m_sync_init+0x58>)
    19ce:	619a      	str	r2, [r3, #24]
	i2c->io.write = i2c_m_sync_write;
    19d0:	687b      	ldr	r3, [r7, #4]
    19d2:	4a07      	ldr	r2, [pc, #28]	; (19f0 <i2c_m_sync_init+0x5c>)
    19d4:	615a      	str	r2, [r3, #20]

	return ERR_NONE;
    19d6:	2300      	movs	r3, #0
}
    19d8:	4618      	mov	r0, r3
    19da:	3710      	adds	r7, #16
    19dc:	46bd      	mov	sp, r7
    19de:	bd80      	pop	{r7, pc}
    19e0:	00005590 	.word	0x00005590
    19e4:	00001c39 	.word	0x00001c39
    19e8:	00003d11 	.word	0x00003d11
    19ec:	000018f5 	.word	0x000018f5
    19f0:	00001945 	.word	0x00001945

000019f4 <i2c_m_sync_enable>:

/**
 * \brief Sync version of i2c enable
 */
int32_t i2c_m_sync_enable(struct i2c_m_sync_desc *i2c)
{
    19f4:	b580      	push	{r7, lr}
    19f6:	b082      	sub	sp, #8
    19f8:	af00      	add	r7, sp, #0
    19fa:	6078      	str	r0, [r7, #4]
	return _i2c_m_sync_enable(&i2c->device);
    19fc:	687b      	ldr	r3, [r7, #4]
    19fe:	4618      	mov	r0, r3
    1a00:	4b03      	ldr	r3, [pc, #12]	; (1a10 <i2c_m_sync_enable+0x1c>)
    1a02:	4798      	blx	r3
    1a04:	4603      	mov	r3, r0
}
    1a06:	4618      	mov	r0, r3
    1a08:	3708      	adds	r7, #8
    1a0a:	46bd      	mov	sp, r7
    1a0c:	bd80      	pop	{r7, pc}
    1a0e:	bf00      	nop
    1a10:	00003d59 	.word	0x00003d59

00001a14 <i2c_m_sync_set_slaveaddr>:

/**
 * \brief Sync version of i2c set slave address
 */
int32_t i2c_m_sync_set_slaveaddr(struct i2c_m_sync_desc *i2c, int16_t addr, int32_t addr_len)
{
    1a14:	b480      	push	{r7}
    1a16:	b085      	sub	sp, #20
    1a18:	af00      	add	r7, sp, #0
    1a1a:	60f8      	str	r0, [r7, #12]
    1a1c:	460b      	mov	r3, r1
    1a1e:	607a      	str	r2, [r7, #4]
    1a20:	817b      	strh	r3, [r7, #10]
	return i2c->slave_addr = (addr & 0x3ff) | (addr_len & I2C_M_TEN);
    1a22:	897b      	ldrh	r3, [r7, #10]
    1a24:	f3c3 0309 	ubfx	r3, r3, #0, #10
    1a28:	b21a      	sxth	r2, r3
    1a2a:	687b      	ldr	r3, [r7, #4]
    1a2c:	b21b      	sxth	r3, r3
    1a2e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    1a32:	b21b      	sxth	r3, r3
    1a34:	4313      	orrs	r3, r2
    1a36:	b21b      	sxth	r3, r3
    1a38:	b29a      	uxth	r2, r3
    1a3a:	68fb      	ldr	r3, [r7, #12]
    1a3c:	839a      	strh	r2, [r3, #28]
    1a3e:	68fb      	ldr	r3, [r7, #12]
    1a40:	8b9b      	ldrh	r3, [r3, #28]
}
    1a42:	4618      	mov	r0, r3
    1a44:	3714      	adds	r7, #20
    1a46:	46bd      	mov	sp, r7
    1a48:	f85d 7b04 	ldr.w	r7, [sp], #4
    1a4c:	4770      	bx	lr

00001a4e <i2c_m_sync_get_io_descriptor>:

/**
 * \brief Retrieve I/O descriptor
 */
int32_t i2c_m_sync_get_io_descriptor(struct i2c_m_sync_desc *const i2c, struct io_descriptor **io)
{
    1a4e:	b480      	push	{r7}
    1a50:	b083      	sub	sp, #12
    1a52:	af00      	add	r7, sp, #0
    1a54:	6078      	str	r0, [r7, #4]
    1a56:	6039      	str	r1, [r7, #0]
	*io = &i2c->io;
    1a58:	687b      	ldr	r3, [r7, #4]
    1a5a:	f103 0214 	add.w	r2, r3, #20
    1a5e:	683b      	ldr	r3, [r7, #0]
    1a60:	601a      	str	r2, [r3, #0]
	return ERR_NONE;
    1a62:	2300      	movs	r3, #0
}
    1a64:	4618      	mov	r0, r3
    1a66:	370c      	adds	r7, #12
    1a68:	46bd      	mov	sp, r7
    1a6a:	f85d 7b04 	ldr.w	r7, [sp], #4
    1a6e:	4770      	bx	lr

00001a70 <delay_init>:

/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
    1a70:	b580      	push	{r7, lr}
    1a72:	b082      	sub	sp, #8
    1a74:	af00      	add	r7, sp, #0
    1a76:	6078      	str	r0, [r7, #4]
	_delay_init(hardware = hw);
    1a78:	4a05      	ldr	r2, [pc, #20]	; (1a90 <delay_init+0x20>)
    1a7a:	687b      	ldr	r3, [r7, #4]
    1a7c:	6013      	str	r3, [r2, #0]
    1a7e:	4b04      	ldr	r3, [pc, #16]	; (1a90 <delay_init+0x20>)
    1a80:	681b      	ldr	r3, [r3, #0]
    1a82:	4618      	mov	r0, r3
    1a84:	4b03      	ldr	r3, [pc, #12]	; (1a94 <delay_init+0x24>)
    1a86:	4798      	blx	r3
}
    1a88:	bf00      	nop
    1a8a:	3708      	adds	r7, #8
    1a8c:	46bd      	mov	sp, r7
    1a8e:	bd80      	pop	{r7, pc}
    1a90:	20000510 	.word	0x20000510
    1a94:	00001325 	.word	0x00001325

00001a98 <delay_ms>:

/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
    1a98:	b590      	push	{r4, r7, lr}
    1a9a:	b083      	sub	sp, #12
    1a9c:	af00      	add	r7, sp, #0
    1a9e:	4603      	mov	r3, r0
    1aa0:	80fb      	strh	r3, [r7, #6]
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
    1aa2:	4b07      	ldr	r3, [pc, #28]	; (1ac0 <delay_ms+0x28>)
    1aa4:	681c      	ldr	r4, [r3, #0]
    1aa6:	88fb      	ldrh	r3, [r7, #6]
    1aa8:	4618      	mov	r0, r3
    1aaa:	4b06      	ldr	r3, [pc, #24]	; (1ac4 <delay_ms+0x2c>)
    1aac:	4798      	blx	r3
    1aae:	4603      	mov	r3, r0
    1ab0:	4619      	mov	r1, r3
    1ab2:	4620      	mov	r0, r4
    1ab4:	4b04      	ldr	r3, [pc, #16]	; (1ac8 <delay_ms+0x30>)
    1ab6:	4798      	blx	r3
}
    1ab8:	bf00      	nop
    1aba:	370c      	adds	r7, #12
    1abc:	46bd      	mov	sp, r7
    1abe:	bd90      	pop	{r4, r7, pc}
    1ac0:	20000510 	.word	0x20000510
    1ac4:	00001739 	.word	0x00001739
    1ac8:	00001341 	.word	0x00001341

00001acc <hri_nvmctrl_set_CTRLA_RWS_bf>:
	tmp = (tmp & NVMCTRL_CTRLA_PRM_Msk) >> NVMCTRL_CTRLA_PRM_Pos;
	return tmp;
}

static inline void hri_nvmctrl_set_CTRLA_RWS_bf(const void *const hw, hri_nvmctrl_ctrla_reg_t mask)
{
    1acc:	b480      	push	{r7}
    1ace:	b083      	sub	sp, #12
    1ad0:	af00      	add	r7, sp, #0
    1ad2:	6078      	str	r0, [r7, #4]
    1ad4:	460b      	mov	r3, r1
    1ad6:	807b      	strh	r3, [r7, #2]
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLA.reg |= NVMCTRL_CTRLA_RWS(mask);
    1ad8:	687b      	ldr	r3, [r7, #4]
    1ada:	881b      	ldrh	r3, [r3, #0]
    1adc:	b29a      	uxth	r2, r3
    1ade:	887b      	ldrh	r3, [r7, #2]
    1ae0:	021b      	lsls	r3, r3, #8
    1ae2:	b29b      	uxth	r3, r3
    1ae4:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
    1ae8:	b29b      	uxth	r3, r3
    1aea:	4313      	orrs	r3, r2
    1aec:	b29a      	uxth	r2, r3
    1aee:	687b      	ldr	r3, [r7, #4]
    1af0:	801a      	strh	r2, [r3, #0]
	NVMCTRL_CRITICAL_SECTION_LEAVE();
}
    1af2:	bf00      	nop
    1af4:	370c      	adds	r7, #12
    1af6:	46bd      	mov	sp, r7
    1af8:	f85d 7b04 	ldr.w	r7, [sp], #4
    1afc:	4770      	bx	lr
	...

00001b00 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    1b00:	b580      	push	{r7, lr}
    1b02:	af00      	add	r7, sp, #0
	hri_nvmctrl_set_CTRLA_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);
    1b04:	2100      	movs	r1, #0
    1b06:	480b      	ldr	r0, [pc, #44]	; (1b34 <_init_chip+0x34>)
    1b08:	4b0b      	ldr	r3, [pc, #44]	; (1b38 <_init_chip+0x38>)
    1b0a:	4798      	blx	r3

	_osc32kctrl_init_sources();
    1b0c:	4b0b      	ldr	r3, [pc, #44]	; (1b3c <_init_chip+0x3c>)
    1b0e:	4798      	blx	r3
	_oscctrl_init_sources();
    1b10:	4b0b      	ldr	r3, [pc, #44]	; (1b40 <_init_chip+0x40>)
    1b12:	4798      	blx	r3
	_mclk_init();
    1b14:	4b0b      	ldr	r3, [pc, #44]	; (1b44 <_init_chip+0x44>)
    1b16:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    1b18:	2008      	movs	r0, #8
    1b1a:	4b0b      	ldr	r3, [pc, #44]	; (1b48 <_init_chip+0x48>)
    1b1c:	4798      	blx	r3
#endif
	_oscctrl_init_referenced_generators();
    1b1e:	4b0b      	ldr	r3, [pc, #44]	; (1b4c <_init_chip+0x4c>)
    1b20:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    1b22:	f640 70f7 	movw	r0, #4087	; 0xff7
    1b26:	4b08      	ldr	r3, [pc, #32]	; (1b48 <_init_chip+0x48>)
    1b28:	4798      	blx	r3
#if (CONF_PORT_EVCTRL_PORT_0 | CONF_PORT_EVCTRL_PORT_1 | CONF_PORT_EVCTRL_PORT_2 | CONF_PORT_EVCTRL_PORT_3)
	_port_event_init();
#endif

#if CONF_CMCC_ENABLE
	cache_init();
    1b2a:	4b09      	ldr	r3, [pc, #36]	; (1b50 <_init_chip+0x50>)
    1b2c:	4798      	blx	r3
#endif
}
    1b2e:	bf00      	nop
    1b30:	bd80      	pop	{r7, pc}
    1b32:	bf00      	nop
    1b34:	41004000 	.word	0x41004000
    1b38:	00001acd 	.word	0x00001acd
    1b3c:	0000238d 	.word	0x0000238d
    1b40:	00001ef5 	.word	0x00001ef5
    1b44:	00002261 	.word	0x00002261
    1b48:	00001bad 	.word	0x00001bad
    1b4c:	00001f11 	.word	0x00001f11
    1b50:	0000471d 	.word	0x0000471d

00001b54 <hri_gclk_wait_for_sync>:
typedef uint32_t hri_gclk_pchctrl_reg_t;
typedef uint32_t hri_gclk_syncbusy_reg_t;
typedef uint8_t  hri_gclk_ctrla_reg_t;

static inline void hri_gclk_wait_for_sync(const void *const hw, hri_gclk_syncbusy_reg_t reg)
{
    1b54:	b480      	push	{r7}
    1b56:	b083      	sub	sp, #12
    1b58:	af00      	add	r7, sp, #0
    1b5a:	6078      	str	r0, [r7, #4]
    1b5c:	6039      	str	r1, [r7, #0]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    1b5e:	bf00      	nop
    1b60:	687b      	ldr	r3, [r7, #4]
    1b62:	685a      	ldr	r2, [r3, #4]
    1b64:	683b      	ldr	r3, [r7, #0]
    1b66:	4013      	ands	r3, r2
    1b68:	2b00      	cmp	r3, #0
    1b6a:	d1f9      	bne.n	1b60 <hri_gclk_wait_for_sync+0xc>
	};
}
    1b6c:	bf00      	nop
    1b6e:	bf00      	nop
    1b70:	370c      	adds	r7, #12
    1b72:	46bd      	mov	sp, r7
    1b74:	f85d 7b04 	ldr.w	r7, [sp], #4
    1b78:	4770      	bx	lr
	...

00001b7c <hri_gclk_write_GENCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gclk_write_GENCTRL_reg(const void *const hw, uint8_t index, hri_gclk_genctrl_reg_t data)
{
    1b7c:	b580      	push	{r7, lr}
    1b7e:	b084      	sub	sp, #16
    1b80:	af00      	add	r7, sp, #0
    1b82:	60f8      	str	r0, [r7, #12]
    1b84:	460b      	mov	r3, r1
    1b86:	607a      	str	r2, [r7, #4]
    1b88:	72fb      	strb	r3, [r7, #11]
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENCTRL[index].reg = data;
    1b8a:	7afa      	ldrb	r2, [r7, #11]
    1b8c:	68fb      	ldr	r3, [r7, #12]
    1b8e:	3208      	adds	r2, #8
    1b90:	6879      	ldr	r1, [r7, #4]
    1b92:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    1b96:	f643 71fd 	movw	r1, #16381	; 0x3ffd
    1b9a:	68f8      	ldr	r0, [r7, #12]
    1b9c:	4b02      	ldr	r3, [pc, #8]	; (1ba8 <hri_gclk_write_GENCTRL_reg+0x2c>)
    1b9e:	4798      	blx	r3
	GCLK_CRITICAL_SECTION_LEAVE();
}
    1ba0:	bf00      	nop
    1ba2:	3710      	adds	r7, #16
    1ba4:	46bd      	mov	sp, r7
    1ba6:	bd80      	pop	{r7, pc}
    1ba8:	00001b55 	.word	0x00001b55

00001bac <_gclk_init_generators_by_fref>:
	        | (CONF_GCLK_GENERATOR_11_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_11_SOURCE);
#endif
}

void _gclk_init_generators_by_fref(uint32_t bm)
{
    1bac:	b580      	push	{r7, lr}
    1bae:	b082      	sub	sp, #8
    1bb0:	af00      	add	r7, sp, #0
    1bb2:	6078      	str	r0, [r7, #4]

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
    1bb4:	687b      	ldr	r3, [r7, #4]
    1bb6:	f003 0301 	and.w	r3, r3, #1
    1bba:	2b00      	cmp	r3, #0
    1bbc:	d004      	beq.n	1bc8 <_gclk_init_generators_by_fref+0x1c>
		hri_gclk_write_GENCTRL_reg(
    1bbe:	4a18      	ldr	r2, [pc, #96]	; (1c20 <_gclk_init_generators_by_fref+0x74>)
    1bc0:	2100      	movs	r1, #0
    1bc2:	4818      	ldr	r0, [pc, #96]	; (1c24 <_gclk_init_generators_by_fref+0x78>)
    1bc4:	4b18      	ldr	r3, [pc, #96]	; (1c28 <_gclk_init_generators_by_fref+0x7c>)
    1bc6:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_0_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_0_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_1_CONFIG == 1
	if (bm & (1ul << 1)) {
    1bc8:	687b      	ldr	r3, [r7, #4]
    1bca:	f003 0302 	and.w	r3, r3, #2
    1bce:	2b00      	cmp	r3, #0
    1bd0:	d004      	beq.n	1bdc <_gclk_init_generators_by_fref+0x30>
		hri_gclk_write_GENCTRL_reg(
    1bd2:	4a16      	ldr	r2, [pc, #88]	; (1c2c <_gclk_init_generators_by_fref+0x80>)
    1bd4:	2101      	movs	r1, #1
    1bd6:	4813      	ldr	r0, [pc, #76]	; (1c24 <_gclk_init_generators_by_fref+0x78>)
    1bd8:	4b13      	ldr	r3, [pc, #76]	; (1c28 <_gclk_init_generators_by_fref+0x7c>)
    1bda:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_1_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_1_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_2_CONFIG == 1
	if (bm & (1ul << 2)) {
    1bdc:	687b      	ldr	r3, [r7, #4]
    1bde:	f003 0304 	and.w	r3, r3, #4
    1be2:	2b00      	cmp	r3, #0
    1be4:	d004      	beq.n	1bf0 <_gclk_init_generators_by_fref+0x44>
		hri_gclk_write_GENCTRL_reg(
    1be6:	4a12      	ldr	r2, [pc, #72]	; (1c30 <_gclk_init_generators_by_fref+0x84>)
    1be8:	2102      	movs	r1, #2
    1bea:	480e      	ldr	r0, [pc, #56]	; (1c24 <_gclk_init_generators_by_fref+0x78>)
    1bec:	4b0e      	ldr	r3, [pc, #56]	; (1c28 <_gclk_init_generators_by_fref+0x7c>)
    1bee:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_2_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_2_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_3_CONFIG == 1
	if (bm & (1ul << 3)) {
    1bf0:	687b      	ldr	r3, [r7, #4]
    1bf2:	f003 0308 	and.w	r3, r3, #8
    1bf6:	2b00      	cmp	r3, #0
    1bf8:	d004      	beq.n	1c04 <_gclk_init_generators_by_fref+0x58>
		hri_gclk_write_GENCTRL_reg(
    1bfa:	4a0e      	ldr	r2, [pc, #56]	; (1c34 <_gclk_init_generators_by_fref+0x88>)
    1bfc:	2103      	movs	r1, #3
    1bfe:	4809      	ldr	r0, [pc, #36]	; (1c24 <_gclk_init_generators_by_fref+0x78>)
    1c00:	4b09      	ldr	r3, [pc, #36]	; (1c28 <_gclk_init_generators_by_fref+0x7c>)
    1c02:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_3_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_3_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_4_CONFIG == 1
	if (bm & (1ul << 4)) {
    1c04:	687b      	ldr	r3, [r7, #4]
    1c06:	f003 0310 	and.w	r3, r3, #16
    1c0a:	2b00      	cmp	r3, #0
    1c0c:	d004      	beq.n	1c18 <_gclk_init_generators_by_fref+0x6c>
		hri_gclk_write_GENCTRL_reg(
    1c0e:	4a09      	ldr	r2, [pc, #36]	; (1c34 <_gclk_init_generators_by_fref+0x88>)
    1c10:	2104      	movs	r1, #4
    1c12:	4804      	ldr	r0, [pc, #16]	; (1c24 <_gclk_init_generators_by_fref+0x78>)
    1c14:	4b04      	ldr	r3, [pc, #16]	; (1c28 <_gclk_init_generators_by_fref+0x7c>)
    1c16:	4798      	blx	r3
		        | (CONF_GCLK_GEN_11_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_11_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_11_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_11_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_11_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_11_SOURCE);
	}
#endif
}
    1c18:	bf00      	nop
    1c1a:	3708      	adds	r7, #8
    1c1c:	46bd      	mov	sp, r7
    1c1e:	bd80      	pop	{r7, pc}
    1c20:	00200106 	.word	0x00200106
    1c24:	40001c00 	.word	0x40001c00
    1c28:	00001b7d 	.word	0x00001b7d
    1c2c:	00082106 	.word	0x00082106
    1c30:	00011106 	.word	0x00011106
    1c34:	00010104 	.word	0x00010104

00001c38 <assert>:

/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
    1c38:	b480      	push	{r7}
    1c3a:	b085      	sub	sp, #20
    1c3c:	af00      	add	r7, sp, #0
    1c3e:	4603      	mov	r3, r0
    1c40:	60b9      	str	r1, [r7, #8]
    1c42:	607a      	str	r2, [r7, #4]
    1c44:	73fb      	strb	r3, [r7, #15]
	if (!(condition)) {
    1c46:	7bfb      	ldrb	r3, [r7, #15]
    1c48:	f083 0301 	eor.w	r3, r3, #1
    1c4c:	b2db      	uxtb	r3, r3
    1c4e:	2b00      	cmp	r3, #0
    1c50:	d000      	beq.n	1c54 <assert+0x1c>
		__asm("BKPT #0");
    1c52:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
    1c54:	bf00      	nop
    1c56:	3714      	adds	r7, #20
    1c58:	46bd      	mov	sp, r7
    1c5a:	f85d 7b04 	ldr.w	r7, [sp], #4
    1c5e:	4770      	bx	lr

00001c60 <hri_gclk_wait_for_sync>:
{
    1c60:	b480      	push	{r7}
    1c62:	b083      	sub	sp, #12
    1c64:	af00      	add	r7, sp, #0
    1c66:	6078      	str	r0, [r7, #4]
    1c68:	6039      	str	r1, [r7, #0]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    1c6a:	bf00      	nop
    1c6c:	687b      	ldr	r3, [r7, #4]
    1c6e:	685a      	ldr	r2, [r3, #4]
    1c70:	683b      	ldr	r3, [r7, #0]
    1c72:	4013      	ands	r3, r2
    1c74:	2b00      	cmp	r3, #0
    1c76:	d1f9      	bne.n	1c6c <hri_gclk_wait_for_sync+0xc>
}
    1c78:	bf00      	nop
    1c7a:	bf00      	nop
    1c7c:	370c      	adds	r7, #12
    1c7e:	46bd      	mov	sp, r7
    1c80:	f85d 7b04 	ldr.w	r7, [sp], #4
    1c84:	4770      	bx	lr

00001c86 <hri_gclk_get_SYNCBUSY_GENCTRL0_bit>:
{
    1c86:	b480      	push	{r7}
    1c88:	b083      	sub	sp, #12
    1c8a:	af00      	add	r7, sp, #0
    1c8c:	6078      	str	r0, [r7, #4]
	return (((Gclk *)hw)->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL0) >> GCLK_SYNCBUSY_GENCTRL0_Pos;
    1c8e:	687b      	ldr	r3, [r7, #4]
    1c90:	685b      	ldr	r3, [r3, #4]
    1c92:	089b      	lsrs	r3, r3, #2
    1c94:	f003 0301 	and.w	r3, r3, #1
    1c98:	2b00      	cmp	r3, #0
    1c9a:	bf14      	ite	ne
    1c9c:	2301      	movne	r3, #1
    1c9e:	2300      	moveq	r3, #0
    1ca0:	b2db      	uxtb	r3, r3
}
    1ca2:	4618      	mov	r0, r3
    1ca4:	370c      	adds	r7, #12
    1ca6:	46bd      	mov	sp, r7
    1ca8:	f85d 7b04 	ldr.w	r7, [sp], #4
    1cac:	4770      	bx	lr

00001cae <hri_gclk_read_SYNCBUSY_reg>:
{
    1cae:	b480      	push	{r7}
    1cb0:	b083      	sub	sp, #12
    1cb2:	af00      	add	r7, sp, #0
    1cb4:	6078      	str	r0, [r7, #4]
	return ((Gclk *)hw)->SYNCBUSY.reg;
    1cb6:	687b      	ldr	r3, [r7, #4]
    1cb8:	685b      	ldr	r3, [r3, #4]
}
    1cba:	4618      	mov	r0, r3
    1cbc:	370c      	adds	r7, #12
    1cbe:	46bd      	mov	sp, r7
    1cc0:	f85d 7b04 	ldr.w	r7, [sp], #4
    1cc4:	4770      	bx	lr
	...

00001cc8 <hri_gclk_write_GENCTRL_SRC_bf>:
{
    1cc8:	b580      	push	{r7, lr}
    1cca:	b086      	sub	sp, #24
    1ccc:	af00      	add	r7, sp, #0
    1cce:	60f8      	str	r0, [r7, #12]
    1cd0:	460b      	mov	r3, r1
    1cd2:	607a      	str	r2, [r7, #4]
    1cd4:	72fb      	strb	r3, [r7, #11]
	tmp = ((Gclk *)hw)->GENCTRL[index].reg;
    1cd6:	7afa      	ldrb	r2, [r7, #11]
    1cd8:	68fb      	ldr	r3, [r7, #12]
    1cda:	3208      	adds	r2, #8
    1cdc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    1ce0:	617b      	str	r3, [r7, #20]
	tmp &= ~GCLK_GENCTRL_SRC_Msk;
    1ce2:	697b      	ldr	r3, [r7, #20]
    1ce4:	f023 030f 	bic.w	r3, r3, #15
    1ce8:	617b      	str	r3, [r7, #20]
	tmp |= GCLK_GENCTRL_SRC(data);
    1cea:	687b      	ldr	r3, [r7, #4]
    1cec:	f003 030f 	and.w	r3, r3, #15
    1cf0:	697a      	ldr	r2, [r7, #20]
    1cf2:	4313      	orrs	r3, r2
    1cf4:	617b      	str	r3, [r7, #20]
	((Gclk *)hw)->GENCTRL[index].reg = tmp;
    1cf6:	7afa      	ldrb	r2, [r7, #11]
    1cf8:	68fb      	ldr	r3, [r7, #12]
    1cfa:	3208      	adds	r2, #8
    1cfc:	6979      	ldr	r1, [r7, #20]
    1cfe:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    1d02:	f643 71fd 	movw	r1, #16381	; 0x3ffd
    1d06:	68f8      	ldr	r0, [r7, #12]
    1d08:	4b02      	ldr	r3, [pc, #8]	; (1d14 <hri_gclk_write_GENCTRL_SRC_bf+0x4c>)
    1d0a:	4798      	blx	r3
}
    1d0c:	bf00      	nop
    1d0e:	3718      	adds	r7, #24
    1d10:	46bd      	mov	sp, r7
    1d12:	bd80      	pop	{r7, pc}
    1d14:	00001c61 	.word	0x00001c61

00001d18 <hri_oscctrl_get_STATUS_DFLLRDY_bit>:
{
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCCKSW1) >> OSCCTRL_STATUS_XOSCCKSW1_Pos;
}

static inline bool hri_oscctrl_get_STATUS_DFLLRDY_bit(const void *const hw)
{
    1d18:	b480      	push	{r7}
    1d1a:	b083      	sub	sp, #12
    1d1c:	af00      	add	r7, sp, #0
    1d1e:	6078      	str	r0, [r7, #4]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_DFLLRDY) >> OSCCTRL_STATUS_DFLLRDY_Pos;
    1d20:	687b      	ldr	r3, [r7, #4]
    1d22:	691b      	ldr	r3, [r3, #16]
    1d24:	0a1b      	lsrs	r3, r3, #8
    1d26:	f003 0301 	and.w	r3, r3, #1
    1d2a:	2b00      	cmp	r3, #0
    1d2c:	bf14      	ite	ne
    1d2e:	2301      	movne	r3, #1
    1d30:	2300      	moveq	r3, #0
    1d32:	b2db      	uxtb	r3, r3
}
    1d34:	4618      	mov	r0, r3
    1d36:	370c      	adds	r7, #12
    1d38:	46bd      	mov	sp, r7
    1d3a:	f85d 7b04 	ldr.w	r7, [sp], #4
    1d3e:	4770      	bx	lr

00001d40 <hri_oscctrl_get_STATUS_reg>:
{
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_DPLL1LDRTO) >> OSCCTRL_STATUS_DPLL1LDRTO_Pos;
}

static inline hri_oscctrl_status_reg_t hri_oscctrl_get_STATUS_reg(const void *const hw, hri_oscctrl_status_reg_t mask)
{
    1d40:	b480      	push	{r7}
    1d42:	b085      	sub	sp, #20
    1d44:	af00      	add	r7, sp, #0
    1d46:	6078      	str	r0, [r7, #4]
    1d48:	6039      	str	r1, [r7, #0]
	uint32_t tmp;
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    1d4a:	687b      	ldr	r3, [r7, #4]
    1d4c:	691b      	ldr	r3, [r3, #16]
    1d4e:	60fb      	str	r3, [r7, #12]
	tmp &= mask;
    1d50:	68fa      	ldr	r2, [r7, #12]
    1d52:	683b      	ldr	r3, [r7, #0]
    1d54:	4013      	ands	r3, r2
    1d56:	60fb      	str	r3, [r7, #12]
	return tmp;
    1d58:	68fb      	ldr	r3, [r7, #12]
}
    1d5a:	4618      	mov	r0, r3
    1d5c:	3714      	adds	r7, #20
    1d5e:	46bd      	mov	sp, r7
    1d60:	f85d 7b04 	ldr.w	r7, [sp], #4
    1d64:	4770      	bx	lr

00001d66 <hri_oscctrl_write_DFLLCTRLA_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_oscctrl_write_DFLLCTRLA_reg(const void *const hw, hri_oscctrl_dfllctrla_reg_t data)
{
    1d66:	b480      	push	{r7}
    1d68:	b083      	sub	sp, #12
    1d6a:	af00      	add	r7, sp, #0
    1d6c:	6078      	str	r0, [r7, #4]
    1d6e:	460b      	mov	r3, r1
    1d70:	70fb      	strb	r3, [r7, #3]
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->DFLLCTRLA.reg = data;
    1d72:	687b      	ldr	r3, [r7, #4]
    1d74:	78fa      	ldrb	r2, [r7, #3]
    1d76:	771a      	strb	r2, [r3, #28]
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}
    1d78:	bf00      	nop
    1d7a:	370c      	adds	r7, #12
    1d7c:	46bd      	mov	sp, r7
    1d7e:	f85d 7b04 	ldr.w	r7, [sp], #4
    1d82:	4770      	bx	lr

00001d84 <hri_oscctrl_get_DFLLCTRLB_MODE_bit>:
	((Oscctrl *)hw)->DFLLCTRLB.reg |= OSCCTRL_DFLLCTRLB_MODE;
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_oscctrl_get_DFLLCTRLB_MODE_bit(const void *const hw)
{
    1d84:	b480      	push	{r7}
    1d86:	b085      	sub	sp, #20
    1d88:	af00      	add	r7, sp, #0
    1d8a:	6078      	str	r0, [r7, #4]
	uint8_t tmp;
	tmp = ((Oscctrl *)hw)->DFLLCTRLB.reg;
    1d8c:	687b      	ldr	r3, [r7, #4]
    1d8e:	f893 3020 	ldrb.w	r3, [r3, #32]
    1d92:	73fb      	strb	r3, [r7, #15]
	tmp = (tmp & OSCCTRL_DFLLCTRLB_MODE) >> OSCCTRL_DFLLCTRLB_MODE_Pos;
    1d94:	7bfb      	ldrb	r3, [r7, #15]
    1d96:	f003 0301 	and.w	r3, r3, #1
    1d9a:	73fb      	strb	r3, [r7, #15]
	return (bool)tmp;
    1d9c:	7bfb      	ldrb	r3, [r7, #15]
    1d9e:	2b00      	cmp	r3, #0
    1da0:	bf14      	ite	ne
    1da2:	2301      	movne	r3, #1
    1da4:	2300      	moveq	r3, #0
    1da6:	b2db      	uxtb	r3, r3
}
    1da8:	4618      	mov	r0, r3
    1daa:	3714      	adds	r7, #20
    1dac:	46bd      	mov	sp, r7
    1dae:	f85d 7b04 	ldr.w	r7, [sp], #4
    1db2:	4770      	bx	lr

00001db4 <hri_oscctrl_write_DFLLCTRLB_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_oscctrl_write_DFLLCTRLB_reg(const void *const hw, hri_oscctrl_dfllctrlb_reg_t data)
{
    1db4:	b480      	push	{r7}
    1db6:	b083      	sub	sp, #12
    1db8:	af00      	add	r7, sp, #0
    1dba:	6078      	str	r0, [r7, #4]
    1dbc:	460b      	mov	r3, r1
    1dbe:	70fb      	strb	r3, [r7, #3]
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->DFLLCTRLB.reg = data;
    1dc0:	687b      	ldr	r3, [r7, #4]
    1dc2:	78fa      	ldrb	r2, [r7, #3]
    1dc4:	f883 2020 	strb.w	r2, [r3, #32]
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}
    1dc8:	bf00      	nop
    1dca:	370c      	adds	r7, #12
    1dcc:	46bd      	mov	sp, r7
    1dce:	f85d 7b04 	ldr.w	r7, [sp], #4
    1dd2:	4770      	bx	lr

00001dd4 <hri_oscctrl_write_DFLLVAL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_oscctrl_write_DFLLVAL_reg(const void *const hw, hri_oscctrl_dfllval_reg_t data)
{
    1dd4:	b480      	push	{r7}
    1dd6:	b083      	sub	sp, #12
    1dd8:	af00      	add	r7, sp, #0
    1dda:	6078      	str	r0, [r7, #4]
    1ddc:	6039      	str	r1, [r7, #0]
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->DFLLVAL.reg = data;
    1dde:	687b      	ldr	r3, [r7, #4]
    1de0:	683a      	ldr	r2, [r7, #0]
    1de2:	625a      	str	r2, [r3, #36]	; 0x24
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}
    1de4:	bf00      	nop
    1de6:	370c      	adds	r7, #12
    1de8:	46bd      	mov	sp, r7
    1dea:	f85d 7b04 	ldr.w	r7, [sp], #4
    1dee:	4770      	bx	lr

00001df0 <hri_oscctrl_read_DFLLVAL_reg>:
	((Oscctrl *)hw)->DFLLVAL.reg ^= mask;
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}

static inline hri_oscctrl_dfllval_reg_t hri_oscctrl_read_DFLLVAL_reg(const void *const hw)
{
    1df0:	b480      	push	{r7}
    1df2:	b083      	sub	sp, #12
    1df4:	af00      	add	r7, sp, #0
    1df6:	6078      	str	r0, [r7, #4]
	return ((Oscctrl *)hw)->DFLLVAL.reg;
    1df8:	687b      	ldr	r3, [r7, #4]
    1dfa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
    1dfc:	4618      	mov	r0, r3
    1dfe:	370c      	adds	r7, #12
    1e00:	46bd      	mov	sp, r7
    1e02:	f85d 7b04 	ldr.w	r7, [sp], #4
    1e06:	4770      	bx	lr

00001e08 <hri_oscctrl_write_DFLLMUL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_oscctrl_write_DFLLMUL_reg(const void *const hw, hri_oscctrl_dfllmul_reg_t data)
{
    1e08:	b480      	push	{r7}
    1e0a:	b083      	sub	sp, #12
    1e0c:	af00      	add	r7, sp, #0
    1e0e:	6078      	str	r0, [r7, #4]
    1e10:	6039      	str	r1, [r7, #0]
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->DFLLMUL.reg = data;
    1e12:	687b      	ldr	r3, [r7, #4]
    1e14:	683a      	ldr	r2, [r7, #0]
    1e16:	629a      	str	r2, [r3, #40]	; 0x28
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}
    1e18:	bf00      	nop
    1e1a:	370c      	adds	r7, #12
    1e1c:	46bd      	mov	sp, r7
    1e1e:	f85d 7b04 	ldr.w	r7, [sp], #4
    1e22:	4770      	bx	lr

00001e24 <hri_oscctrl_get_DFLLSYNC_ENABLE_bit>:
	((Oscctrl *)hw)->DFLLSYNC.reg |= OSCCTRL_DFLLSYNC_ENABLE;
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_oscctrl_get_DFLLSYNC_ENABLE_bit(const void *const hw)
{
    1e24:	b480      	push	{r7}
    1e26:	b085      	sub	sp, #20
    1e28:	af00      	add	r7, sp, #0
    1e2a:	6078      	str	r0, [r7, #4]
	uint8_t tmp;
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    1e2c:	687b      	ldr	r3, [r7, #4]
    1e2e:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    1e32:	73fb      	strb	r3, [r7, #15]
	tmp = (tmp & OSCCTRL_DFLLSYNC_ENABLE) >> OSCCTRL_DFLLSYNC_ENABLE_Pos;
    1e34:	7bfb      	ldrb	r3, [r7, #15]
    1e36:	085b      	lsrs	r3, r3, #1
    1e38:	b2db      	uxtb	r3, r3
    1e3a:	f003 0301 	and.w	r3, r3, #1
    1e3e:	73fb      	strb	r3, [r7, #15]
	return (bool)tmp;
    1e40:	7bfb      	ldrb	r3, [r7, #15]
    1e42:	2b00      	cmp	r3, #0
    1e44:	bf14      	ite	ne
    1e46:	2301      	movne	r3, #1
    1e48:	2300      	moveq	r3, #0
    1e4a:	b2db      	uxtb	r3, r3
}
    1e4c:	4618      	mov	r0, r3
    1e4e:	3714      	adds	r7, #20
    1e50:	46bd      	mov	sp, r7
    1e52:	f85d 7b04 	ldr.w	r7, [sp], #4
    1e56:	4770      	bx	lr

00001e58 <hri_oscctrl_get_DFLLSYNC_DFLLCTRLB_bit>:
	((Oscctrl *)hw)->DFLLSYNC.reg |= OSCCTRL_DFLLSYNC_DFLLCTRLB;
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_oscctrl_get_DFLLSYNC_DFLLCTRLB_bit(const void *const hw)
{
    1e58:	b480      	push	{r7}
    1e5a:	b085      	sub	sp, #20
    1e5c:	af00      	add	r7, sp, #0
    1e5e:	6078      	str	r0, [r7, #4]
	uint8_t tmp;
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    1e60:	687b      	ldr	r3, [r7, #4]
    1e62:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    1e66:	73fb      	strb	r3, [r7, #15]
	tmp = (tmp & OSCCTRL_DFLLSYNC_DFLLCTRLB) >> OSCCTRL_DFLLSYNC_DFLLCTRLB_Pos;
    1e68:	7bfb      	ldrb	r3, [r7, #15]
    1e6a:	089b      	lsrs	r3, r3, #2
    1e6c:	b2db      	uxtb	r3, r3
    1e6e:	f003 0301 	and.w	r3, r3, #1
    1e72:	73fb      	strb	r3, [r7, #15]
	return (bool)tmp;
    1e74:	7bfb      	ldrb	r3, [r7, #15]
    1e76:	2b00      	cmp	r3, #0
    1e78:	bf14      	ite	ne
    1e7a:	2301      	movne	r3, #1
    1e7c:	2300      	moveq	r3, #0
    1e7e:	b2db      	uxtb	r3, r3
}
    1e80:	4618      	mov	r0, r3
    1e82:	3714      	adds	r7, #20
    1e84:	46bd      	mov	sp, r7
    1e86:	f85d 7b04 	ldr.w	r7, [sp], #4
    1e8a:	4770      	bx	lr

00001e8c <hri_oscctrl_get_DFLLSYNC_DFLLVAL_bit>:
	((Oscctrl *)hw)->DFLLSYNC.reg |= OSCCTRL_DFLLSYNC_DFLLVAL;
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_oscctrl_get_DFLLSYNC_DFLLVAL_bit(const void *const hw)
{
    1e8c:	b480      	push	{r7}
    1e8e:	b085      	sub	sp, #20
    1e90:	af00      	add	r7, sp, #0
    1e92:	6078      	str	r0, [r7, #4]
	uint8_t tmp;
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    1e94:	687b      	ldr	r3, [r7, #4]
    1e96:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    1e9a:	73fb      	strb	r3, [r7, #15]
	tmp = (tmp & OSCCTRL_DFLLSYNC_DFLLVAL) >> OSCCTRL_DFLLSYNC_DFLLVAL_Pos;
    1e9c:	7bfb      	ldrb	r3, [r7, #15]
    1e9e:	08db      	lsrs	r3, r3, #3
    1ea0:	b2db      	uxtb	r3, r3
    1ea2:	f003 0301 	and.w	r3, r3, #1
    1ea6:	73fb      	strb	r3, [r7, #15]
	return (bool)tmp;
    1ea8:	7bfb      	ldrb	r3, [r7, #15]
    1eaa:	2b00      	cmp	r3, #0
    1eac:	bf14      	ite	ne
    1eae:	2301      	movne	r3, #1
    1eb0:	2300      	moveq	r3, #0
    1eb2:	b2db      	uxtb	r3, r3
}
    1eb4:	4618      	mov	r0, r3
    1eb6:	3714      	adds	r7, #20
    1eb8:	46bd      	mov	sp, r7
    1eba:	f85d 7b04 	ldr.w	r7, [sp], #4
    1ebe:	4770      	bx	lr

00001ec0 <hri_oscctrl_get_DFLLSYNC_DFLLMUL_bit>:
	((Oscctrl *)hw)->DFLLSYNC.reg |= OSCCTRL_DFLLSYNC_DFLLMUL;
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_oscctrl_get_DFLLSYNC_DFLLMUL_bit(const void *const hw)
{
    1ec0:	b480      	push	{r7}
    1ec2:	b085      	sub	sp, #20
    1ec4:	af00      	add	r7, sp, #0
    1ec6:	6078      	str	r0, [r7, #4]
	uint8_t tmp;
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    1ec8:	687b      	ldr	r3, [r7, #4]
    1eca:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    1ece:	73fb      	strb	r3, [r7, #15]
	tmp = (tmp & OSCCTRL_DFLLSYNC_DFLLMUL) >> OSCCTRL_DFLLSYNC_DFLLMUL_Pos;
    1ed0:	7bfb      	ldrb	r3, [r7, #15]
    1ed2:	091b      	lsrs	r3, r3, #4
    1ed4:	b2db      	uxtb	r3, r3
    1ed6:	f003 0301 	and.w	r3, r3, #1
    1eda:	73fb      	strb	r3, [r7, #15]
	return (bool)tmp;
    1edc:	7bfb      	ldrb	r3, [r7, #15]
    1ede:	2b00      	cmp	r3, #0
    1ee0:	bf14      	ite	ne
    1ee2:	2301      	movne	r3, #1
    1ee4:	2300      	moveq	r3, #0
    1ee6:	b2db      	uxtb	r3, r3
}
    1ee8:	4618      	mov	r0, r3
    1eea:	3714      	adds	r7, #20
    1eec:	46bd      	mov	sp, r7
    1eee:	f85d 7b04 	ldr.w	r7, [sp], #4
    1ef2:	4770      	bx	lr

00001ef4 <_oscctrl_init_sources>:

/**
 * \brief Initialize clock sources
 */
void _oscctrl_init_sources(void)
{
    1ef4:	b480      	push	{r7}
    1ef6:	b083      	sub	sp, #12
    1ef8:	af00      	add	r7, sp, #0
	void *hw = (void *)OSCCTRL;
    1efa:	4b04      	ldr	r3, [pc, #16]	; (1f0c <_oscctrl_init_sources+0x18>)
    1efc:	607b      	str	r3, [r7, #4]
	hri_oscctrl_set_XOSCCTRL_ONDEMAND_bit(hw, 1);
#endif
#endif

	(void)hw;
}
    1efe:	bf00      	nop
    1f00:	370c      	adds	r7, #12
    1f02:	46bd      	mov	sp, r7
    1f04:	f85d 7b04 	ldr.w	r7, [sp], #4
    1f08:	4770      	bx	lr
    1f0a:	bf00      	nop
    1f0c:	40001000 	.word	0x40001000

00001f10 <_oscctrl_init_referenced_generators>:

void _oscctrl_init_referenced_generators(void)
{
    1f10:	b580      	push	{r7, lr}
    1f12:	b084      	sub	sp, #16
    1f14:	af00      	add	r7, sp, #0
	void *hw = (void *)OSCCTRL;
    1f16:	4b44      	ldr	r3, [pc, #272]	; (2028 <_oscctrl_init_referenced_generators+0x118>)
    1f18:	60fb      	str	r3, [r7, #12]

#if CONF_DFLL_CONFIG == 1
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, GCLK_GENCTRL_SRC_OSCULP32K);
    1f1a:	2204      	movs	r2, #4
    1f1c:	2100      	movs	r1, #0
    1f1e:	4843      	ldr	r0, [pc, #268]	; (202c <_oscctrl_init_referenced_generators+0x11c>)
    1f20:	4b43      	ldr	r3, [pc, #268]	; (2030 <_oscctrl_init_referenced_generators+0x120>)
    1f22:	4798      	blx	r3
	while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
    1f24:	bf00      	nop
    1f26:	4841      	ldr	r0, [pc, #260]	; (202c <_oscctrl_init_referenced_generators+0x11c>)
    1f28:	4b42      	ldr	r3, [pc, #264]	; (2034 <_oscctrl_init_referenced_generators+0x124>)
    1f2a:	4798      	blx	r3
    1f2c:	4603      	mov	r3, r0
    1f2e:	2b00      	cmp	r3, #0
    1f30:	d1f9      	bne.n	1f26 <_oscctrl_init_referenced_generators+0x16>
		;
	uint8_t tmp;
	hri_oscctrl_write_DFLLCTRLA_reg(hw, 0);
    1f32:	2100      	movs	r1, #0
    1f34:	68f8      	ldr	r0, [r7, #12]
    1f36:	4b40      	ldr	r3, [pc, #256]	; (2038 <_oscctrl_init_referenced_generators+0x128>)
    1f38:	4798      	blx	r3
#if CONF_DFLL_USBCRM != 1 && CONF_DFLL_MODE != 0
	hri_gclk_write_PCHCTRL_reg(
	    GCLK, OSCCTRL_GCLK_ID_DFLL48, (1 << GCLK_PCHCTRL_CHEN_Pos) | GCLK_PCHCTRL_GEN(CONF_DFLL_GCLK));
#endif

	hri_oscctrl_write_DFLLMUL_reg(hw,
    1f3a:	4940      	ldr	r1, [pc, #256]	; (203c <_oscctrl_init_referenced_generators+0x12c>)
    1f3c:	68f8      	ldr	r0, [r7, #12]
    1f3e:	4b40      	ldr	r3, [pc, #256]	; (2040 <_oscctrl_init_referenced_generators+0x130>)
    1f40:	4798      	blx	r3
	                              OSCCTRL_DFLLMUL_CSTEP(CONF_DFLL_CSTEP) | OSCCTRL_DFLLMUL_FSTEP(CONF_DFLL_FSTEP)
	                                  | OSCCTRL_DFLLMUL_MUL(CONF_DFLL_MUL));
	while (hri_oscctrl_get_DFLLSYNC_DFLLMUL_bit(hw))
    1f42:	bf00      	nop
    1f44:	68f8      	ldr	r0, [r7, #12]
    1f46:	4b3f      	ldr	r3, [pc, #252]	; (2044 <_oscctrl_init_referenced_generators+0x134>)
    1f48:	4798      	blx	r3
    1f4a:	4603      	mov	r3, r0
    1f4c:	2b00      	cmp	r3, #0
    1f4e:	d1f9      	bne.n	1f44 <_oscctrl_init_referenced_generators+0x34>
		;

	hri_oscctrl_write_DFLLCTRLB_reg(hw, 0);
    1f50:	2100      	movs	r1, #0
    1f52:	68f8      	ldr	r0, [r7, #12]
    1f54:	4b3c      	ldr	r3, [pc, #240]	; (2048 <_oscctrl_init_referenced_generators+0x138>)
    1f56:	4798      	blx	r3
	while (hri_oscctrl_get_DFLLSYNC_DFLLCTRLB_bit(hw))
    1f58:	bf00      	nop
    1f5a:	68f8      	ldr	r0, [r7, #12]
    1f5c:	4b3b      	ldr	r3, [pc, #236]	; (204c <_oscctrl_init_referenced_generators+0x13c>)
    1f5e:	4798      	blx	r3
    1f60:	4603      	mov	r3, r0
    1f62:	2b00      	cmp	r3, #0
    1f64:	d1f9      	bne.n	1f5a <_oscctrl_init_referenced_generators+0x4a>
		;

	tmp = (CONF_DFLL_RUNSTDBY << OSCCTRL_DFLLCTRLA_RUNSTDBY_Pos) | OSCCTRL_DFLLCTRLA_ENABLE;
    1f66:	2302      	movs	r3, #2
    1f68:	72fb      	strb	r3, [r7, #11]
	hri_oscctrl_write_DFLLCTRLA_reg(hw, tmp);
    1f6a:	7afb      	ldrb	r3, [r7, #11]
    1f6c:	4619      	mov	r1, r3
    1f6e:	68f8      	ldr	r0, [r7, #12]
    1f70:	4b31      	ldr	r3, [pc, #196]	; (2038 <_oscctrl_init_referenced_generators+0x128>)
    1f72:	4798      	blx	r3
	while (hri_oscctrl_get_DFLLSYNC_ENABLE_bit(hw))
    1f74:	bf00      	nop
    1f76:	68f8      	ldr	r0, [r7, #12]
    1f78:	4b35      	ldr	r3, [pc, #212]	; (2050 <_oscctrl_init_referenced_generators+0x140>)
    1f7a:	4798      	blx	r3
    1f7c:	4603      	mov	r3, r0
    1f7e:	2b00      	cmp	r3, #0
    1f80:	d1f9      	bne.n	1f76 <_oscctrl_init_referenced_generators+0x66>
		;

#if CONF_DFLL_OVERWRITE_CALIBRATION == 1
	hri_oscctrl_write_DFLLVAL_reg(hw, OSCCTRL_DFLLVAL_COARSE(CONF_DFLL_COARSE) | OSCCTRL_DFLLVAL_FINE(CONF_DFLL_FINE));
#endif
	hri_oscctrl_write_DFLLVAL_reg(hw, hri_oscctrl_read_DFLLVAL_reg(hw));
    1f82:	68f8      	ldr	r0, [r7, #12]
    1f84:	4b33      	ldr	r3, [pc, #204]	; (2054 <_oscctrl_init_referenced_generators+0x144>)
    1f86:	4798      	blx	r3
    1f88:	4603      	mov	r3, r0
    1f8a:	4619      	mov	r1, r3
    1f8c:	68f8      	ldr	r0, [r7, #12]
    1f8e:	4b32      	ldr	r3, [pc, #200]	; (2058 <_oscctrl_init_referenced_generators+0x148>)
    1f90:	4798      	blx	r3
	while (hri_oscctrl_get_DFLLSYNC_DFLLVAL_bit(hw))
    1f92:	bf00      	nop
    1f94:	68f8      	ldr	r0, [r7, #12]
    1f96:	4b31      	ldr	r3, [pc, #196]	; (205c <_oscctrl_init_referenced_generators+0x14c>)
    1f98:	4798      	blx	r3
    1f9a:	4603      	mov	r3, r0
    1f9c:	2b00      	cmp	r3, #0
    1f9e:	d1f9      	bne.n	1f94 <_oscctrl_init_referenced_generators+0x84>
		;

	tmp = (CONF_DFLL_WAITLOCK << OSCCTRL_DFLLCTRLB_WAITLOCK_Pos) | (CONF_DFLL_BPLCKC << OSCCTRL_DFLLCTRLB_BPLCKC_Pos)
    1fa0:	2380      	movs	r3, #128	; 0x80
    1fa2:	72fb      	strb	r3, [r7, #11]
	      | (CONF_DFLL_QLDIS << OSCCTRL_DFLLCTRLB_QLDIS_Pos) | (CONF_DFLL_CCDIS << OSCCTRL_DFLLCTRLB_CCDIS_Pos)
	      | (CONF_DFLL_USBCRM << OSCCTRL_DFLLCTRLB_USBCRM_Pos) | (CONF_DFLL_LLAW << OSCCTRL_DFLLCTRLB_LLAW_Pos)
	      | (CONF_DFLL_STABLE << OSCCTRL_DFLLCTRLB_STABLE_Pos) | (CONF_DFLL_MODE << OSCCTRL_DFLLCTRLB_MODE_Pos) | 0;
	hri_oscctrl_write_DFLLCTRLB_reg(hw, tmp);
    1fa4:	7afb      	ldrb	r3, [r7, #11]
    1fa6:	4619      	mov	r1, r3
    1fa8:	68f8      	ldr	r0, [r7, #12]
    1faa:	4b27      	ldr	r3, [pc, #156]	; (2048 <_oscctrl_init_referenced_generators+0x138>)
    1fac:	4798      	blx	r3
	while (hri_oscctrl_get_DFLLSYNC_DFLLCTRLB_bit(hw))
    1fae:	bf00      	nop
    1fb0:	68f8      	ldr	r0, [r7, #12]
    1fb2:	4b26      	ldr	r3, [pc, #152]	; (204c <_oscctrl_init_referenced_generators+0x13c>)
    1fb4:	4798      	blx	r3
    1fb6:	4603      	mov	r3, r0
    1fb8:	2b00      	cmp	r3, #0
    1fba:	d1f9      	bne.n	1fb0 <_oscctrl_init_referenced_generators+0xa0>
	                                (CONF_FDPLL1_RUNSTDBY << OSCCTRL_DPLLCTRLA_RUNSTDBY_Pos)
	                                    | (CONF_FDPLL1_ENABLE << OSCCTRL_DPLLCTRLA_ENABLE_Pos));
#endif

#if CONF_DFLL_CONFIG == 1
	if (hri_oscctrl_get_DFLLCTRLB_MODE_bit(hw)) {
    1fbc:	68f8      	ldr	r0, [r7, #12]
    1fbe:	4b28      	ldr	r3, [pc, #160]	; (2060 <_oscctrl_init_referenced_generators+0x150>)
    1fc0:	4798      	blx	r3
    1fc2:	4603      	mov	r3, r0
    1fc4:	2b00      	cmp	r3, #0
    1fc6:	d00c      	beq.n	1fe2 <_oscctrl_init_referenced_generators+0xd2>
		hri_oscctrl_status_reg_t status_mask = OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC;
    1fc8:	f44f 6310 	mov.w	r3, #2304	; 0x900
    1fcc:	607b      	str	r3, [r7, #4]

		while (hri_oscctrl_get_STATUS_reg(hw, status_mask) != status_mask)
    1fce:	bf00      	nop
    1fd0:	6879      	ldr	r1, [r7, #4]
    1fd2:	68f8      	ldr	r0, [r7, #12]
    1fd4:	4b23      	ldr	r3, [pc, #140]	; (2064 <_oscctrl_init_referenced_generators+0x154>)
    1fd6:	4798      	blx	r3
    1fd8:	4602      	mov	r2, r0
    1fda:	687b      	ldr	r3, [r7, #4]
    1fdc:	4293      	cmp	r3, r2
    1fde:	d1f7      	bne.n	1fd0 <_oscctrl_init_referenced_generators+0xc0>
    1fe0:	e009      	b.n	1ff6 <_oscctrl_init_referenced_generators+0xe6>
			;
	} else {
		while (!hri_oscctrl_get_STATUS_DFLLRDY_bit(hw))
    1fe2:	bf00      	nop
    1fe4:	68f8      	ldr	r0, [r7, #12]
    1fe6:	4b20      	ldr	r3, [pc, #128]	; (2068 <_oscctrl_init_referenced_generators+0x158>)
    1fe8:	4798      	blx	r3
    1fea:	4603      	mov	r3, r0
    1fec:	f083 0301 	eor.w	r3, r3, #1
    1ff0:	b2db      	uxtb	r3, r3
    1ff2:	2b00      	cmp	r3, #0
    1ff4:	d1f6      	bne.n	1fe4 <_oscctrl_init_referenced_generators+0xd4>
	hri_oscctrl_set_DPLLCTRLA_ONDEMAND_bit(hw, 1);
#endif
#endif

#if CONF_DFLL_CONFIG == 1
	while (hri_gclk_read_SYNCBUSY_reg(GCLK))
    1ff6:	bf00      	nop
    1ff8:	480c      	ldr	r0, [pc, #48]	; (202c <_oscctrl_init_referenced_generators+0x11c>)
    1ffa:	4b1c      	ldr	r3, [pc, #112]	; (206c <_oscctrl_init_referenced_generators+0x15c>)
    1ffc:	4798      	blx	r3
    1ffe:	4603      	mov	r3, r0
    2000:	2b00      	cmp	r3, #0
    2002:	d1f9      	bne.n	1ff8 <_oscctrl_init_referenced_generators+0xe8>
		;
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, CONF_GCLK_GEN_0_SOURCE);
    2004:	2206      	movs	r2, #6
    2006:	2100      	movs	r1, #0
    2008:	4808      	ldr	r0, [pc, #32]	; (202c <_oscctrl_init_referenced_generators+0x11c>)
    200a:	4b09      	ldr	r3, [pc, #36]	; (2030 <_oscctrl_init_referenced_generators+0x120>)
    200c:	4798      	blx	r3
	while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
    200e:	bf00      	nop
    2010:	4806      	ldr	r0, [pc, #24]	; (202c <_oscctrl_init_referenced_generators+0x11c>)
    2012:	4b08      	ldr	r3, [pc, #32]	; (2034 <_oscctrl_init_referenced_generators+0x124>)
    2014:	4798      	blx	r3
    2016:	4603      	mov	r3, r0
    2018:	2b00      	cmp	r3, #0
    201a:	d1f9      	bne.n	2010 <_oscctrl_init_referenced_generators+0x100>
		;
#endif
	(void)hw;
}
    201c:	bf00      	nop
    201e:	bf00      	nop
    2020:	3710      	adds	r7, #16
    2022:	46bd      	mov	sp, r7
    2024:	bd80      	pop	{r7, pc}
    2026:	bf00      	nop
    2028:	40001000 	.word	0x40001000
    202c:	40001c00 	.word	0x40001c00
    2030:	00001cc9 	.word	0x00001cc9
    2034:	00001c87 	.word	0x00001c87
    2038:	00001d67 	.word	0x00001d67
    203c:	04010000 	.word	0x04010000
    2040:	00001e09 	.word	0x00001e09
    2044:	00001ec1 	.word	0x00001ec1
    2048:	00001db5 	.word	0x00001db5
    204c:	00001e59 	.word	0x00001e59
    2050:	00001e25 	.word	0x00001e25
    2054:	00001df1 	.word	0x00001df1
    2058:	00001dd5 	.word	0x00001dd5
    205c:	00001e8d 	.word	0x00001e8d
    2060:	00001d85 	.word	0x00001d85
    2064:	00001d41 	.word	0x00001d41
    2068:	00001d19 	.word	0x00001d19
    206c:	00001caf 	.word	0x00001caf

00002070 <usart_sync_init>:

/**
 * \brief Initialize usart interface
 */
int32_t usart_sync_init(struct usart_sync_descriptor *const descr, void *const hw, void *const func)
{
    2070:	b580      	push	{r7, lr}
    2072:	b086      	sub	sp, #24
    2074:	af00      	add	r7, sp, #0
    2076:	60f8      	str	r0, [r7, #12]
    2078:	60b9      	str	r1, [r7, #8]
    207a:	607a      	str	r2, [r7, #4]
	int32_t init_status;
	ASSERT(descr && hw);
    207c:	68fb      	ldr	r3, [r7, #12]
    207e:	2b00      	cmp	r3, #0
    2080:	d004      	beq.n	208c <usart_sync_init+0x1c>
    2082:	68bb      	ldr	r3, [r7, #8]
    2084:	2b00      	cmp	r3, #0
    2086:	d001      	beq.n	208c <usart_sync_init+0x1c>
    2088:	2301      	movs	r3, #1
    208a:	e000      	b.n	208e <usart_sync_init+0x1e>
    208c:	2300      	movs	r3, #0
    208e:	f003 0301 	and.w	r3, r3, #1
    2092:	b2db      	uxtb	r3, r3
    2094:	2234      	movs	r2, #52	; 0x34
    2096:	490d      	ldr	r1, [pc, #52]	; (20cc <usart_sync_init+0x5c>)
    2098:	4618      	mov	r0, r3
    209a:	4b0d      	ldr	r3, [pc, #52]	; (20d0 <usart_sync_init+0x60>)
    209c:	4798      	blx	r3
	init_status = _usart_sync_init(&descr->device, hw);
    209e:	68fb      	ldr	r3, [r7, #12]
    20a0:	3308      	adds	r3, #8
    20a2:	68b9      	ldr	r1, [r7, #8]
    20a4:	4618      	mov	r0, r3
    20a6:	4b0b      	ldr	r3, [pc, #44]	; (20d4 <usart_sync_init+0x64>)
    20a8:	4798      	blx	r3
    20aa:	6178      	str	r0, [r7, #20]
	if (init_status) {
    20ac:	697b      	ldr	r3, [r7, #20]
    20ae:	2b00      	cmp	r3, #0
    20b0:	d001      	beq.n	20b6 <usart_sync_init+0x46>
		return init_status;
    20b2:	697b      	ldr	r3, [r7, #20]
    20b4:	e006      	b.n	20c4 <usart_sync_init+0x54>
	}

	descr->io.read  = usart_sync_read;
    20b6:	68fb      	ldr	r3, [r7, #12]
    20b8:	4a07      	ldr	r2, [pc, #28]	; (20d8 <usart_sync_init+0x68>)
    20ba:	605a      	str	r2, [r3, #4]
	descr->io.write = usart_sync_write;
    20bc:	68fb      	ldr	r3, [r7, #12]
    20be:	4a07      	ldr	r2, [pc, #28]	; (20dc <usart_sync_init+0x6c>)
    20c0:	601a      	str	r2, [r3, #0]

	return ERR_NONE;
    20c2:	2300      	movs	r3, #0
}
    20c4:	4618      	mov	r0, r3
    20c6:	3718      	adds	r7, #24
    20c8:	46bd      	mov	sp, r7
    20ca:	bd80      	pop	{r7, pc}
    20cc:	000055ac 	.word	0x000055ac
    20d0:	00001c39 	.word	0x00001c39
    20d4:	000036f5 	.word	0x000036f5
    20d8:	000021a9 	.word	0x000021a9
    20dc:	000020e1 	.word	0x000020e1

000020e0 <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    20e0:	b580      	push	{r7, lr}
    20e2:	b086      	sub	sp, #24
    20e4:	af00      	add	r7, sp, #0
    20e6:	60f8      	str	r0, [r7, #12]
    20e8:	60b9      	str	r1, [r7, #8]
    20ea:	4613      	mov	r3, r2
    20ec:	80fb      	strh	r3, [r7, #6]
	uint32_t                      offset = 0;
    20ee:	2300      	movs	r3, #0
    20f0:	617b      	str	r3, [r7, #20]
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);
    20f2:	68fb      	ldr	r3, [r7, #12]
    20f4:	613b      	str	r3, [r7, #16]

	ASSERT(io_descr && buf && length);
    20f6:	68fb      	ldr	r3, [r7, #12]
    20f8:	2b00      	cmp	r3, #0
    20fa:	d007      	beq.n	210c <usart_sync_write+0x2c>
    20fc:	68bb      	ldr	r3, [r7, #8]
    20fe:	2b00      	cmp	r3, #0
    2100:	d004      	beq.n	210c <usart_sync_write+0x2c>
    2102:	88fb      	ldrh	r3, [r7, #6]
    2104:	2b00      	cmp	r3, #0
    2106:	d001      	beq.n	210c <usart_sync_write+0x2c>
    2108:	2301      	movs	r3, #1
    210a:	e000      	b.n	210e <usart_sync_write+0x2e>
    210c:	2300      	movs	r3, #0
    210e:	f003 0301 	and.w	r3, r3, #1
    2112:	b2db      	uxtb	r3, r3
    2114:	22f1      	movs	r2, #241	; 0xf1
    2116:	491f      	ldr	r1, [pc, #124]	; (2194 <usart_sync_write+0xb4>)
    2118:	4618      	mov	r0, r3
    211a:	4b1f      	ldr	r3, [pc, #124]	; (2198 <usart_sync_write+0xb8>)
    211c:	4798      	blx	r3
	while (!_usart_sync_is_ready_to_send(&descr->device))
    211e:	bf00      	nop
    2120:	693b      	ldr	r3, [r7, #16]
    2122:	3308      	adds	r3, #8
    2124:	4618      	mov	r0, r3
    2126:	4b1d      	ldr	r3, [pc, #116]	; (219c <usart_sync_write+0xbc>)
    2128:	4798      	blx	r3
    212a:	4603      	mov	r3, r0
    212c:	f083 0301 	eor.w	r3, r3, #1
    2130:	b2db      	uxtb	r3, r3
    2132:	2b00      	cmp	r3, #0
    2134:	d1f4      	bne.n	2120 <usart_sync_write+0x40>
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
    2136:	693b      	ldr	r3, [r7, #16]
    2138:	f103 0008 	add.w	r0, r3, #8
    213c:	68ba      	ldr	r2, [r7, #8]
    213e:	697b      	ldr	r3, [r7, #20]
    2140:	4413      	add	r3, r2
    2142:	781b      	ldrb	r3, [r3, #0]
    2144:	4619      	mov	r1, r3
    2146:	4b16      	ldr	r3, [pc, #88]	; (21a0 <usart_sync_write+0xc0>)
    2148:	4798      	blx	r3
		while (!_usart_sync_is_ready_to_send(&descr->device))
    214a:	bf00      	nop
    214c:	693b      	ldr	r3, [r7, #16]
    214e:	3308      	adds	r3, #8
    2150:	4618      	mov	r0, r3
    2152:	4b12      	ldr	r3, [pc, #72]	; (219c <usart_sync_write+0xbc>)
    2154:	4798      	blx	r3
    2156:	4603      	mov	r3, r0
    2158:	f083 0301 	eor.w	r3, r3, #1
    215c:	b2db      	uxtb	r3, r3
    215e:	2b00      	cmp	r3, #0
    2160:	d1f4      	bne.n	214c <usart_sync_write+0x6c>
			;
	} while (++offset < length);
    2162:	697b      	ldr	r3, [r7, #20]
    2164:	3301      	adds	r3, #1
    2166:	617b      	str	r3, [r7, #20]
    2168:	88fb      	ldrh	r3, [r7, #6]
    216a:	697a      	ldr	r2, [r7, #20]
    216c:	429a      	cmp	r2, r3
    216e:	d3e2      	bcc.n	2136 <usart_sync_write+0x56>
	while (!_usart_sync_is_transmit_done(&descr->device))
    2170:	bf00      	nop
    2172:	693b      	ldr	r3, [r7, #16]
    2174:	3308      	adds	r3, #8
    2176:	4618      	mov	r0, r3
    2178:	4b0a      	ldr	r3, [pc, #40]	; (21a4 <usart_sync_write+0xc4>)
    217a:	4798      	blx	r3
    217c:	4603      	mov	r3, r0
    217e:	f083 0301 	eor.w	r3, r3, #1
    2182:	b2db      	uxtb	r3, r3
    2184:	2b00      	cmp	r3, #0
    2186:	d1f4      	bne.n	2172 <usart_sync_write+0x92>
		;
	return (int32_t)offset;
    2188:	697b      	ldr	r3, [r7, #20]
}
    218a:	4618      	mov	r0, r3
    218c:	3718      	adds	r7, #24
    218e:	46bd      	mov	sp, r7
    2190:	bd80      	pop	{r7, pc}
    2192:	bf00      	nop
    2194:	000055ac 	.word	0x000055ac
    2198:	00001c39 	.word	0x00001c39
    219c:	00003785 	.word	0x00003785
    21a0:	00003739 	.word	0x00003739
    21a4:	000037a5 	.word	0x000037a5

000021a8 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    21a8:	b590      	push	{r4, r7, lr}
    21aa:	b087      	sub	sp, #28
    21ac:	af00      	add	r7, sp, #0
    21ae:	60f8      	str	r0, [r7, #12]
    21b0:	60b9      	str	r1, [r7, #8]
    21b2:	4613      	mov	r3, r2
    21b4:	80fb      	strh	r3, [r7, #6]
	uint32_t                      offset = 0;
    21b6:	2300      	movs	r3, #0
    21b8:	617b      	str	r3, [r7, #20]
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);
    21ba:	68fb      	ldr	r3, [r7, #12]
    21bc:	613b      	str	r3, [r7, #16]

	ASSERT(io_descr && buf && length);
    21be:	68fb      	ldr	r3, [r7, #12]
    21c0:	2b00      	cmp	r3, #0
    21c2:	d007      	beq.n	21d4 <usart_sync_read+0x2c>
    21c4:	68bb      	ldr	r3, [r7, #8]
    21c6:	2b00      	cmp	r3, #0
    21c8:	d004      	beq.n	21d4 <usart_sync_read+0x2c>
    21ca:	88fb      	ldrh	r3, [r7, #6]
    21cc:	2b00      	cmp	r3, #0
    21ce:	d001      	beq.n	21d4 <usart_sync_read+0x2c>
    21d0:	2301      	movs	r3, #1
    21d2:	e000      	b.n	21d6 <usart_sync_read+0x2e>
    21d4:	2300      	movs	r3, #0
    21d6:	f003 0301 	and.w	r3, r3, #1
    21da:	b2db      	uxtb	r3, r3
    21dc:	f44f 7286 	mov.w	r2, #268	; 0x10c
    21e0:	4913      	ldr	r1, [pc, #76]	; (2230 <usart_sync_read+0x88>)
    21e2:	4618      	mov	r0, r3
    21e4:	4b13      	ldr	r3, [pc, #76]	; (2234 <usart_sync_read+0x8c>)
    21e6:	4798      	blx	r3
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
    21e8:	bf00      	nop
    21ea:	693b      	ldr	r3, [r7, #16]
    21ec:	3308      	adds	r3, #8
    21ee:	4618      	mov	r0, r3
    21f0:	4b11      	ldr	r3, [pc, #68]	; (2238 <usart_sync_read+0x90>)
    21f2:	4798      	blx	r3
    21f4:	4603      	mov	r3, r0
    21f6:	f083 0301 	eor.w	r3, r3, #1
    21fa:	b2db      	uxtb	r3, r3
    21fc:	2b00      	cmp	r3, #0
    21fe:	d1f4      	bne.n	21ea <usart_sync_read+0x42>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
    2200:	693b      	ldr	r3, [r7, #16]
    2202:	f103 0108 	add.w	r1, r3, #8
    2206:	68ba      	ldr	r2, [r7, #8]
    2208:	697b      	ldr	r3, [r7, #20]
    220a:	18d4      	adds	r4, r2, r3
    220c:	4608      	mov	r0, r1
    220e:	4b0b      	ldr	r3, [pc, #44]	; (223c <usart_sync_read+0x94>)
    2210:	4798      	blx	r3
    2212:	4603      	mov	r3, r0
    2214:	7023      	strb	r3, [r4, #0]
	} while (++offset < length);
    2216:	697b      	ldr	r3, [r7, #20]
    2218:	3301      	adds	r3, #1
    221a:	617b      	str	r3, [r7, #20]
    221c:	88fb      	ldrh	r3, [r7, #6]
    221e:	697a      	ldr	r2, [r7, #20]
    2220:	429a      	cmp	r2, r3
    2222:	d3e1      	bcc.n	21e8 <usart_sync_read+0x40>

	return (int32_t)offset;
    2224:	697b      	ldr	r3, [r7, #20]
}
    2226:	4618      	mov	r0, r3
    2228:	371c      	adds	r7, #28
    222a:	46bd      	mov	sp, r7
    222c:	bd90      	pop	{r4, r7, pc}
    222e:	bf00      	nop
    2230:	000055ac 	.word	0x000055ac
    2234:	00001c39 	.word	0x00001c39
    2238:	000037c5 	.word	0x000037c5
    223c:	00003761 	.word	0x00003761

00002240 <hri_mclk_write_CPUDIV_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_mclk_write_CPUDIV_reg(const void *const hw, hri_mclk_cpudiv_reg_t data)
{
    2240:	b480      	push	{r7}
    2242:	b083      	sub	sp, #12
    2244:	af00      	add	r7, sp, #0
    2246:	6078      	str	r0, [r7, #4]
    2248:	460b      	mov	r3, r1
    224a:	70fb      	strb	r3, [r7, #3]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->CPUDIV.reg = data;
    224c:	687b      	ldr	r3, [r7, #4]
    224e:	78fa      	ldrb	r2, [r7, #3]
    2250:	715a      	strb	r2, [r3, #5]
	MCLK_CRITICAL_SECTION_LEAVE();
}
    2252:	bf00      	nop
    2254:	370c      	adds	r7, #12
    2256:	46bd      	mov	sp, r7
    2258:	f85d 7b04 	ldr.w	r7, [sp], #4
    225c:	4770      	bx	lr
	...

00002260 <_mclk_init>:

/**
 * \brief Initialize master clock generator
 */
void _mclk_init(void)
{
    2260:	b580      	push	{r7, lr}
    2262:	b082      	sub	sp, #8
    2264:	af00      	add	r7, sp, #0
	void *hw = (void *)MCLK;
    2266:	4b05      	ldr	r3, [pc, #20]	; (227c <_mclk_init+0x1c>)
    2268:	607b      	str	r3, [r7, #4]
	hri_mclk_write_CPUDIV_reg(hw, MCLK_CPUDIV_DIV(CONF_MCLK_CPUDIV));
    226a:	2101      	movs	r1, #1
    226c:	6878      	ldr	r0, [r7, #4]
    226e:	4b04      	ldr	r3, [pc, #16]	; (2280 <_mclk_init+0x20>)
    2270:	4798      	blx	r3
}
    2272:	bf00      	nop
    2274:	3708      	adds	r7, #8
    2276:	46bd      	mov	sp, r7
    2278:	bd80      	pop	{r7, pc}
    227a:	bf00      	nop
    227c:	40000800 	.word	0x40000800
    2280:	00002241 	.word	0x00002241

00002284 <hri_ramecc_read_INTFLAG_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
    2284:	b480      	push	{r7}
    2286:	b083      	sub	sp, #12
    2288:	af00      	add	r7, sp, #0
    228a:	6078      	str	r0, [r7, #4]
	return ((Ramecc *)hw)->INTFLAG.reg;
    228c:	687b      	ldr	r3, [r7, #4]
    228e:	789b      	ldrb	r3, [r3, #2]
    2290:	b2db      	uxtb	r3, r3
}
    2292:	4618      	mov	r0, r3
    2294:	370c      	adds	r7, #12
    2296:	46bd      	mov	sp, r7
    2298:	f85d 7b04 	ldr.w	r7, [sp], #4
    229c:	4770      	bx	lr

0000229e <hri_ramecc_read_ERRADDR_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
    229e:	b480      	push	{r7}
    22a0:	b083      	sub	sp, #12
    22a2:	af00      	add	r7, sp, #0
    22a4:	6078      	str	r0, [r7, #4]
	return ((Ramecc *)hw)->ERRADDR.reg;
    22a6:	687b      	ldr	r3, [r7, #4]
    22a8:	685b      	ldr	r3, [r3, #4]
}
    22aa:	4618      	mov	r0, r3
    22ac:	370c      	adds	r7, #12
    22ae:	46bd      	mov	sp, r7
    22b0:	f85d 7b04 	ldr.w	r7, [sp], #4
    22b4:	4770      	bx	lr
	...

000022b8 <RAMECC_Handler>:

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
    22b8:	b590      	push	{r4, r7, lr}
    22ba:	b083      	sub	sp, #12
    22bc:	af00      	add	r7, sp, #0
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
    22be:	4b17      	ldr	r3, [pc, #92]	; (231c <RAMECC_Handler+0x64>)
    22c0:	607b      	str	r3, [r7, #4]
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
    22c2:	4817      	ldr	r0, [pc, #92]	; (2320 <RAMECC_Handler+0x68>)
    22c4:	4b17      	ldr	r3, [pc, #92]	; (2324 <RAMECC_Handler+0x6c>)
    22c6:	4798      	blx	r3
    22c8:	4603      	mov	r3, r0
    22ca:	603b      	str	r3, [r7, #0]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
    22cc:	683b      	ldr	r3, [r7, #0]
    22ce:	f003 0302 	and.w	r3, r3, #2
    22d2:	2b00      	cmp	r3, #0
    22d4:	d00c      	beq.n	22f0 <RAMECC_Handler+0x38>
    22d6:	687b      	ldr	r3, [r7, #4]
    22d8:	681b      	ldr	r3, [r3, #0]
    22da:	2b00      	cmp	r3, #0
    22dc:	d008      	beq.n	22f0 <RAMECC_Handler+0x38>
		dev->ramecc_cb.dual_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    22de:	687b      	ldr	r3, [r7, #4]
    22e0:	681c      	ldr	r4, [r3, #0]
    22e2:	480f      	ldr	r0, [pc, #60]	; (2320 <RAMECC_Handler+0x68>)
    22e4:	4b10      	ldr	r3, [pc, #64]	; (2328 <RAMECC_Handler+0x70>)
    22e6:	4798      	blx	r3
    22e8:	4603      	mov	r3, r0
    22ea:	4618      	mov	r0, r3
    22ec:	47a0      	blx	r4
    22ee:	e012      	b.n	2316 <RAMECC_Handler+0x5e>
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
    22f0:	683b      	ldr	r3, [r7, #0]
    22f2:	f003 0301 	and.w	r3, r3, #1
    22f6:	2b00      	cmp	r3, #0
    22f8:	d00c      	beq.n	2314 <RAMECC_Handler+0x5c>
    22fa:	687b      	ldr	r3, [r7, #4]
    22fc:	685b      	ldr	r3, [r3, #4]
    22fe:	2b00      	cmp	r3, #0
    2300:	d008      	beq.n	2314 <RAMECC_Handler+0x5c>
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    2302:	687b      	ldr	r3, [r7, #4]
    2304:	685c      	ldr	r4, [r3, #4]
    2306:	4806      	ldr	r0, [pc, #24]	; (2320 <RAMECC_Handler+0x68>)
    2308:	4b07      	ldr	r3, [pc, #28]	; (2328 <RAMECC_Handler+0x70>)
    230a:	4798      	blx	r3
    230c:	4603      	mov	r3, r0
    230e:	4618      	mov	r0, r3
    2310:	47a0      	blx	r4
    2312:	e000      	b.n	2316 <RAMECC_Handler+0x5e>
	} else {
		return;
    2314:	bf00      	nop
	}
}
    2316:	370c      	adds	r7, #12
    2318:	46bd      	mov	sp, r7
    231a:	bd90      	pop	{r4, r7, pc}
    231c:	20000514 	.word	0x20000514
    2320:	41020000 	.word	0x41020000
    2324:	00002285 	.word	0x00002285
    2328:	0000229f 	.word	0x0000229f

0000232c <hri_osc32kctrl_write_RTCCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_osc32kctrl_write_RTCCTRL_reg(const void *const hw, hri_osc32kctrl_rtcctrl_reg_t data)
{
    232c:	b480      	push	{r7}
    232e:	b083      	sub	sp, #12
    2330:	af00      	add	r7, sp, #0
    2332:	6078      	str	r0, [r7, #4]
    2334:	460b      	mov	r3, r1
    2336:	70fb      	strb	r3, [r7, #3]
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
    2338:	687b      	ldr	r3, [r7, #4]
    233a:	78fa      	ldrb	r2, [r7, #3]
    233c:	741a      	strb	r2, [r3, #16]
	OSC32KCTRL_CRITICAL_SECTION_LEAVE();
}
    233e:	bf00      	nop
    2340:	370c      	adds	r7, #12
    2342:	46bd      	mov	sp, r7
    2344:	f85d 7b04 	ldr.w	r7, [sp], #4
    2348:	4770      	bx	lr

0000234a <hri_osc32kctrl_read_OSCULP32K_CALIB_bf>:
	((Osc32kctrl *)hw)->OSCULP32K.reg ^= OSC32KCTRL_OSCULP32K_CALIB(mask);
	OSC32KCTRL_CRITICAL_SECTION_LEAVE();
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
    234a:	b480      	push	{r7}
    234c:	b085      	sub	sp, #20
    234e:	af00      	add	r7, sp, #0
    2350:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
    2352:	687b      	ldr	r3, [r7, #4]
    2354:	69db      	ldr	r3, [r3, #28]
    2356:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & OSC32KCTRL_OSCULP32K_CALIB_Msk) >> OSC32KCTRL_OSCULP32K_CALIB_Pos;
    2358:	68fb      	ldr	r3, [r7, #12]
    235a:	0a1b      	lsrs	r3, r3, #8
    235c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    2360:	60fb      	str	r3, [r7, #12]
	return tmp;
    2362:	68fb      	ldr	r3, [r7, #12]
}
    2364:	4618      	mov	r0, r3
    2366:	3714      	adds	r7, #20
    2368:	46bd      	mov	sp, r7
    236a:	f85d 7b04 	ldr.w	r7, [sp], #4
    236e:	4770      	bx	lr

00002370 <hri_osc32kctrl_write_OSCULP32K_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
    2370:	b480      	push	{r7}
    2372:	b083      	sub	sp, #12
    2374:	af00      	add	r7, sp, #0
    2376:	6078      	str	r0, [r7, #4]
    2378:	6039      	str	r1, [r7, #0]
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
    237a:	687b      	ldr	r3, [r7, #4]
    237c:	683a      	ldr	r2, [r7, #0]
    237e:	61da      	str	r2, [r3, #28]
	OSC32KCTRL_CRITICAL_SECTION_LEAVE();
}
    2380:	bf00      	nop
    2382:	370c      	adds	r7, #12
    2384:	46bd      	mov	sp, r7
    2386:	f85d 7b04 	ldr.w	r7, [sp], #4
    238a:	4770      	bx	lr

0000238c <_osc32kctrl_init_sources>:

/**
 * \brief Initialize 32 kHz clock sources
 */
void _osc32kctrl_init_sources(void)
{
    238c:	b580      	push	{r7, lr}
    238e:	b082      	sub	sp, #8
    2390:	af00      	add	r7, sp, #0
	void *   hw    = (void *)OSC32KCTRL;
    2392:	4b0c      	ldr	r3, [pc, #48]	; (23c4 <_osc32kctrl_init_sources+0x38>)
    2394:	607b      	str	r3, [r7, #4]
	uint16_t calib = 0;
    2396:	2300      	movs	r3, #0
    2398:	807b      	strh	r3, [r7, #2]

	hri_osc32kctrl_write_EVCTRL_reg(hw, (CONF_XOSC32K_CFDEO << OSC32KCTRL_EVCTRL_CFDEO_Pos));
#endif

#if CONF_OSCULP32K_CONFIG == 1
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
    239a:	6878      	ldr	r0, [r7, #4]
    239c:	4b0a      	ldr	r3, [pc, #40]	; (23c8 <_osc32kctrl_init_sources+0x3c>)
    239e:	4798      	blx	r3
    23a0:	4603      	mov	r3, r0
    23a2:	807b      	strh	r3, [r7, #2]
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSCULP32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSCULP32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
    23a4:	887b      	ldrh	r3, [r7, #2]
    23a6:	021b      	lsls	r3, r3, #8
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
    23a8:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
    23ac:	4619      	mov	r1, r3
    23ae:	6878      	ldr	r0, [r7, #4]
    23b0:	4b06      	ldr	r3, [pc, #24]	; (23cc <_osc32kctrl_init_sources+0x40>)
    23b2:	4798      	blx	r3
	while (!hri_osc32kctrl_get_STATUS_XOSC32KRDY_bit(hw))
		;
#endif
#endif

	hri_osc32kctrl_write_RTCCTRL_reg(hw, OSC32KCTRL_RTCCTRL_RTCSEL(CONF_RTCCTRL));
    23b4:	2101      	movs	r1, #1
    23b6:	6878      	ldr	r0, [r7, #4]
    23b8:	4b05      	ldr	r3, [pc, #20]	; (23d0 <_osc32kctrl_init_sources+0x44>)
    23ba:	4798      	blx	r3
	(void)calib;
}
    23bc:	bf00      	nop
    23be:	3708      	adds	r7, #8
    23c0:	46bd      	mov	sp, r7
    23c2:	bd80      	pop	{r7, pc}
    23c4:	40001400 	.word	0x40001400
    23c8:	0000234b 	.word	0x0000234b
    23cc:	00002371 	.word	0x00002371
    23d0:	0000232d 	.word	0x0000232d

000023d4 <hri_gclk_write_PCHCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
    23d4:	b480      	push	{r7}
    23d6:	b085      	sub	sp, #20
    23d8:	af00      	add	r7, sp, #0
    23da:	60f8      	str	r0, [r7, #12]
    23dc:	460b      	mov	r3, r1
    23de:	607a      	str	r2, [r7, #4]
    23e0:	72fb      	strb	r3, [r7, #11]
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
    23e2:	7afa      	ldrb	r2, [r7, #11]
    23e4:	68fb      	ldr	r3, [r7, #12]
    23e6:	3220      	adds	r2, #32
    23e8:	6879      	ldr	r1, [r7, #4]
    23ea:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	GCLK_CRITICAL_SECTION_LEAVE();
}
    23ee:	bf00      	nop
    23f0:	3714      	adds	r7, #20
    23f2:	46bd      	mov	sp, r7
    23f4:	f85d 7b04 	ldr.w	r7, [sp], #4
    23f8:	4770      	bx	lr

000023fa <hri_mclk_set_APBAMASK_WDT_bit>:
	((Mclk *)hw)->APBAMASK.reg ^= MCLK_APBAMASK_GCLK;
	MCLK_CRITICAL_SECTION_LEAVE();
}

static inline void hri_mclk_set_APBAMASK_WDT_bit(const void *const hw)
{
    23fa:	b480      	push	{r7}
    23fc:	b083      	sub	sp, #12
    23fe:	af00      	add	r7, sp, #0
    2400:	6078      	str	r0, [r7, #4]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_WDT;
    2402:	687b      	ldr	r3, [r7, #4]
    2404:	695b      	ldr	r3, [r3, #20]
    2406:	f443 7280 	orr.w	r2, r3, #256	; 0x100
    240a:	687b      	ldr	r3, [r7, #4]
    240c:	615a      	str	r2, [r3, #20]
	MCLK_CRITICAL_SECTION_LEAVE();
}
    240e:	bf00      	nop
    2410:	370c      	adds	r7, #12
    2412:	46bd      	mov	sp, r7
    2414:	f85d 7b04 	ldr.w	r7, [sp], #4
    2418:	4770      	bx	lr

0000241a <hri_mclk_set_APBAMASK_SERCOM0_bit>:
	((Mclk *)hw)->APBAMASK.reg ^= MCLK_APBAMASK_FREQM;
	MCLK_CRITICAL_SECTION_LEAVE();
}

static inline void hri_mclk_set_APBAMASK_SERCOM0_bit(const void *const hw)
{
    241a:	b480      	push	{r7}
    241c:	b083      	sub	sp, #12
    241e:	af00      	add	r7, sp, #0
    2420:	6078      	str	r0, [r7, #4]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_SERCOM0;
    2422:	687b      	ldr	r3, [r7, #4]
    2424:	695b      	ldr	r3, [r3, #20]
    2426:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
    242a:	687b      	ldr	r3, [r7, #4]
    242c:	615a      	str	r2, [r3, #20]
	MCLK_CRITICAL_SECTION_LEAVE();
}
    242e:	bf00      	nop
    2430:	370c      	adds	r7, #12
    2432:	46bd      	mov	sp, r7
    2434:	f85d 7b04 	ldr.w	r7, [sp], #4
    2438:	4770      	bx	lr

0000243a <hri_mclk_set_APBBMASK_SERCOM2_bit>:
	((Mclk *)hw)->APBBMASK.reg ^= MCLK_APBBMASK_EVSYS;
	MCLK_CRITICAL_SECTION_LEAVE();
}

static inline void hri_mclk_set_APBBMASK_SERCOM2_bit(const void *const hw)
{
    243a:	b480      	push	{r7}
    243c:	b083      	sub	sp, #12
    243e:	af00      	add	r7, sp, #0
    2440:	6078      	str	r0, [r7, #4]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_SERCOM2;
    2442:	687b      	ldr	r3, [r7, #4]
    2444:	699b      	ldr	r3, [r3, #24]
    2446:	f443 7200 	orr.w	r2, r3, #512	; 0x200
    244a:	687b      	ldr	r3, [r7, #4]
    244c:	619a      	str	r2, [r3, #24]
	MCLK_CRITICAL_SECTION_LEAVE();
}
    244e:	bf00      	nop
    2450:	370c      	adds	r7, #12
    2452:	46bd      	mov	sp, r7
    2454:	f85d 7b04 	ldr.w	r7, [sp], #4
    2458:	4770      	bx	lr

0000245a <hri_mclk_set_APBBMASK_SERCOM3_bit>:
	((Mclk *)hw)->APBBMASK.reg ^= MCLK_APBBMASK_SERCOM2;
	MCLK_CRITICAL_SECTION_LEAVE();
}

static inline void hri_mclk_set_APBBMASK_SERCOM3_bit(const void *const hw)
{
    245a:	b480      	push	{r7}
    245c:	b083      	sub	sp, #12
    245e:	af00      	add	r7, sp, #0
    2460:	6078      	str	r0, [r7, #4]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_SERCOM3;
    2462:	687b      	ldr	r3, [r7, #4]
    2464:	699b      	ldr	r3, [r3, #24]
    2466:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
    246a:	687b      	ldr	r3, [r7, #4]
    246c:	619a      	str	r2, [r3, #24]
	MCLK_CRITICAL_SECTION_LEAVE();
}
    246e:	bf00      	nop
    2470:	370c      	adds	r7, #12
    2472:	46bd      	mov	sp, r7
    2474:	f85d 7b04 	ldr.w	r7, [sp], #4
    2478:	4770      	bx	lr

0000247a <hri_mclk_set_APBDMASK_ADC0_bit>:
	((Mclk *)hw)->APBDMASK.reg ^= MCLK_APBDMASK_TC7;
	MCLK_CRITICAL_SECTION_LEAVE();
}

static inline void hri_mclk_set_APBDMASK_ADC0_bit(const void *const hw)
{
    247a:	b480      	push	{r7}
    247c:	b083      	sub	sp, #12
    247e:	af00      	add	r7, sp, #0
    2480:	6078      	str	r0, [r7, #4]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_ADC0;
    2482:	687b      	ldr	r3, [r7, #4]
    2484:	6a1b      	ldr	r3, [r3, #32]
    2486:	f043 0280 	orr.w	r2, r3, #128	; 0x80
    248a:	687b      	ldr	r3, [r7, #4]
    248c:	621a      	str	r2, [r3, #32]
	MCLK_CRITICAL_SECTION_LEAVE();
}
    248e:	bf00      	nop
    2490:	370c      	adds	r7, #12
    2492:	46bd      	mov	sp, r7
    2494:	f85d 7b04 	ldr.w	r7, [sp], #4
    2498:	4770      	bx	lr

0000249a <hri_mclk_set_APBDMASK_ADC1_bit>:
	((Mclk *)hw)->APBDMASK.reg ^= MCLK_APBDMASK_ADC0;
	MCLK_CRITICAL_SECTION_LEAVE();
}

static inline void hri_mclk_set_APBDMASK_ADC1_bit(const void *const hw)
{
    249a:	b480      	push	{r7}
    249c:	b083      	sub	sp, #12
    249e:	af00      	add	r7, sp, #0
    24a0:	6078      	str	r0, [r7, #4]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_ADC1;
    24a2:	687b      	ldr	r3, [r7, #4]
    24a4:	6a1b      	ldr	r3, [r3, #32]
    24a6:	f443 7280 	orr.w	r2, r3, #256	; 0x100
    24aa:	687b      	ldr	r3, [r7, #4]
    24ac:	621a      	str	r2, [r3, #32]
	MCLK_CRITICAL_SECTION_LEAVE();
}
    24ae:	bf00      	nop
    24b0:	370c      	adds	r7, #12
    24b2:	46bd      	mov	sp, r7
    24b4:	f85d 7b04 	ldr.w	r7, [sp], #4
    24b8:	4770      	bx	lr

000024ba <hri_port_set_DIR_reg>:
{
    24ba:	b480      	push	{r7}
    24bc:	b085      	sub	sp, #20
    24be:	af00      	add	r7, sp, #0
    24c0:	60f8      	str	r0, [r7, #12]
    24c2:	460b      	mov	r3, r1
    24c4:	607a      	str	r2, [r7, #4]
    24c6:	72fb      	strb	r3, [r7, #11]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    24c8:	7afb      	ldrb	r3, [r7, #11]
    24ca:	68fa      	ldr	r2, [r7, #12]
    24cc:	01db      	lsls	r3, r3, #7
    24ce:	4413      	add	r3, r2
    24d0:	3308      	adds	r3, #8
    24d2:	687a      	ldr	r2, [r7, #4]
    24d4:	601a      	str	r2, [r3, #0]
}
    24d6:	bf00      	nop
    24d8:	3714      	adds	r7, #20
    24da:	46bd      	mov	sp, r7
    24dc:	f85d 7b04 	ldr.w	r7, [sp], #4
    24e0:	4770      	bx	lr

000024e2 <hri_port_clear_DIR_reg>:
{
    24e2:	b480      	push	{r7}
    24e4:	b085      	sub	sp, #20
    24e6:	af00      	add	r7, sp, #0
    24e8:	60f8      	str	r0, [r7, #12]
    24ea:	460b      	mov	r3, r1
    24ec:	607a      	str	r2, [r7, #4]
    24ee:	72fb      	strb	r3, [r7, #11]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    24f0:	7afb      	ldrb	r3, [r7, #11]
    24f2:	68fa      	ldr	r2, [r7, #12]
    24f4:	01db      	lsls	r3, r3, #7
    24f6:	4413      	add	r3, r2
    24f8:	3304      	adds	r3, #4
    24fa:	687a      	ldr	r2, [r7, #4]
    24fc:	601a      	str	r2, [r3, #0]
}
    24fe:	bf00      	nop
    2500:	3714      	adds	r7, #20
    2502:	46bd      	mov	sp, r7
    2504:	f85d 7b04 	ldr.w	r7, [sp], #4
    2508:	4770      	bx	lr

0000250a <hri_port_set_OUT_reg>:
{
    250a:	b480      	push	{r7}
    250c:	b085      	sub	sp, #20
    250e:	af00      	add	r7, sp, #0
    2510:	60f8      	str	r0, [r7, #12]
    2512:	460b      	mov	r3, r1
    2514:	607a      	str	r2, [r7, #4]
    2516:	72fb      	strb	r3, [r7, #11]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    2518:	7afb      	ldrb	r3, [r7, #11]
    251a:	68fa      	ldr	r2, [r7, #12]
    251c:	01db      	lsls	r3, r3, #7
    251e:	4413      	add	r3, r2
    2520:	3318      	adds	r3, #24
    2522:	687a      	ldr	r2, [r7, #4]
    2524:	601a      	str	r2, [r3, #0]
}
    2526:	bf00      	nop
    2528:	3714      	adds	r7, #20
    252a:	46bd      	mov	sp, r7
    252c:	f85d 7b04 	ldr.w	r7, [sp], #4
    2530:	4770      	bx	lr

00002532 <hri_port_clear_OUT_reg>:
{
    2532:	b480      	push	{r7}
    2534:	b085      	sub	sp, #20
    2536:	af00      	add	r7, sp, #0
    2538:	60f8      	str	r0, [r7, #12]
    253a:	460b      	mov	r3, r1
    253c:	607a      	str	r2, [r7, #4]
    253e:	72fb      	strb	r3, [r7, #11]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    2540:	7afb      	ldrb	r3, [r7, #11]
    2542:	68fa      	ldr	r2, [r7, #12]
    2544:	01db      	lsls	r3, r3, #7
    2546:	4413      	add	r3, r2
    2548:	3314      	adds	r3, #20
    254a:	687a      	ldr	r2, [r7, #4]
    254c:	601a      	str	r2, [r3, #0]
}
    254e:	bf00      	nop
    2550:	3714      	adds	r7, #20
    2552:	46bd      	mov	sp, r7
    2554:	f85d 7b04 	ldr.w	r7, [sp], #4
    2558:	4770      	bx	lr

0000255a <hri_port_write_PMUX_PMUXE_bf>:
	return tmp;
}

static inline void hri_port_write_PMUX_PMUXE_bf(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                hri_port_pmux_reg_t data)
{
    255a:	b480      	push	{r7}
    255c:	b085      	sub	sp, #20
    255e:	af00      	add	r7, sp, #0
    2560:	6078      	str	r0, [r7, #4]
    2562:	4608      	mov	r0, r1
    2564:	4611      	mov	r1, r2
    2566:	461a      	mov	r2, r3
    2568:	4603      	mov	r3, r0
    256a:	70fb      	strb	r3, [r7, #3]
    256c:	460b      	mov	r3, r1
    256e:	70bb      	strb	r3, [r7, #2]
    2570:	4613      	mov	r3, r2
    2572:	707b      	strb	r3, [r7, #1]
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    2574:	78fa      	ldrb	r2, [r7, #3]
    2576:	78bb      	ldrb	r3, [r7, #2]
    2578:	6879      	ldr	r1, [r7, #4]
    257a:	01d2      	lsls	r2, r2, #7
    257c:	440a      	add	r2, r1
    257e:	4413      	add	r3, r2
    2580:	3330      	adds	r3, #48	; 0x30
    2582:	781b      	ldrb	r3, [r3, #0]
    2584:	73fb      	strb	r3, [r7, #15]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    2586:	7bfb      	ldrb	r3, [r7, #15]
    2588:	f023 030f 	bic.w	r3, r3, #15
    258c:	73fb      	strb	r3, [r7, #15]
	tmp |= PORT_PMUX_PMUXE(data);
    258e:	787b      	ldrb	r3, [r7, #1]
    2590:	f003 030f 	and.w	r3, r3, #15
    2594:	b2da      	uxtb	r2, r3
    2596:	7bfb      	ldrb	r3, [r7, #15]
    2598:	4313      	orrs	r3, r2
    259a:	73fb      	strb	r3, [r7, #15]
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    259c:	78fa      	ldrb	r2, [r7, #3]
    259e:	78bb      	ldrb	r3, [r7, #2]
    25a0:	6879      	ldr	r1, [r7, #4]
    25a2:	01d2      	lsls	r2, r2, #7
    25a4:	440a      	add	r2, r1
    25a6:	4413      	add	r3, r2
    25a8:	3330      	adds	r3, #48	; 0x30
    25aa:	7bfa      	ldrb	r2, [r7, #15]
    25ac:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    25ae:	bf00      	nop
    25b0:	3714      	adds	r7, #20
    25b2:	46bd      	mov	sp, r7
    25b4:	f85d 7b04 	ldr.w	r7, [sp], #4
    25b8:	4770      	bx	lr

000025ba <hri_port_write_PMUX_PMUXO_bf>:
	return tmp;
}

static inline void hri_port_write_PMUX_PMUXO_bf(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                hri_port_pmux_reg_t data)
{
    25ba:	b480      	push	{r7}
    25bc:	b085      	sub	sp, #20
    25be:	af00      	add	r7, sp, #0
    25c0:	6078      	str	r0, [r7, #4]
    25c2:	4608      	mov	r0, r1
    25c4:	4611      	mov	r1, r2
    25c6:	461a      	mov	r2, r3
    25c8:	4603      	mov	r3, r0
    25ca:	70fb      	strb	r3, [r7, #3]
    25cc:	460b      	mov	r3, r1
    25ce:	70bb      	strb	r3, [r7, #2]
    25d0:	4613      	mov	r3, r2
    25d2:	707b      	strb	r3, [r7, #1]
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    25d4:	78fa      	ldrb	r2, [r7, #3]
    25d6:	78bb      	ldrb	r3, [r7, #2]
    25d8:	6879      	ldr	r1, [r7, #4]
    25da:	01d2      	lsls	r2, r2, #7
    25dc:	440a      	add	r2, r1
    25de:	4413      	add	r3, r2
    25e0:	3330      	adds	r3, #48	; 0x30
    25e2:	781b      	ldrb	r3, [r3, #0]
    25e4:	73fb      	strb	r3, [r7, #15]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    25e6:	7bfb      	ldrb	r3, [r7, #15]
    25e8:	f003 030f 	and.w	r3, r3, #15
    25ec:	73fb      	strb	r3, [r7, #15]
	tmp |= PORT_PMUX_PMUXO(data);
    25ee:	787b      	ldrb	r3, [r7, #1]
    25f0:	011b      	lsls	r3, r3, #4
    25f2:	b2da      	uxtb	r2, r3
    25f4:	7bfb      	ldrb	r3, [r7, #15]
    25f6:	4313      	orrs	r3, r2
    25f8:	73fb      	strb	r3, [r7, #15]
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    25fa:	78fa      	ldrb	r2, [r7, #3]
    25fc:	78bb      	ldrb	r3, [r7, #2]
    25fe:	6879      	ldr	r1, [r7, #4]
    2600:	01d2      	lsls	r2, r2, #7
    2602:	440a      	add	r2, r1
    2604:	4413      	add	r3, r2
    2606:	3330      	adds	r3, #48	; 0x30
    2608:	7bfa      	ldrb	r2, [r7, #15]
    260a:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    260c:	bf00      	nop
    260e:	3714      	adds	r7, #20
    2610:	46bd      	mov	sp, r7
    2612:	f85d 7b04 	ldr.w	r7, [sp], #4
    2616:	4770      	bx	lr

00002618 <hri_port_write_PINCFG_PMUXEN_bit>:
	return (bool)tmp;
}

static inline void hri_port_write_PINCFG_PMUXEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                    bool value)
{
    2618:	b480      	push	{r7}
    261a:	b085      	sub	sp, #20
    261c:	af00      	add	r7, sp, #0
    261e:	6078      	str	r0, [r7, #4]
    2620:	4608      	mov	r0, r1
    2622:	4611      	mov	r1, r2
    2624:	461a      	mov	r2, r3
    2626:	4603      	mov	r3, r0
    2628:	70fb      	strb	r3, [r7, #3]
    262a:	460b      	mov	r3, r1
    262c:	70bb      	strb	r3, [r7, #2]
    262e:	4613      	mov	r3, r2
    2630:	707b      	strb	r3, [r7, #1]
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    2632:	78fa      	ldrb	r2, [r7, #3]
    2634:	78bb      	ldrb	r3, [r7, #2]
    2636:	6879      	ldr	r1, [r7, #4]
    2638:	01d2      	lsls	r2, r2, #7
    263a:	440a      	add	r2, r1
    263c:	4413      	add	r3, r2
    263e:	3340      	adds	r3, #64	; 0x40
    2640:	781b      	ldrb	r3, [r3, #0]
    2642:	73fb      	strb	r3, [r7, #15]
	tmp &= ~PORT_PINCFG_PMUXEN;
    2644:	7bfb      	ldrb	r3, [r7, #15]
    2646:	f023 0301 	bic.w	r3, r3, #1
    264a:	73fb      	strb	r3, [r7, #15]
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    264c:	787a      	ldrb	r2, [r7, #1]
    264e:	7bfb      	ldrb	r3, [r7, #15]
    2650:	4313      	orrs	r3, r2
    2652:	73fb      	strb	r3, [r7, #15]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    2654:	78fa      	ldrb	r2, [r7, #3]
    2656:	78bb      	ldrb	r3, [r7, #2]
    2658:	6879      	ldr	r1, [r7, #4]
    265a:	01d2      	lsls	r2, r2, #7
    265c:	440a      	add	r2, r1
    265e:	4413      	add	r3, r2
    2660:	3340      	adds	r3, #64	; 0x40
    2662:	7bfa      	ldrb	r2, [r7, #15]
    2664:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    2666:	bf00      	nop
    2668:	3714      	adds	r7, #20
    266a:	46bd      	mov	sp, r7
    266c:	f85d 7b04 	ldr.w	r7, [sp], #4
    2670:	4770      	bx	lr

00002672 <hri_port_set_PINCFG_PULLEN_bit>:
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg ^= PORT_PINCFG_INEN;
	PORT_CRITICAL_SECTION_LEAVE();
}

static inline void hri_port_set_PINCFG_PULLEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index)
{
    2672:	b480      	push	{r7}
    2674:	b083      	sub	sp, #12
    2676:	af00      	add	r7, sp, #0
    2678:	6078      	str	r0, [r7, #4]
    267a:	460b      	mov	r3, r1
    267c:	70fb      	strb	r3, [r7, #3]
    267e:	4613      	mov	r3, r2
    2680:	70bb      	strb	r3, [r7, #2]
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    2682:	78fa      	ldrb	r2, [r7, #3]
    2684:	78bb      	ldrb	r3, [r7, #2]
    2686:	6879      	ldr	r1, [r7, #4]
    2688:	01d2      	lsls	r2, r2, #7
    268a:	440a      	add	r2, r1
    268c:	4413      	add	r3, r2
    268e:	3340      	adds	r3, #64	; 0x40
    2690:	781b      	ldrb	r3, [r3, #0]
    2692:	b2d9      	uxtb	r1, r3
    2694:	78fa      	ldrb	r2, [r7, #3]
    2696:	78bb      	ldrb	r3, [r7, #2]
    2698:	f041 0104 	orr.w	r1, r1, #4
    269c:	b2c8      	uxtb	r0, r1
    269e:	6879      	ldr	r1, [r7, #4]
    26a0:	01d2      	lsls	r2, r2, #7
    26a2:	440a      	add	r2, r1
    26a4:	4413      	add	r3, r2
    26a6:	3340      	adds	r3, #64	; 0x40
    26a8:	4602      	mov	r2, r0
    26aa:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    26ac:	bf00      	nop
    26ae:	370c      	adds	r7, #12
    26b0:	46bd      	mov	sp, r7
    26b2:	f85d 7b04 	ldr.w	r7, [sp], #4
    26b6:	4770      	bx	lr

000026b8 <hri_port_clear_PINCFG_PULLEN_bit>:
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
	PORT_CRITICAL_SECTION_LEAVE();
}

static inline void hri_port_clear_PINCFG_PULLEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index)
{
    26b8:	b480      	push	{r7}
    26ba:	b083      	sub	sp, #12
    26bc:	af00      	add	r7, sp, #0
    26be:	6078      	str	r0, [r7, #4]
    26c0:	460b      	mov	r3, r1
    26c2:	70fb      	strb	r3, [r7, #3]
    26c4:	4613      	mov	r3, r2
    26c6:	70bb      	strb	r3, [r7, #2]
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    26c8:	78fa      	ldrb	r2, [r7, #3]
    26ca:	78bb      	ldrb	r3, [r7, #2]
    26cc:	6879      	ldr	r1, [r7, #4]
    26ce:	01d2      	lsls	r2, r2, #7
    26d0:	440a      	add	r2, r1
    26d2:	4413      	add	r3, r2
    26d4:	3340      	adds	r3, #64	; 0x40
    26d6:	781b      	ldrb	r3, [r3, #0]
    26d8:	b2d9      	uxtb	r1, r3
    26da:	78fa      	ldrb	r2, [r7, #3]
    26dc:	78bb      	ldrb	r3, [r7, #2]
    26de:	f021 0104 	bic.w	r1, r1, #4
    26e2:	b2c8      	uxtb	r0, r1
    26e4:	6879      	ldr	r1, [r7, #4]
    26e6:	01d2      	lsls	r2, r2, #7
    26e8:	440a      	add	r2, r1
    26ea:	4413      	add	r3, r2
    26ec:	3340      	adds	r3, #64	; 0x40
    26ee:	4602      	mov	r2, r0
    26f0:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    26f2:	bf00      	nop
    26f4:	370c      	adds	r7, #12
    26f6:	46bd      	mov	sp, r7
    26f8:	f85d 7b04 	ldr.w	r7, [sp], #4
    26fc:	4770      	bx	lr

000026fe <hri_port_write_WRCONFIG_reg>:
	return ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
}

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
    26fe:	b480      	push	{r7}
    2700:	b085      	sub	sp, #20
    2702:	af00      	add	r7, sp, #0
    2704:	60f8      	str	r0, [r7, #12]
    2706:	460b      	mov	r3, r1
    2708:	607a      	str	r2, [r7, #4]
    270a:	72fb      	strb	r3, [r7, #11]
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    270c:	7afb      	ldrb	r3, [r7, #11]
    270e:	68fa      	ldr	r2, [r7, #12]
    2710:	01db      	lsls	r3, r3, #7
    2712:	4413      	add	r3, r2
    2714:	3328      	adds	r3, #40	; 0x28
    2716:	687a      	ldr	r2, [r7, #4]
    2718:	601a      	str	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
    271a:	bf00      	nop
    271c:	3714      	adds	r7, #20
    271e:	46bd      	mov	sp, r7
    2720:	f85d 7b04 	ldr.w	r7, [sp], #4
    2724:	4770      	bx	lr
	...

00002728 <_gpio_set_direction>:
{
    2728:	b580      	push	{r7, lr}
    272a:	b082      	sub	sp, #8
    272c:	af00      	add	r7, sp, #0
    272e:	4603      	mov	r3, r0
    2730:	6039      	str	r1, [r7, #0]
    2732:	71fb      	strb	r3, [r7, #7]
    2734:	4613      	mov	r3, r2
    2736:	71bb      	strb	r3, [r7, #6]
	switch (direction) {
    2738:	79bb      	ldrb	r3, [r7, #6]
    273a:	2b02      	cmp	r3, #2
    273c:	d03c      	beq.n	27b8 <_gpio_set_direction+0x90>
    273e:	2b02      	cmp	r3, #2
    2740:	dc53      	bgt.n	27ea <_gpio_set_direction+0xc2>
    2742:	2b00      	cmp	r3, #0
    2744:	d002      	beq.n	274c <_gpio_set_direction+0x24>
    2746:	2b01      	cmp	r3, #1
    2748:	d019      	beq.n	277e <_gpio_set_direction+0x56>
    274a:	e04e      	b.n	27ea <_gpio_set_direction+0xc2>
		hri_port_clear_DIR_reg(PORT, port, mask);
    274c:	79fb      	ldrb	r3, [r7, #7]
    274e:	683a      	ldr	r2, [r7, #0]
    2750:	4619      	mov	r1, r3
    2752:	482b      	ldr	r0, [pc, #172]	; (2800 <_gpio_set_direction+0xd8>)
    2754:	4b2b      	ldr	r3, [pc, #172]	; (2804 <_gpio_set_direction+0xdc>)
    2756:	4798      	blx	r3
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
    2758:	683b      	ldr	r3, [r7, #0]
    275a:	b29b      	uxth	r3, r3
    275c:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
    2760:	79fb      	ldrb	r3, [r7, #7]
    2762:	4619      	mov	r1, r3
    2764:	4826      	ldr	r0, [pc, #152]	; (2800 <_gpio_set_direction+0xd8>)
    2766:	4b28      	ldr	r3, [pc, #160]	; (2808 <_gpio_set_direction+0xe0>)
    2768:	4798      	blx	r3
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
    276a:	683b      	ldr	r3, [r7, #0]
    276c:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(
    276e:	f043 4240 	orr.w	r2, r3, #3221225472	; 0xc0000000
    2772:	79fb      	ldrb	r3, [r7, #7]
    2774:	4619      	mov	r1, r3
    2776:	4822      	ldr	r0, [pc, #136]	; (2800 <_gpio_set_direction+0xd8>)
    2778:	4b23      	ldr	r3, [pc, #140]	; (2808 <_gpio_set_direction+0xe0>)
    277a:	4798      	blx	r3
		break;
    277c:	e03b      	b.n	27f6 <_gpio_set_direction+0xce>
		hri_port_clear_DIR_reg(PORT, port, mask);
    277e:	79fb      	ldrb	r3, [r7, #7]
    2780:	683a      	ldr	r2, [r7, #0]
    2782:	4619      	mov	r1, r3
    2784:	481e      	ldr	r0, [pc, #120]	; (2800 <_gpio_set_direction+0xd8>)
    2786:	4b1f      	ldr	r3, [pc, #124]	; (2804 <_gpio_set_direction+0xdc>)
    2788:	4798      	blx	r3
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN | (mask & 0xffff));
    278a:	683b      	ldr	r3, [r7, #0]
    278c:	b29b      	uxth	r3, r3
    278e:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    2792:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    2796:	79f9      	ldrb	r1, [r7, #7]
    2798:	461a      	mov	r2, r3
    279a:	4819      	ldr	r0, [pc, #100]	; (2800 <_gpio_set_direction+0xd8>)
    279c:	4b1a      	ldr	r3, [pc, #104]	; (2808 <_gpio_set_direction+0xe0>)
    279e:	4798      	blx	r3
		                                | ((mask & 0xffff0000) >> 16));
    27a0:	683b      	ldr	r3, [r7, #0]
    27a2:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(PORT,
    27a4:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
    27a8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    27ac:	79f9      	ldrb	r1, [r7, #7]
    27ae:	461a      	mov	r2, r3
    27b0:	4813      	ldr	r0, [pc, #76]	; (2800 <_gpio_set_direction+0xd8>)
    27b2:	4b15      	ldr	r3, [pc, #84]	; (2808 <_gpio_set_direction+0xe0>)
    27b4:	4798      	blx	r3
		break;
    27b6:	e01e      	b.n	27f6 <_gpio_set_direction+0xce>
		hri_port_set_DIR_reg(PORT, port, mask);
    27b8:	79fb      	ldrb	r3, [r7, #7]
    27ba:	683a      	ldr	r2, [r7, #0]
    27bc:	4619      	mov	r1, r3
    27be:	4810      	ldr	r0, [pc, #64]	; (2800 <_gpio_set_direction+0xd8>)
    27c0:	4b12      	ldr	r3, [pc, #72]	; (280c <_gpio_set_direction+0xe4>)
    27c2:	4798      	blx	r3
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
    27c4:	683b      	ldr	r3, [r7, #0]
    27c6:	b29b      	uxth	r3, r3
    27c8:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
    27cc:	79fb      	ldrb	r3, [r7, #7]
    27ce:	4619      	mov	r1, r3
    27d0:	480b      	ldr	r0, [pc, #44]	; (2800 <_gpio_set_direction+0xd8>)
    27d2:	4b0d      	ldr	r3, [pc, #52]	; (2808 <_gpio_set_direction+0xe0>)
    27d4:	4798      	blx	r3
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
    27d6:	683b      	ldr	r3, [r7, #0]
    27d8:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(
    27da:	f043 4240 	orr.w	r2, r3, #3221225472	; 0xc0000000
    27de:	79fb      	ldrb	r3, [r7, #7]
    27e0:	4619      	mov	r1, r3
    27e2:	4807      	ldr	r0, [pc, #28]	; (2800 <_gpio_set_direction+0xd8>)
    27e4:	4b08      	ldr	r3, [pc, #32]	; (2808 <_gpio_set_direction+0xe0>)
    27e6:	4798      	blx	r3
		break;
    27e8:	e005      	b.n	27f6 <_gpio_set_direction+0xce>
		ASSERT(false);
    27ea:	2246      	movs	r2, #70	; 0x46
    27ec:	4908      	ldr	r1, [pc, #32]	; (2810 <_gpio_set_direction+0xe8>)
    27ee:	2000      	movs	r0, #0
    27f0:	4b08      	ldr	r3, [pc, #32]	; (2814 <_gpio_set_direction+0xec>)
    27f2:	4798      	blx	r3
}
    27f4:	bf00      	nop
    27f6:	bf00      	nop
    27f8:	3708      	adds	r7, #8
    27fa:	46bd      	mov	sp, r7
    27fc:	bd80      	pop	{r7, pc}
    27fe:	bf00      	nop
    2800:	41008000 	.word	0x41008000
    2804:	000024e3 	.word	0x000024e3
    2808:	000026ff 	.word	0x000026ff
    280c:	000024bb 	.word	0x000024bb
    2810:	000055c8 	.word	0x000055c8
    2814:	00001c39 	.word	0x00001c39

00002818 <_gpio_set_level>:
{
    2818:	b580      	push	{r7, lr}
    281a:	b082      	sub	sp, #8
    281c:	af00      	add	r7, sp, #0
    281e:	4603      	mov	r3, r0
    2820:	6039      	str	r1, [r7, #0]
    2822:	71fb      	strb	r3, [r7, #7]
    2824:	4613      	mov	r3, r2
    2826:	71bb      	strb	r3, [r7, #6]
	if (level) {
    2828:	79bb      	ldrb	r3, [r7, #6]
    282a:	2b00      	cmp	r3, #0
    282c:	d006      	beq.n	283c <_gpio_set_level+0x24>
		hri_port_set_OUT_reg(PORT, port, mask);
    282e:	79fb      	ldrb	r3, [r7, #7]
    2830:	683a      	ldr	r2, [r7, #0]
    2832:	4619      	mov	r1, r3
    2834:	4806      	ldr	r0, [pc, #24]	; (2850 <_gpio_set_level+0x38>)
    2836:	4b07      	ldr	r3, [pc, #28]	; (2854 <_gpio_set_level+0x3c>)
    2838:	4798      	blx	r3
}
    283a:	e005      	b.n	2848 <_gpio_set_level+0x30>
		hri_port_clear_OUT_reg(PORT, port, mask);
    283c:	79fb      	ldrb	r3, [r7, #7]
    283e:	683a      	ldr	r2, [r7, #0]
    2840:	4619      	mov	r1, r3
    2842:	4803      	ldr	r0, [pc, #12]	; (2850 <_gpio_set_level+0x38>)
    2844:	4b04      	ldr	r3, [pc, #16]	; (2858 <_gpio_set_level+0x40>)
    2846:	4798      	blx	r3
}
    2848:	bf00      	nop
    284a:	3708      	adds	r7, #8
    284c:	46bd      	mov	sp, r7
    284e:	bd80      	pop	{r7, pc}
    2850:	41008000 	.word	0x41008000
    2854:	0000250b 	.word	0x0000250b
    2858:	00002533 	.word	0x00002533

0000285c <_gpio_set_pin_pull_mode>:
/**
 * \brief Set pin pull mode
 */
static inline void _gpio_set_pin_pull_mode(const enum gpio_port port, const uint8_t pin,
                                           const enum gpio_pull_mode pull_mode)
{
    285c:	b580      	push	{r7, lr}
    285e:	b082      	sub	sp, #8
    2860:	af00      	add	r7, sp, #0
    2862:	4603      	mov	r3, r0
    2864:	71fb      	strb	r3, [r7, #7]
    2866:	460b      	mov	r3, r1
    2868:	71bb      	strb	r3, [r7, #6]
    286a:	4613      	mov	r3, r2
    286c:	717b      	strb	r3, [r7, #5]
	switch (pull_mode) {
    286e:	797b      	ldrb	r3, [r7, #5]
    2870:	2b02      	cmp	r3, #2
    2872:	d024      	beq.n	28be <_gpio_set_pin_pull_mode+0x62>
    2874:	2b02      	cmp	r3, #2
    2876:	dc39      	bgt.n	28ec <_gpio_set_pin_pull_mode+0x90>
    2878:	2b00      	cmp	r3, #0
    287a:	d002      	beq.n	2882 <_gpio_set_pin_pull_mode+0x26>
    287c:	2b01      	cmp	r3, #1
    287e:	d007      	beq.n	2890 <_gpio_set_pin_pull_mode+0x34>
    2880:	e034      	b.n	28ec <_gpio_set_pin_pull_mode+0x90>
	case GPIO_PULL_OFF:
		hri_port_clear_PINCFG_PULLEN_bit(PORT, port, pin);
    2882:	79ba      	ldrb	r2, [r7, #6]
    2884:	79fb      	ldrb	r3, [r7, #7]
    2886:	4619      	mov	r1, r3
    2888:	481d      	ldr	r0, [pc, #116]	; (2900 <_gpio_set_pin_pull_mode+0xa4>)
    288a:	4b1e      	ldr	r3, [pc, #120]	; (2904 <_gpio_set_pin_pull_mode+0xa8>)
    288c:	4798      	blx	r3
		break;
    288e:	e033      	b.n	28f8 <_gpio_set_pin_pull_mode+0x9c>

	case GPIO_PULL_UP:
		hri_port_clear_DIR_reg(PORT, port, 1U << pin);
    2890:	79bb      	ldrb	r3, [r7, #6]
    2892:	2201      	movs	r2, #1
    2894:	409a      	lsls	r2, r3
    2896:	79fb      	ldrb	r3, [r7, #7]
    2898:	4619      	mov	r1, r3
    289a:	4819      	ldr	r0, [pc, #100]	; (2900 <_gpio_set_pin_pull_mode+0xa4>)
    289c:	4b1a      	ldr	r3, [pc, #104]	; (2908 <_gpio_set_pin_pull_mode+0xac>)
    289e:	4798      	blx	r3
		hri_port_set_PINCFG_PULLEN_bit(PORT, port, pin);
    28a0:	79ba      	ldrb	r2, [r7, #6]
    28a2:	79fb      	ldrb	r3, [r7, #7]
    28a4:	4619      	mov	r1, r3
    28a6:	4816      	ldr	r0, [pc, #88]	; (2900 <_gpio_set_pin_pull_mode+0xa4>)
    28a8:	4b18      	ldr	r3, [pc, #96]	; (290c <_gpio_set_pin_pull_mode+0xb0>)
    28aa:	4798      	blx	r3
		hri_port_set_OUT_reg(PORT, port, 1U << pin);
    28ac:	79bb      	ldrb	r3, [r7, #6]
    28ae:	2201      	movs	r2, #1
    28b0:	409a      	lsls	r2, r3
    28b2:	79fb      	ldrb	r3, [r7, #7]
    28b4:	4619      	mov	r1, r3
    28b6:	4812      	ldr	r0, [pc, #72]	; (2900 <_gpio_set_pin_pull_mode+0xa4>)
    28b8:	4b15      	ldr	r3, [pc, #84]	; (2910 <_gpio_set_pin_pull_mode+0xb4>)
    28ba:	4798      	blx	r3
		break;
    28bc:	e01c      	b.n	28f8 <_gpio_set_pin_pull_mode+0x9c>

	case GPIO_PULL_DOWN:
		hri_port_clear_DIR_reg(PORT, port, 1U << pin);
    28be:	79bb      	ldrb	r3, [r7, #6]
    28c0:	2201      	movs	r2, #1
    28c2:	409a      	lsls	r2, r3
    28c4:	79fb      	ldrb	r3, [r7, #7]
    28c6:	4619      	mov	r1, r3
    28c8:	480d      	ldr	r0, [pc, #52]	; (2900 <_gpio_set_pin_pull_mode+0xa4>)
    28ca:	4b0f      	ldr	r3, [pc, #60]	; (2908 <_gpio_set_pin_pull_mode+0xac>)
    28cc:	4798      	blx	r3
		hri_port_set_PINCFG_PULLEN_bit(PORT, port, pin);
    28ce:	79ba      	ldrb	r2, [r7, #6]
    28d0:	79fb      	ldrb	r3, [r7, #7]
    28d2:	4619      	mov	r1, r3
    28d4:	480a      	ldr	r0, [pc, #40]	; (2900 <_gpio_set_pin_pull_mode+0xa4>)
    28d6:	4b0d      	ldr	r3, [pc, #52]	; (290c <_gpio_set_pin_pull_mode+0xb0>)
    28d8:	4798      	blx	r3
		hri_port_clear_OUT_reg(PORT, port, 1U << pin);
    28da:	79bb      	ldrb	r3, [r7, #6]
    28dc:	2201      	movs	r2, #1
    28de:	409a      	lsls	r2, r3
    28e0:	79fb      	ldrb	r3, [r7, #7]
    28e2:	4619      	mov	r1, r3
    28e4:	4806      	ldr	r0, [pc, #24]	; (2900 <_gpio_set_pin_pull_mode+0xa4>)
    28e6:	4b0b      	ldr	r3, [pc, #44]	; (2914 <_gpio_set_pin_pull_mode+0xb8>)
    28e8:	4798      	blx	r3
		break;
    28ea:	e005      	b.n	28f8 <_gpio_set_pin_pull_mode+0x9c>

	default:
		ASSERT(false);
    28ec:	2289      	movs	r2, #137	; 0x89
    28ee:	490a      	ldr	r1, [pc, #40]	; (2918 <_gpio_set_pin_pull_mode+0xbc>)
    28f0:	2000      	movs	r0, #0
    28f2:	4b0a      	ldr	r3, [pc, #40]	; (291c <_gpio_set_pin_pull_mode+0xc0>)
    28f4:	4798      	blx	r3
		break;
    28f6:	bf00      	nop
	}
}
    28f8:	bf00      	nop
    28fa:	3708      	adds	r7, #8
    28fc:	46bd      	mov	sp, r7
    28fe:	bd80      	pop	{r7, pc}
    2900:	41008000 	.word	0x41008000
    2904:	000026b9 	.word	0x000026b9
    2908:	000024e3 	.word	0x000024e3
    290c:	00002673 	.word	0x00002673
    2910:	0000250b 	.word	0x0000250b
    2914:	00002533 	.word	0x00002533
    2918:	000055c8 	.word	0x000055c8
    291c:	00001c39 	.word	0x00001c39

00002920 <_gpio_set_pin_function>:

/**
 * \brief Set gpio pin function
 */
static inline void _gpio_set_pin_function(const uint32_t gpio, const uint32_t function)
{
    2920:	b590      	push	{r4, r7, lr}
    2922:	b085      	sub	sp, #20
    2924:	af00      	add	r7, sp, #0
    2926:	6078      	str	r0, [r7, #4]
    2928:	6039      	str	r1, [r7, #0]
	uint8_t port = GPIO_PORT(gpio);
    292a:	687b      	ldr	r3, [r7, #4]
    292c:	095b      	lsrs	r3, r3, #5
    292e:	73fb      	strb	r3, [r7, #15]
	uint8_t pin  = GPIO_PIN(gpio);
    2930:	687b      	ldr	r3, [r7, #4]
    2932:	b2db      	uxtb	r3, r3
    2934:	f003 031f 	and.w	r3, r3, #31
    2938:	73bb      	strb	r3, [r7, #14]

	if (function == GPIO_PIN_FUNCTION_OFF) {
    293a:	683b      	ldr	r3, [r7, #0]
    293c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
    2940:	d106      	bne.n	2950 <_gpio_set_pin_function+0x30>
		hri_port_write_PINCFG_PMUXEN_bit(PORT, port, pin, false);
    2942:	7bba      	ldrb	r2, [r7, #14]
    2944:	7bf9      	ldrb	r1, [r7, #15]
    2946:	2300      	movs	r3, #0
    2948:	4812      	ldr	r0, [pc, #72]	; (2994 <_gpio_set_pin_function+0x74>)
    294a:	4c13      	ldr	r4, [pc, #76]	; (2998 <_gpio_set_pin_function+0x78>)
    294c:	47a0      	blx	r4
		} else {
			// Even numbered pin
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
		}
	}
}
    294e:	e01d      	b.n	298c <_gpio_set_pin_function+0x6c>
		hri_port_write_PINCFG_PMUXEN_bit(PORT, port, pin, true);
    2950:	7bba      	ldrb	r2, [r7, #14]
    2952:	7bf9      	ldrb	r1, [r7, #15]
    2954:	2301      	movs	r3, #1
    2956:	480f      	ldr	r0, [pc, #60]	; (2994 <_gpio_set_pin_function+0x74>)
    2958:	4c0f      	ldr	r4, [pc, #60]	; (2998 <_gpio_set_pin_function+0x78>)
    295a:	47a0      	blx	r4
		if (pin & 1) {
    295c:	7bbb      	ldrb	r3, [r7, #14]
    295e:	f003 0301 	and.w	r3, r3, #1
    2962:	2b00      	cmp	r3, #0
    2964:	d009      	beq.n	297a <_gpio_set_pin_function+0x5a>
			hri_port_write_PMUX_PMUXO_bf(PORT, port, pin >> 1, function & 0xffff);
    2966:	7bbb      	ldrb	r3, [r7, #14]
    2968:	085b      	lsrs	r3, r3, #1
    296a:	b2da      	uxtb	r2, r3
    296c:	683b      	ldr	r3, [r7, #0]
    296e:	b2db      	uxtb	r3, r3
    2970:	7bf9      	ldrb	r1, [r7, #15]
    2972:	4808      	ldr	r0, [pc, #32]	; (2994 <_gpio_set_pin_function+0x74>)
    2974:	4c09      	ldr	r4, [pc, #36]	; (299c <_gpio_set_pin_function+0x7c>)
    2976:	47a0      	blx	r4
}
    2978:	e008      	b.n	298c <_gpio_set_pin_function+0x6c>
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
    297a:	7bbb      	ldrb	r3, [r7, #14]
    297c:	085b      	lsrs	r3, r3, #1
    297e:	b2da      	uxtb	r2, r3
    2980:	683b      	ldr	r3, [r7, #0]
    2982:	b2db      	uxtb	r3, r3
    2984:	7bf9      	ldrb	r1, [r7, #15]
    2986:	4803      	ldr	r0, [pc, #12]	; (2994 <_gpio_set_pin_function+0x74>)
    2988:	4c05      	ldr	r4, [pc, #20]	; (29a0 <_gpio_set_pin_function+0x80>)
    298a:	47a0      	blx	r4
}
    298c:	bf00      	nop
    298e:	3714      	adds	r7, #20
    2990:	46bd      	mov	sp, r7
    2992:	bd90      	pop	{r4, r7, pc}
    2994:	41008000 	.word	0x41008000
    2998:	00002619 	.word	0x00002619
    299c:	000025bb 	.word	0x000025bb
    29a0:	0000255b 	.word	0x0000255b

000029a4 <gpio_set_pin_pull_mode>:
{
    29a4:	b580      	push	{r7, lr}
    29a6:	b082      	sub	sp, #8
    29a8:	af00      	add	r7, sp, #0
    29aa:	4603      	mov	r3, r0
    29ac:	460a      	mov	r2, r1
    29ae:	71fb      	strb	r3, [r7, #7]
    29b0:	4613      	mov	r3, r2
    29b2:	71bb      	strb	r3, [r7, #6]
	_gpio_set_pin_pull_mode((enum gpio_port)GPIO_PORT(pin), pin & 0x1F, pull_mode);
    29b4:	79fb      	ldrb	r3, [r7, #7]
    29b6:	095b      	lsrs	r3, r3, #5
    29b8:	b2d8      	uxtb	r0, r3
    29ba:	79fb      	ldrb	r3, [r7, #7]
    29bc:	f003 031f 	and.w	r3, r3, #31
    29c0:	b2db      	uxtb	r3, r3
    29c2:	79ba      	ldrb	r2, [r7, #6]
    29c4:	4619      	mov	r1, r3
    29c6:	4b03      	ldr	r3, [pc, #12]	; (29d4 <gpio_set_pin_pull_mode+0x30>)
    29c8:	4798      	blx	r3
}
    29ca:	bf00      	nop
    29cc:	3708      	adds	r7, #8
    29ce:	46bd      	mov	sp, r7
    29d0:	bd80      	pop	{r7, pc}
    29d2:	bf00      	nop
    29d4:	0000285d 	.word	0x0000285d

000029d8 <gpio_set_pin_function>:
{
    29d8:	b580      	push	{r7, lr}
    29da:	b082      	sub	sp, #8
    29dc:	af00      	add	r7, sp, #0
    29de:	6078      	str	r0, [r7, #4]
    29e0:	6039      	str	r1, [r7, #0]
	_gpio_set_pin_function(pin, function);
    29e2:	6839      	ldr	r1, [r7, #0]
    29e4:	6878      	ldr	r0, [r7, #4]
    29e6:	4b03      	ldr	r3, [pc, #12]	; (29f4 <gpio_set_pin_function+0x1c>)
    29e8:	4798      	blx	r3
}
    29ea:	bf00      	nop
    29ec:	3708      	adds	r7, #8
    29ee:	46bd      	mov	sp, r7
    29f0:	bd80      	pop	{r7, pc}
    29f2:	bf00      	nop
    29f4:	00002921 	.word	0x00002921

000029f8 <gpio_set_pin_direction>:
{
    29f8:	b580      	push	{r7, lr}
    29fa:	b082      	sub	sp, #8
    29fc:	af00      	add	r7, sp, #0
    29fe:	4603      	mov	r3, r0
    2a00:	460a      	mov	r2, r1
    2a02:	71fb      	strb	r3, [r7, #7]
    2a04:	4613      	mov	r3, r2
    2a06:	71bb      	strb	r3, [r7, #6]
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    2a08:	79fb      	ldrb	r3, [r7, #7]
    2a0a:	095b      	lsrs	r3, r3, #5
    2a0c:	b2d8      	uxtb	r0, r3
    2a0e:	79fb      	ldrb	r3, [r7, #7]
    2a10:	f003 031f 	and.w	r3, r3, #31
    2a14:	2201      	movs	r2, #1
    2a16:	fa02 f303 	lsl.w	r3, r2, r3
    2a1a:	79ba      	ldrb	r2, [r7, #6]
    2a1c:	4619      	mov	r1, r3
    2a1e:	4b03      	ldr	r3, [pc, #12]	; (2a2c <gpio_set_pin_direction+0x34>)
    2a20:	4798      	blx	r3
}
    2a22:	bf00      	nop
    2a24:	3708      	adds	r7, #8
    2a26:	46bd      	mov	sp, r7
    2a28:	bd80      	pop	{r7, pc}
    2a2a:	bf00      	nop
    2a2c:	00002729 	.word	0x00002729

00002a30 <gpio_set_pin_level>:
{
    2a30:	b580      	push	{r7, lr}
    2a32:	b082      	sub	sp, #8
    2a34:	af00      	add	r7, sp, #0
    2a36:	4603      	mov	r3, r0
    2a38:	460a      	mov	r2, r1
    2a3a:	71fb      	strb	r3, [r7, #7]
    2a3c:	4613      	mov	r3, r2
    2a3e:	71bb      	strb	r3, [r7, #6]
	_gpio_set_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), level);
    2a40:	79fb      	ldrb	r3, [r7, #7]
    2a42:	095b      	lsrs	r3, r3, #5
    2a44:	b2d8      	uxtb	r0, r3
    2a46:	79fb      	ldrb	r3, [r7, #7]
    2a48:	f003 031f 	and.w	r3, r3, #31
    2a4c:	2201      	movs	r2, #1
    2a4e:	fa02 f303 	lsl.w	r3, r2, r3
    2a52:	79ba      	ldrb	r2, [r7, #6]
    2a54:	4619      	mov	r1, r3
    2a56:	4b03      	ldr	r3, [pc, #12]	; (2a64 <gpio_set_pin_level+0x34>)
    2a58:	4798      	blx	r3
}
    2a5a:	bf00      	nop
    2a5c:	3708      	adds	r7, #8
    2a5e:	46bd      	mov	sp, r7
    2a60:	bd80      	pop	{r7, pc}
    2a62:	bf00      	nop
    2a64:	00002819 	.word	0x00002819

00002a68 <init_mcu>:
 * This function calls the various initialization functions.
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
    2a68:	b580      	push	{r7, lr}
    2a6a:	af00      	add	r7, sp, #0
	_init_chip();
    2a6c:	4b01      	ldr	r3, [pc, #4]	; (2a74 <init_mcu+0xc>)
    2a6e:	4798      	blx	r3
}
    2a70:	bf00      	nop
    2a72:	bd80      	pop	{r7, pc}
    2a74:	00001b01 	.word	0x00001b01

00002a78 <wdt_init>:
 * \return Operation status of init
 * \retval 0 Completed sucessfully.
 * \retval -1 Always on or enabled, don't need init again.
 */
static inline int32_t wdt_init(struct wdt_descriptor *const wdt, const void *hw)
{
    2a78:	b580      	push	{r7, lr}
    2a7a:	b082      	sub	sp, #8
    2a7c:	af00      	add	r7, sp, #0
    2a7e:	6078      	str	r0, [r7, #4]
    2a80:	6039      	str	r1, [r7, #0]
	ASSERT(wdt && hw);
    2a82:	687b      	ldr	r3, [r7, #4]
    2a84:	2b00      	cmp	r3, #0
    2a86:	d004      	beq.n	2a92 <wdt_init+0x1a>
    2a88:	683b      	ldr	r3, [r7, #0]
    2a8a:	2b00      	cmp	r3, #0
    2a8c:	d001      	beq.n	2a92 <wdt_init+0x1a>
    2a8e:	2301      	movs	r3, #1
    2a90:	e000      	b.n	2a94 <wdt_init+0x1c>
    2a92:	2300      	movs	r3, #0
    2a94:	f003 0301 	and.w	r3, r3, #1
    2a98:	b2db      	uxtb	r3, r3
    2a9a:	2248      	movs	r2, #72	; 0x48
    2a9c:	4907      	ldr	r1, [pc, #28]	; (2abc <wdt_init+0x44>)
    2a9e:	4618      	mov	r0, r3
    2aa0:	4b07      	ldr	r3, [pc, #28]	; (2ac0 <wdt_init+0x48>)
    2aa2:	4798      	blx	r3

	wdt->dev.hw = (void *)hw;
    2aa4:	687b      	ldr	r3, [r7, #4]
    2aa6:	683a      	ldr	r2, [r7, #0]
    2aa8:	601a      	str	r2, [r3, #0]

	return _wdt_init(&wdt->dev);
    2aaa:	687b      	ldr	r3, [r7, #4]
    2aac:	4618      	mov	r0, r3
    2aae:	4b05      	ldr	r3, [pc, #20]	; (2ac4 <wdt_init+0x4c>)
    2ab0:	4798      	blx	r3
    2ab2:	4603      	mov	r3, r0
}
    2ab4:	4618      	mov	r0, r3
    2ab6:	3708      	adds	r7, #8
    2ab8:	46bd      	mov	sp, r7
    2aba:	bd80      	pop	{r7, pc}
    2abc:	000055e4 	.word	0x000055e4
    2ac0:	00001c39 	.word	0x00001c39
    2ac4:	000015a1 	.word	0x000015a1

00002ac8 <ADC_0_PORT_init>:
struct i2c_m_sync_desc I2C_0;

struct wdt_descriptor WDT_0;

void ADC_0_PORT_init(void)
{
    2ac8:	b480      	push	{r7}
    2aca:	af00      	add	r7, sp, #0
}
    2acc:	bf00      	nop
    2ace:	46bd      	mov	sp, r7
    2ad0:	f85d 7b04 	ldr.w	r7, [sp], #4
    2ad4:	4770      	bx	lr
	...

00002ad8 <ADC_0_CLOCK_init>:

void ADC_0_CLOCK_init(void)
{
    2ad8:	b580      	push	{r7, lr}
    2ada:	af00      	add	r7, sp, #0
	hri_mclk_set_APBDMASK_ADC0_bit(MCLK);
    2adc:	4804      	ldr	r0, [pc, #16]	; (2af0 <ADC_0_CLOCK_init+0x18>)
    2ade:	4b05      	ldr	r3, [pc, #20]	; (2af4 <ADC_0_CLOCK_init+0x1c>)
    2ae0:	4798      	blx	r3
	hri_gclk_write_PCHCTRL_reg(GCLK, ADC0_GCLK_ID, CONF_GCLK_ADC0_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
    2ae2:	2241      	movs	r2, #65	; 0x41
    2ae4:	2128      	movs	r1, #40	; 0x28
    2ae6:	4804      	ldr	r0, [pc, #16]	; (2af8 <ADC_0_CLOCK_init+0x20>)
    2ae8:	4b04      	ldr	r3, [pc, #16]	; (2afc <ADC_0_CLOCK_init+0x24>)
    2aea:	4798      	blx	r3
}
    2aec:	bf00      	nop
    2aee:	bd80      	pop	{r7, pc}
    2af0:	40000800 	.word	0x40000800
    2af4:	0000247b 	.word	0x0000247b
    2af8:	40001c00 	.word	0x40001c00
    2afc:	000023d5 	.word	0x000023d5

00002b00 <ADC_0_init>:

void ADC_0_init(void)
{
    2b00:	b580      	push	{r7, lr}
    2b02:	af00      	add	r7, sp, #0
	ADC_0_CLOCK_init();
    2b04:	4b05      	ldr	r3, [pc, #20]	; (2b1c <ADC_0_init+0x1c>)
    2b06:	4798      	blx	r3
	ADC_0_PORT_init();
    2b08:	4b05      	ldr	r3, [pc, #20]	; (2b20 <ADC_0_init+0x20>)
    2b0a:	4798      	blx	r3
	adc_sync_init(&ADC_0, ADC0, (void *)NULL);
    2b0c:	2200      	movs	r2, #0
    2b0e:	4905      	ldr	r1, [pc, #20]	; (2b24 <ADC_0_init+0x24>)
    2b10:	4805      	ldr	r0, [pc, #20]	; (2b28 <ADC_0_init+0x28>)
    2b12:	4b06      	ldr	r3, [pc, #24]	; (2b2c <ADC_0_init+0x2c>)
    2b14:	4798      	blx	r3
}
    2b16:	bf00      	nop
    2b18:	bd80      	pop	{r7, pc}
    2b1a:	bf00      	nop
    2b1c:	00002ad9 	.word	0x00002ad9
    2b20:	00002ac9 	.word	0x00002ac9
    2b24:	43001c00 	.word	0x43001c00
    2b28:	2000053c 	.word	0x2000053c
    2b2c:	00002e99 	.word	0x00002e99

00002b30 <ADC_1_PORT_init>:

void ADC_1_PORT_init(void)
{
    2b30:	b480      	push	{r7}
    2b32:	af00      	add	r7, sp, #0
}
    2b34:	bf00      	nop
    2b36:	46bd      	mov	sp, r7
    2b38:	f85d 7b04 	ldr.w	r7, [sp], #4
    2b3c:	4770      	bx	lr
	...

00002b40 <ADC_1_CLOCK_init>:

void ADC_1_CLOCK_init(void)
{
    2b40:	b580      	push	{r7, lr}
    2b42:	af00      	add	r7, sp, #0
	hri_mclk_set_APBDMASK_ADC1_bit(MCLK);
    2b44:	4804      	ldr	r0, [pc, #16]	; (2b58 <ADC_1_CLOCK_init+0x18>)
    2b46:	4b05      	ldr	r3, [pc, #20]	; (2b5c <ADC_1_CLOCK_init+0x1c>)
    2b48:	4798      	blx	r3
	hri_gclk_write_PCHCTRL_reg(GCLK, ADC1_GCLK_ID, CONF_GCLK_ADC1_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
    2b4a:	2240      	movs	r2, #64	; 0x40
    2b4c:	2129      	movs	r1, #41	; 0x29
    2b4e:	4804      	ldr	r0, [pc, #16]	; (2b60 <ADC_1_CLOCK_init+0x20>)
    2b50:	4b04      	ldr	r3, [pc, #16]	; (2b64 <ADC_1_CLOCK_init+0x24>)
    2b52:	4798      	blx	r3
}
    2b54:	bf00      	nop
    2b56:	bd80      	pop	{r7, pc}
    2b58:	40000800 	.word	0x40000800
    2b5c:	0000249b 	.word	0x0000249b
    2b60:	40001c00 	.word	0x40001c00
    2b64:	000023d5 	.word	0x000023d5

00002b68 <ADC_1_init>:

void ADC_1_init(void)
{
    2b68:	b580      	push	{r7, lr}
    2b6a:	af00      	add	r7, sp, #0
	ADC_1_CLOCK_init();
    2b6c:	4b05      	ldr	r3, [pc, #20]	; (2b84 <ADC_1_init+0x1c>)
    2b6e:	4798      	blx	r3
	ADC_1_PORT_init();
    2b70:	4b05      	ldr	r3, [pc, #20]	; (2b88 <ADC_1_init+0x20>)
    2b72:	4798      	blx	r3
	adc_sync_init(&ADC_1, ADC1, (void *)NULL);
    2b74:	2200      	movs	r2, #0
    2b76:	4905      	ldr	r1, [pc, #20]	; (2b8c <ADC_1_init+0x24>)
    2b78:	4805      	ldr	r0, [pc, #20]	; (2b90 <ADC_1_init+0x28>)
    2b7a:	4b06      	ldr	r3, [pc, #24]	; (2b94 <ADC_1_init+0x2c>)
    2b7c:	4798      	blx	r3
}
    2b7e:	bf00      	nop
    2b80:	bd80      	pop	{r7, pc}
    2b82:	bf00      	nop
    2b84:	00002b41 	.word	0x00002b41
    2b88:	00002b31 	.word	0x00002b31
    2b8c:	43002000 	.word	0x43002000
    2b90:	20000540 	.word	0x20000540
    2b94:	00002e99 	.word	0x00002e99

00002b98 <USART_0_PORT_init>:

void USART_0_PORT_init(void)
{
    2b98:	b580      	push	{r7, lr}
    2b9a:	af00      	add	r7, sp, #0

	gpio_set_pin_function(PA04, PINMUX_PA04D_SERCOM0_PAD0);
    2b9c:	4904      	ldr	r1, [pc, #16]	; (2bb0 <USART_0_PORT_init+0x18>)
    2b9e:	2004      	movs	r0, #4
    2ba0:	4b04      	ldr	r3, [pc, #16]	; (2bb4 <USART_0_PORT_init+0x1c>)
    2ba2:	4798      	blx	r3

	gpio_set_pin_function(PA05, PINMUX_PA05D_SERCOM0_PAD1);
    2ba4:	4904      	ldr	r1, [pc, #16]	; (2bb8 <USART_0_PORT_init+0x20>)
    2ba6:	2005      	movs	r0, #5
    2ba8:	4b02      	ldr	r3, [pc, #8]	; (2bb4 <USART_0_PORT_init+0x1c>)
    2baa:	4798      	blx	r3
}
    2bac:	bf00      	nop
    2bae:	bd80      	pop	{r7, pc}
    2bb0:	00040003 	.word	0x00040003
    2bb4:	000029d9 	.word	0x000029d9
    2bb8:	00050003 	.word	0x00050003

00002bbc <USART_0_CLOCK_init>:

void USART_0_CLOCK_init(void)
{
    2bbc:	b580      	push	{r7, lr}
    2bbe:	af00      	add	r7, sp, #0
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM0_GCLK_ID_CORE, CONF_GCLK_SERCOM0_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
    2bc0:	2240      	movs	r2, #64	; 0x40
    2bc2:	2107      	movs	r1, #7
    2bc4:	4806      	ldr	r0, [pc, #24]	; (2be0 <USART_0_CLOCK_init+0x24>)
    2bc6:	4b07      	ldr	r3, [pc, #28]	; (2be4 <USART_0_CLOCK_init+0x28>)
    2bc8:	4798      	blx	r3
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM0_GCLK_ID_SLOW, CONF_GCLK_SERCOM0_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
    2bca:	2243      	movs	r2, #67	; 0x43
    2bcc:	2103      	movs	r1, #3
    2bce:	4804      	ldr	r0, [pc, #16]	; (2be0 <USART_0_CLOCK_init+0x24>)
    2bd0:	4b04      	ldr	r3, [pc, #16]	; (2be4 <USART_0_CLOCK_init+0x28>)
    2bd2:	4798      	blx	r3

	hri_mclk_set_APBAMASK_SERCOM0_bit(MCLK);
    2bd4:	4804      	ldr	r0, [pc, #16]	; (2be8 <USART_0_CLOCK_init+0x2c>)
    2bd6:	4b05      	ldr	r3, [pc, #20]	; (2bec <USART_0_CLOCK_init+0x30>)
    2bd8:	4798      	blx	r3
}
    2bda:	bf00      	nop
    2bdc:	bd80      	pop	{r7, pc}
    2bde:	bf00      	nop
    2be0:	40001c00 	.word	0x40001c00
    2be4:	000023d5 	.word	0x000023d5
    2be8:	40000800 	.word	0x40000800
    2bec:	0000241b 	.word	0x0000241b

00002bf0 <USART_0_init>:

void USART_0_init(void)
{
    2bf0:	b580      	push	{r7, lr}
    2bf2:	af00      	add	r7, sp, #0
	USART_0_CLOCK_init();
    2bf4:	4b05      	ldr	r3, [pc, #20]	; (2c0c <USART_0_init+0x1c>)
    2bf6:	4798      	blx	r3
	usart_sync_init(&USART_0, SERCOM0, (void *)NULL);
    2bf8:	2200      	movs	r2, #0
    2bfa:	4905      	ldr	r1, [pc, #20]	; (2c10 <USART_0_init+0x20>)
    2bfc:	4805      	ldr	r0, [pc, #20]	; (2c14 <USART_0_init+0x24>)
    2bfe:	4b06      	ldr	r3, [pc, #24]	; (2c18 <USART_0_init+0x28>)
    2c00:	4798      	blx	r3
	USART_0_PORT_init();
    2c02:	4b06      	ldr	r3, [pc, #24]	; (2c1c <USART_0_init+0x2c>)
    2c04:	4798      	blx	r3
}
    2c06:	bf00      	nop
    2c08:	bd80      	pop	{r7, pc}
    2c0a:	bf00      	nop
    2c0c:	00002bbd 	.word	0x00002bbd
    2c10:	40003000 	.word	0x40003000
    2c14:	20000544 	.word	0x20000544
    2c18:	00002071 	.word	0x00002071
    2c1c:	00002b99 	.word	0x00002b99

00002c20 <SPI_0_PORT_init>:

void SPI_0_PORT_init(void)
{
    2c20:	b580      	push	{r7, lr}
    2c22:	af00      	add	r7, sp, #0

	gpio_set_pin_level(PB26,
    2c24:	2100      	movs	r1, #0
    2c26:	203a      	movs	r0, #58	; 0x3a
    2c28:	4b11      	ldr	r3, [pc, #68]	; (2c70 <SPI_0_PORT_init+0x50>)
    2c2a:	4798      	blx	r3
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PB26, GPIO_DIRECTION_OUT);
    2c2c:	2102      	movs	r1, #2
    2c2e:	203a      	movs	r0, #58	; 0x3a
    2c30:	4b10      	ldr	r3, [pc, #64]	; (2c74 <SPI_0_PORT_init+0x54>)
    2c32:	4798      	blx	r3

	gpio_set_pin_function(PB26, PINMUX_PB26C_SERCOM2_PAD0);
    2c34:	4910      	ldr	r1, [pc, #64]	; (2c78 <SPI_0_PORT_init+0x58>)
    2c36:	203a      	movs	r0, #58	; 0x3a
    2c38:	4b10      	ldr	r3, [pc, #64]	; (2c7c <SPI_0_PORT_init+0x5c>)
    2c3a:	4798      	blx	r3

	gpio_set_pin_level(PB27,
    2c3c:	2100      	movs	r1, #0
    2c3e:	203b      	movs	r0, #59	; 0x3b
    2c40:	4b0b      	ldr	r3, [pc, #44]	; (2c70 <SPI_0_PORT_init+0x50>)
    2c42:	4798      	blx	r3
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PB27, GPIO_DIRECTION_OUT);
    2c44:	2102      	movs	r1, #2
    2c46:	203b      	movs	r0, #59	; 0x3b
    2c48:	4b0a      	ldr	r3, [pc, #40]	; (2c74 <SPI_0_PORT_init+0x54>)
    2c4a:	4798      	blx	r3

	gpio_set_pin_function(PB27, PINMUX_PB27C_SERCOM2_PAD1);
    2c4c:	490c      	ldr	r1, [pc, #48]	; (2c80 <SPI_0_PORT_init+0x60>)
    2c4e:	203b      	movs	r0, #59	; 0x3b
    2c50:	4b0a      	ldr	r3, [pc, #40]	; (2c7c <SPI_0_PORT_init+0x5c>)
    2c52:	4798      	blx	r3

	// Set pin direction to input
	gpio_set_pin_direction(PB29, GPIO_DIRECTION_IN);
    2c54:	2101      	movs	r1, #1
    2c56:	203d      	movs	r0, #61	; 0x3d
    2c58:	4b06      	ldr	r3, [pc, #24]	; (2c74 <SPI_0_PORT_init+0x54>)
    2c5a:	4798      	blx	r3

	gpio_set_pin_pull_mode(PB29,
    2c5c:	2100      	movs	r1, #0
    2c5e:	203d      	movs	r0, #61	; 0x3d
    2c60:	4b08      	ldr	r3, [pc, #32]	; (2c84 <SPI_0_PORT_init+0x64>)
    2c62:	4798      	blx	r3
	                       // <GPIO_PULL_OFF"> Off
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PB29, PINMUX_PB29C_SERCOM2_PAD3);
    2c64:	4908      	ldr	r1, [pc, #32]	; (2c88 <SPI_0_PORT_init+0x68>)
    2c66:	203d      	movs	r0, #61	; 0x3d
    2c68:	4b04      	ldr	r3, [pc, #16]	; (2c7c <SPI_0_PORT_init+0x5c>)
    2c6a:	4798      	blx	r3
}
    2c6c:	bf00      	nop
    2c6e:	bd80      	pop	{r7, pc}
    2c70:	00002a31 	.word	0x00002a31
    2c74:	000029f9 	.word	0x000029f9
    2c78:	003a0002 	.word	0x003a0002
    2c7c:	000029d9 	.word	0x000029d9
    2c80:	003b0002 	.word	0x003b0002
    2c84:	000029a5 	.word	0x000029a5
    2c88:	003d0002 	.word	0x003d0002

00002c8c <SPI_0_CLOCK_init>:

void SPI_0_CLOCK_init(void)
{
    2c8c:	b580      	push	{r7, lr}
    2c8e:	af00      	add	r7, sp, #0
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM2_GCLK_ID_CORE, CONF_GCLK_SERCOM2_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
    2c90:	2242      	movs	r2, #66	; 0x42
    2c92:	2117      	movs	r1, #23
    2c94:	4806      	ldr	r0, [pc, #24]	; (2cb0 <SPI_0_CLOCK_init+0x24>)
    2c96:	4b07      	ldr	r3, [pc, #28]	; (2cb4 <SPI_0_CLOCK_init+0x28>)
    2c98:	4798      	blx	r3
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM2_GCLK_ID_SLOW, CONF_GCLK_SERCOM2_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
    2c9a:	2243      	movs	r2, #67	; 0x43
    2c9c:	2103      	movs	r1, #3
    2c9e:	4804      	ldr	r0, [pc, #16]	; (2cb0 <SPI_0_CLOCK_init+0x24>)
    2ca0:	4b04      	ldr	r3, [pc, #16]	; (2cb4 <SPI_0_CLOCK_init+0x28>)
    2ca2:	4798      	blx	r3

	hri_mclk_set_APBBMASK_SERCOM2_bit(MCLK);
    2ca4:	4804      	ldr	r0, [pc, #16]	; (2cb8 <SPI_0_CLOCK_init+0x2c>)
    2ca6:	4b05      	ldr	r3, [pc, #20]	; (2cbc <SPI_0_CLOCK_init+0x30>)
    2ca8:	4798      	blx	r3
}
    2caa:	bf00      	nop
    2cac:	bd80      	pop	{r7, pc}
    2cae:	bf00      	nop
    2cb0:	40001c00 	.word	0x40001c00
    2cb4:	000023d5 	.word	0x000023d5
    2cb8:	40000800 	.word	0x40000800
    2cbc:	0000243b 	.word	0x0000243b

00002cc0 <SPI_0_init>:

void SPI_0_init(void)
{
    2cc0:	b580      	push	{r7, lr}
    2cc2:	af00      	add	r7, sp, #0
	SPI_0_CLOCK_init();
    2cc4:	4b04      	ldr	r3, [pc, #16]	; (2cd8 <SPI_0_init+0x18>)
    2cc6:	4798      	blx	r3
	spi_m_sync_init(&SPI_0, SERCOM2);
    2cc8:	4904      	ldr	r1, [pc, #16]	; (2cdc <SPI_0_init+0x1c>)
    2cca:	4805      	ldr	r0, [pc, #20]	; (2ce0 <SPI_0_init+0x20>)
    2ccc:	4b05      	ldr	r3, [pc, #20]	; (2ce4 <SPI_0_init+0x24>)
    2cce:	4798      	blx	r3
	SPI_0_PORT_init();
    2cd0:	4b05      	ldr	r3, [pc, #20]	; (2ce8 <SPI_0_init+0x28>)
    2cd2:	4798      	blx	r3
}
    2cd4:	bf00      	nop
    2cd6:	bd80      	pop	{r7, pc}
    2cd8:	00002c8d 	.word	0x00002c8d
    2cdc:	41012000 	.word	0x41012000
    2ce0:	20000524 	.word	0x20000524
    2ce4:	00001761 	.word	0x00001761
    2ce8:	00002c21 	.word	0x00002c21

00002cec <I2C_0_PORT_init>:

void I2C_0_PORT_init(void)
{
    2cec:	b580      	push	{r7, lr}
    2cee:	af00      	add	r7, sp, #0

	gpio_set_pin_pull_mode(PA17,
    2cf0:	2100      	movs	r1, #0
    2cf2:	2011      	movs	r0, #17
    2cf4:	4b07      	ldr	r3, [pc, #28]	; (2d14 <I2C_0_PORT_init+0x28>)
    2cf6:	4798      	blx	r3
	                       // <GPIO_PULL_OFF"> Off
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA17, PINMUX_PA17D_SERCOM3_PAD0);
    2cf8:	4907      	ldr	r1, [pc, #28]	; (2d18 <I2C_0_PORT_init+0x2c>)
    2cfa:	2011      	movs	r0, #17
    2cfc:	4b07      	ldr	r3, [pc, #28]	; (2d1c <I2C_0_PORT_init+0x30>)
    2cfe:	4798      	blx	r3

	gpio_set_pin_pull_mode(PA16,
    2d00:	2100      	movs	r1, #0
    2d02:	2010      	movs	r0, #16
    2d04:	4b03      	ldr	r3, [pc, #12]	; (2d14 <I2C_0_PORT_init+0x28>)
    2d06:	4798      	blx	r3
	                       // <GPIO_PULL_OFF"> Off
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA16, PINMUX_PA16D_SERCOM3_PAD1);
    2d08:	4905      	ldr	r1, [pc, #20]	; (2d20 <I2C_0_PORT_init+0x34>)
    2d0a:	2010      	movs	r0, #16
    2d0c:	4b03      	ldr	r3, [pc, #12]	; (2d1c <I2C_0_PORT_init+0x30>)
    2d0e:	4798      	blx	r3
}
    2d10:	bf00      	nop
    2d12:	bd80      	pop	{r7, pc}
    2d14:	000029a5 	.word	0x000029a5
    2d18:	00110003 	.word	0x00110003
    2d1c:	000029d9 	.word	0x000029d9
    2d20:	00100003 	.word	0x00100003

00002d24 <I2C_0_CLOCK_init>:

void I2C_0_CLOCK_init(void)
{
    2d24:	b580      	push	{r7, lr}
    2d26:	af00      	add	r7, sp, #0
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM3_GCLK_ID_CORE, CONF_GCLK_SERCOM3_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
    2d28:	2240      	movs	r2, #64	; 0x40
    2d2a:	2118      	movs	r1, #24
    2d2c:	4806      	ldr	r0, [pc, #24]	; (2d48 <I2C_0_CLOCK_init+0x24>)
    2d2e:	4b07      	ldr	r3, [pc, #28]	; (2d4c <I2C_0_CLOCK_init+0x28>)
    2d30:	4798      	blx	r3
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM3_GCLK_ID_SLOW, CONF_GCLK_SERCOM3_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
    2d32:	2243      	movs	r2, #67	; 0x43
    2d34:	2103      	movs	r1, #3
    2d36:	4804      	ldr	r0, [pc, #16]	; (2d48 <I2C_0_CLOCK_init+0x24>)
    2d38:	4b04      	ldr	r3, [pc, #16]	; (2d4c <I2C_0_CLOCK_init+0x28>)
    2d3a:	4798      	blx	r3

	hri_mclk_set_APBBMASK_SERCOM3_bit(MCLK);
    2d3c:	4804      	ldr	r0, [pc, #16]	; (2d50 <I2C_0_CLOCK_init+0x2c>)
    2d3e:	4b05      	ldr	r3, [pc, #20]	; (2d54 <I2C_0_CLOCK_init+0x30>)
    2d40:	4798      	blx	r3
}
    2d42:	bf00      	nop
    2d44:	bd80      	pop	{r7, pc}
    2d46:	bf00      	nop
    2d48:	40001c00 	.word	0x40001c00
    2d4c:	000023d5 	.word	0x000023d5
    2d50:	40000800 	.word	0x40000800
    2d54:	0000245b 	.word	0x0000245b

00002d58 <I2C_0_init>:

void I2C_0_init(void)
{
    2d58:	b580      	push	{r7, lr}
    2d5a:	af00      	add	r7, sp, #0
	I2C_0_CLOCK_init();
    2d5c:	4b04      	ldr	r3, [pc, #16]	; (2d70 <I2C_0_init+0x18>)
    2d5e:	4798      	blx	r3
	i2c_m_sync_init(&I2C_0, SERCOM3);
    2d60:	4904      	ldr	r1, [pc, #16]	; (2d74 <I2C_0_init+0x1c>)
    2d62:	4805      	ldr	r0, [pc, #20]	; (2d78 <I2C_0_init+0x20>)
    2d64:	4b05      	ldr	r3, [pc, #20]	; (2d7c <I2C_0_init+0x24>)
    2d66:	4798      	blx	r3
	I2C_0_PORT_init();
    2d68:	4b05      	ldr	r3, [pc, #20]	; (2d80 <I2C_0_init+0x28>)
    2d6a:	4798      	blx	r3
}
    2d6c:	bf00      	nop
    2d6e:	bd80      	pop	{r7, pc}
    2d70:	00002d25 	.word	0x00002d25
    2d74:	41014000 	.word	0x41014000
    2d78:	20000550 	.word	0x20000550
    2d7c:	00001995 	.word	0x00001995
    2d80:	00002ced 	.word	0x00002ced

00002d84 <delay_driver_init>:

void delay_driver_init(void)
{
    2d84:	b580      	push	{r7, lr}
    2d86:	af00      	add	r7, sp, #0
	delay_init(SysTick);
    2d88:	4802      	ldr	r0, [pc, #8]	; (2d94 <delay_driver_init+0x10>)
    2d8a:	4b03      	ldr	r3, [pc, #12]	; (2d98 <delay_driver_init+0x14>)
    2d8c:	4798      	blx	r3
}
    2d8e:	bf00      	nop
    2d90:	bd80      	pop	{r7, pc}
    2d92:	bf00      	nop
    2d94:	e000e010 	.word	0xe000e010
    2d98:	00001a71 	.word	0x00001a71

00002d9c <WDT_0_CLOCK_init>:

void WDT_0_CLOCK_init(void)
{
    2d9c:	b580      	push	{r7, lr}
    2d9e:	af00      	add	r7, sp, #0
	hri_mclk_set_APBAMASK_WDT_bit(MCLK);
    2da0:	4802      	ldr	r0, [pc, #8]	; (2dac <WDT_0_CLOCK_init+0x10>)
    2da2:	4b03      	ldr	r3, [pc, #12]	; (2db0 <WDT_0_CLOCK_init+0x14>)
    2da4:	4798      	blx	r3
}
    2da6:	bf00      	nop
    2da8:	bd80      	pop	{r7, pc}
    2daa:	bf00      	nop
    2dac:	40000800 	.word	0x40000800
    2db0:	000023fb 	.word	0x000023fb

00002db4 <WDT_0_init>:

void WDT_0_init(void)
{
    2db4:	b580      	push	{r7, lr}
    2db6:	af00      	add	r7, sp, #0
	WDT_0_CLOCK_init();
    2db8:	4b03      	ldr	r3, [pc, #12]	; (2dc8 <WDT_0_init+0x14>)
    2dba:	4798      	blx	r3
	wdt_init(&WDT_0, WDT);
    2dbc:	4903      	ldr	r1, [pc, #12]	; (2dcc <WDT_0_init+0x18>)
    2dbe:	4804      	ldr	r0, [pc, #16]	; (2dd0 <WDT_0_init+0x1c>)
    2dc0:	4b04      	ldr	r3, [pc, #16]	; (2dd4 <WDT_0_init+0x20>)
    2dc2:	4798      	blx	r3
}
    2dc4:	bf00      	nop
    2dc6:	bd80      	pop	{r7, pc}
    2dc8:	00002d9d 	.word	0x00002d9d
    2dcc:	40002000 	.word	0x40002000
    2dd0:	20000570 	.word	0x20000570
    2dd4:	00002a79 	.word	0x00002a79

00002dd8 <system_init>:

void system_init(void)
{
    2dd8:	b580      	push	{r7, lr}
    2dda:	af00      	add	r7, sp, #0
	init_mcu();
    2ddc:	4b22      	ldr	r3, [pc, #136]	; (2e68 <system_init+0x90>)
    2dde:	4798      	blx	r3

	// GPIO on PB01

	gpio_set_pin_level(LED_Red,
    2de0:	2100      	movs	r1, #0
    2de2:	2021      	movs	r0, #33	; 0x21
    2de4:	4b21      	ldr	r3, [pc, #132]	; (2e6c <system_init+0x94>)
    2de6:	4798      	blx	r3
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(LED_Red, GPIO_DIRECTION_OUT);
    2de8:	2102      	movs	r1, #2
    2dea:	2021      	movs	r0, #33	; 0x21
    2dec:	4b20      	ldr	r3, [pc, #128]	; (2e70 <system_init+0x98>)
    2dee:	4798      	blx	r3

	gpio_set_pin_function(LED_Red, GPIO_PIN_FUNCTION_OFF);
    2df0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    2df4:	2021      	movs	r0, #33	; 0x21
    2df6:	4b1f      	ldr	r3, [pc, #124]	; (2e74 <system_init+0x9c>)
    2df8:	4798      	blx	r3

	// GPIO on PC30

	gpio_set_pin_level(LED_Orange1,
    2dfa:	2101      	movs	r1, #1
    2dfc:	205e      	movs	r0, #94	; 0x5e
    2dfe:	4b1b      	ldr	r3, [pc, #108]	; (2e6c <system_init+0x94>)
    2e00:	4798      	blx	r3
	                   // <false"> Low
	                   // <true"> High
	                   true);

	// Set pin direction to output
	gpio_set_pin_direction(LED_Orange1, GPIO_DIRECTION_OUT);
    2e02:	2102      	movs	r1, #2
    2e04:	205e      	movs	r0, #94	; 0x5e
    2e06:	4b1a      	ldr	r3, [pc, #104]	; (2e70 <system_init+0x98>)
    2e08:	4798      	blx	r3

	gpio_set_pin_function(LED_Orange1, GPIO_PIN_FUNCTION_OFF);
    2e0a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    2e0e:	205e      	movs	r0, #94	; 0x5e
    2e10:	4b18      	ldr	r3, [pc, #96]	; (2e74 <system_init+0x9c>)
    2e12:	4798      	blx	r3

	// GPIO on PC31

	gpio_set_pin_level(LED_Orange2,
    2e14:	2101      	movs	r1, #1
    2e16:	205f      	movs	r0, #95	; 0x5f
    2e18:	4b14      	ldr	r3, [pc, #80]	; (2e6c <system_init+0x94>)
    2e1a:	4798      	blx	r3
	                   // <false"> Low
	                   // <true"> High
	                   true);

	// Set pin direction to output
	gpio_set_pin_direction(LED_Orange2, GPIO_DIRECTION_OUT);
    2e1c:	2102      	movs	r1, #2
    2e1e:	205f      	movs	r0, #95	; 0x5f
    2e20:	4b13      	ldr	r3, [pc, #76]	; (2e70 <system_init+0x98>)
    2e22:	4798      	blx	r3

	gpio_set_pin_function(LED_Orange2, GPIO_PIN_FUNCTION_OFF);
    2e24:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    2e28:	205f      	movs	r0, #95	; 0x5f
    2e2a:	4b12      	ldr	r3, [pc, #72]	; (2e74 <system_init+0x9c>)
    2e2c:	4798      	blx	r3

	// GPIO on PD20

	// Set pin direction to input
	gpio_set_pin_direction(DRDY_PIN, GPIO_DIRECTION_IN);
    2e2e:	2101      	movs	r1, #1
    2e30:	2074      	movs	r0, #116	; 0x74
    2e32:	4b0f      	ldr	r3, [pc, #60]	; (2e70 <system_init+0x98>)
    2e34:	4798      	blx	r3

	gpio_set_pin_pull_mode(DRDY_PIN,
    2e36:	2102      	movs	r1, #2
    2e38:	2074      	movs	r0, #116	; 0x74
    2e3a:	4b0f      	ldr	r3, [pc, #60]	; (2e78 <system_init+0xa0>)
    2e3c:	4798      	blx	r3
	                       // <GPIO_PULL_OFF"> Off
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_DOWN);

	gpio_set_pin_function(DRDY_PIN, GPIO_PIN_FUNCTION_OFF);
    2e3e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    2e42:	2074      	movs	r0, #116	; 0x74
    2e44:	4b0b      	ldr	r3, [pc, #44]	; (2e74 <system_init+0x9c>)
    2e46:	4798      	blx	r3

	ADC_0_init();
    2e48:	4b0c      	ldr	r3, [pc, #48]	; (2e7c <system_init+0xa4>)
    2e4a:	4798      	blx	r3

	ADC_1_init();
    2e4c:	4b0c      	ldr	r3, [pc, #48]	; (2e80 <system_init+0xa8>)
    2e4e:	4798      	blx	r3

	USART_0_init();
    2e50:	4b0c      	ldr	r3, [pc, #48]	; (2e84 <system_init+0xac>)
    2e52:	4798      	blx	r3

	SPI_0_init();
    2e54:	4b0c      	ldr	r3, [pc, #48]	; (2e88 <system_init+0xb0>)
    2e56:	4798      	blx	r3

	I2C_0_init();
    2e58:	4b0c      	ldr	r3, [pc, #48]	; (2e8c <system_init+0xb4>)
    2e5a:	4798      	blx	r3

	delay_driver_init();
    2e5c:	4b0c      	ldr	r3, [pc, #48]	; (2e90 <system_init+0xb8>)
    2e5e:	4798      	blx	r3

	WDT_0_init();
    2e60:	4b0c      	ldr	r3, [pc, #48]	; (2e94 <system_init+0xbc>)
    2e62:	4798      	blx	r3
}
    2e64:	bf00      	nop
    2e66:	bd80      	pop	{r7, pc}
    2e68:	00002a69 	.word	0x00002a69
    2e6c:	00002a31 	.word	0x00002a31
    2e70:	000029f9 	.word	0x000029f9
    2e74:	000029d9 	.word	0x000029d9
    2e78:	000029a5 	.word	0x000029a5
    2e7c:	00002b01 	.word	0x00002b01
    2e80:	00002b69 	.word	0x00002b69
    2e84:	00002bf1 	.word	0x00002bf1
    2e88:	00002cc1 	.word	0x00002cc1
    2e8c:	00002d59 	.word	0x00002d59
    2e90:	00002d85 	.word	0x00002d85
    2e94:	00002db5 	.word	0x00002db5

00002e98 <adc_sync_init>:

/**
 * \brief Initialize ADC
 */
int32_t adc_sync_init(struct adc_sync_descriptor *const descr, void *const hw, void *const func)
{
    2e98:	b580      	push	{r7, lr}
    2e9a:	b084      	sub	sp, #16
    2e9c:	af00      	add	r7, sp, #0
    2e9e:	60f8      	str	r0, [r7, #12]
    2ea0:	60b9      	str	r1, [r7, #8]
    2ea2:	607a      	str	r2, [r7, #4]
	ASSERT(descr && hw);
    2ea4:	68fb      	ldr	r3, [r7, #12]
    2ea6:	2b00      	cmp	r3, #0
    2ea8:	d004      	beq.n	2eb4 <adc_sync_init+0x1c>
    2eaa:	68bb      	ldr	r3, [r7, #8]
    2eac:	2b00      	cmp	r3, #0
    2eae:	d001      	beq.n	2eb4 <adc_sync_init+0x1c>
    2eb0:	2301      	movs	r3, #1
    2eb2:	e000      	b.n	2eb6 <adc_sync_init+0x1e>
    2eb4:	2300      	movs	r3, #0
    2eb6:	f003 0301 	and.w	r3, r3, #1
    2eba:	b2db      	uxtb	r3, r3
    2ebc:	2239      	movs	r2, #57	; 0x39
    2ebe:	4907      	ldr	r1, [pc, #28]	; (2edc <adc_sync_init+0x44>)
    2ec0:	4618      	mov	r0, r3
    2ec2:	4b07      	ldr	r3, [pc, #28]	; (2ee0 <adc_sync_init+0x48>)
    2ec4:	4798      	blx	r3

	return _adc_sync_init(&descr->device, hw);
    2ec6:	68fb      	ldr	r3, [r7, #12]
    2ec8:	68b9      	ldr	r1, [r7, #8]
    2eca:	4618      	mov	r0, r3
    2ecc:	4b05      	ldr	r3, [pc, #20]	; (2ee4 <adc_sync_init+0x4c>)
    2ece:	4798      	blx	r3
    2ed0:	4603      	mov	r3, r0
}
    2ed2:	4618      	mov	r0, r3
    2ed4:	3710      	adds	r7, #16
    2ed6:	46bd      	mov	sp, r7
    2ed8:	bd80      	pop	{r7, pc}
    2eda:	bf00      	nop
    2edc:	00005600 	.word	0x00005600
    2ee0:	00001c39 	.word	0x00001c39
    2ee4:	000051f5 	.word	0x000051f5

00002ee8 <hri_sercomi2cm_wait_for_sync>:
typedef uint8_t  hri_sercomusart_intflag_reg_t;
typedef uint8_t  hri_sercomusart_rxerrcnt_reg_t;
typedef uint8_t  hri_sercomusart_rxpl_reg_t;

static inline void hri_sercomi2cm_wait_for_sync(const void *const hw, hri_sercomi2cm_syncbusy_reg_t reg)
{
    2ee8:	b480      	push	{r7}
    2eea:	b083      	sub	sp, #12
    2eec:	af00      	add	r7, sp, #0
    2eee:	6078      	str	r0, [r7, #4]
    2ef0:	6039      	str	r1, [r7, #0]
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
    2ef2:	bf00      	nop
    2ef4:	687b      	ldr	r3, [r7, #4]
    2ef6:	69da      	ldr	r2, [r3, #28]
    2ef8:	683b      	ldr	r3, [r7, #0]
    2efa:	4013      	ands	r3, r2
    2efc:	2b00      	cmp	r3, #0
    2efe:	d1f9      	bne.n	2ef4 <hri_sercomi2cm_wait_for_sync+0xc>
	};
}
    2f00:	bf00      	nop
    2f02:	bf00      	nop
    2f04:	370c      	adds	r7, #12
    2f06:	46bd      	mov	sp, r7
    2f08:	f85d 7b04 	ldr.w	r7, [sp], #4
    2f0c:	4770      	bx	lr

00002f0e <hri_sercomi2cm_is_syncing>:

static inline bool hri_sercomi2cm_is_syncing(const void *const hw, hri_sercomi2cm_syncbusy_reg_t reg)
{
    2f0e:	b480      	push	{r7}
    2f10:	b083      	sub	sp, #12
    2f12:	af00      	add	r7, sp, #0
    2f14:	6078      	str	r0, [r7, #4]
    2f16:	6039      	str	r1, [r7, #0]
	return ((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg;
    2f18:	687b      	ldr	r3, [r7, #4]
    2f1a:	69da      	ldr	r2, [r3, #28]
    2f1c:	683b      	ldr	r3, [r7, #0]
    2f1e:	4013      	ands	r3, r2
    2f20:	2b00      	cmp	r3, #0
    2f22:	bf14      	ite	ne
    2f24:	2301      	movne	r3, #1
    2f26:	2300      	moveq	r3, #0
    2f28:	b2db      	uxtb	r3, r3
}
    2f2a:	4618      	mov	r0, r3
    2f2c:	370c      	adds	r7, #12
    2f2e:	46bd      	mov	sp, r7
    2f30:	f85d 7b04 	ldr.w	r7, [sp], #4
    2f34:	4770      	bx	lr

00002f36 <hri_sercomspi_wait_for_sync>:
{
	return ((Sercom *)hw)->I2CS.SYNCBUSY.reg & reg;
}

static inline void hri_sercomspi_wait_for_sync(const void *const hw, hri_sercomspi_syncbusy_reg_t reg)
{
    2f36:	b480      	push	{r7}
    2f38:	b083      	sub	sp, #12
    2f3a:	af00      	add	r7, sp, #0
    2f3c:	6078      	str	r0, [r7, #4]
    2f3e:	6039      	str	r1, [r7, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2f40:	bf00      	nop
    2f42:	687b      	ldr	r3, [r7, #4]
    2f44:	69da      	ldr	r2, [r3, #28]
    2f46:	683b      	ldr	r3, [r7, #0]
    2f48:	4013      	ands	r3, r2
    2f4a:	2b00      	cmp	r3, #0
    2f4c:	d1f9      	bne.n	2f42 <hri_sercomspi_wait_for_sync+0xc>
	};
}
    2f4e:	bf00      	nop
    2f50:	bf00      	nop
    2f52:	370c      	adds	r7, #12
    2f54:	46bd      	mov	sp, r7
    2f56:	f85d 7b04 	ldr.w	r7, [sp], #4
    2f5a:	4770      	bx	lr

00002f5c <hri_sercomspi_is_syncing>:

static inline bool hri_sercomspi_is_syncing(const void *const hw, hri_sercomspi_syncbusy_reg_t reg)
{
    2f5c:	b480      	push	{r7}
    2f5e:	b083      	sub	sp, #12
    2f60:	af00      	add	r7, sp, #0
    2f62:	6078      	str	r0, [r7, #4]
    2f64:	6039      	str	r1, [r7, #0]
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
    2f66:	687b      	ldr	r3, [r7, #4]
    2f68:	69da      	ldr	r2, [r3, #28]
    2f6a:	683b      	ldr	r3, [r7, #0]
    2f6c:	4013      	ands	r3, r2
    2f6e:	2b00      	cmp	r3, #0
    2f70:	bf14      	ite	ne
    2f72:	2301      	movne	r3, #1
    2f74:	2300      	moveq	r3, #0
    2f76:	b2db      	uxtb	r3, r3
}
    2f78:	4618      	mov	r0, r3
    2f7a:	370c      	adds	r7, #12
    2f7c:	46bd      	mov	sp, r7
    2f7e:	f85d 7b04 	ldr.w	r7, [sp], #4
    2f82:	4770      	bx	lr

00002f84 <hri_sercomusart_wait_for_sync>:

static inline void hri_sercomusart_wait_for_sync(const void *const hw, hri_sercomusart_syncbusy_reg_t reg)
{
    2f84:	b480      	push	{r7}
    2f86:	b083      	sub	sp, #12
    2f88:	af00      	add	r7, sp, #0
    2f8a:	6078      	str	r0, [r7, #4]
    2f8c:	6039      	str	r1, [r7, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    2f8e:	bf00      	nop
    2f90:	687b      	ldr	r3, [r7, #4]
    2f92:	69da      	ldr	r2, [r3, #28]
    2f94:	683b      	ldr	r3, [r7, #0]
    2f96:	4013      	ands	r3, r2
    2f98:	2b00      	cmp	r3, #0
    2f9a:	d1f9      	bne.n	2f90 <hri_sercomusart_wait_for_sync+0xc>
	};
}
    2f9c:	bf00      	nop
    2f9e:	bf00      	nop
    2fa0:	370c      	adds	r7, #12
    2fa2:	46bd      	mov	sp, r7
    2fa4:	f85d 7b04 	ldr.w	r7, [sp], #4
    2fa8:	4770      	bx	lr

00002faa <hri_sercomusart_is_syncing>:

static inline bool hri_sercomusart_is_syncing(const void *const hw, hri_sercomusart_syncbusy_reg_t reg)
{
    2faa:	b480      	push	{r7}
    2fac:	b083      	sub	sp, #12
    2fae:	af00      	add	r7, sp, #0
    2fb0:	6078      	str	r0, [r7, #4]
    2fb2:	6039      	str	r1, [r7, #0]
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
    2fb4:	687b      	ldr	r3, [r7, #4]
    2fb6:	69da      	ldr	r2, [r3, #28]
    2fb8:	683b      	ldr	r3, [r7, #0]
    2fba:	4013      	ands	r3, r2
    2fbc:	2b00      	cmp	r3, #0
    2fbe:	bf14      	ite	ne
    2fc0:	2301      	movne	r3, #1
    2fc2:	2300      	moveq	r3, #0
    2fc4:	b2db      	uxtb	r3, r3
}
    2fc6:	4618      	mov	r0, r3
    2fc8:	370c      	adds	r7, #12
    2fca:	46bd      	mov	sp, r7
    2fcc:	f85d 7b04 	ldr.w	r7, [sp], #4
    2fd0:	4770      	bx	lr

00002fd2 <hri_sercomi2cm_clear_interrupt_MB_bit>:
{
	return (((Sercom *)hw)->I2CM.INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB) >> SERCOM_I2CM_INTFLAG_MB_Pos;
}

static inline void hri_sercomi2cm_clear_interrupt_MB_bit(const void *const hw)
{
    2fd2:	b480      	push	{r7}
    2fd4:	b083      	sub	sp, #12
    2fd6:	af00      	add	r7, sp, #0
    2fd8:	6078      	str	r0, [r7, #4]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
    2fda:	687b      	ldr	r3, [r7, #4]
    2fdc:	2201      	movs	r2, #1
    2fde:	761a      	strb	r2, [r3, #24]
}
    2fe0:	bf00      	nop
    2fe2:	370c      	adds	r7, #12
    2fe4:	46bd      	mov	sp, r7
    2fe6:	f85d 7b04 	ldr.w	r7, [sp], #4
    2fea:	4770      	bx	lr

00002fec <hri_sercomi2cm_clear_interrupt_SB_bit>:
{
	return (((Sercom *)hw)->I2CM.INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB) >> SERCOM_I2CM_INTFLAG_SB_Pos;
}

static inline void hri_sercomi2cm_clear_interrupt_SB_bit(const void *const hw)
{
    2fec:	b480      	push	{r7}
    2fee:	b083      	sub	sp, #12
    2ff0:	af00      	add	r7, sp, #0
    2ff2:	6078      	str	r0, [r7, #4]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
    2ff4:	687b      	ldr	r3, [r7, #4]
    2ff6:	2202      	movs	r2, #2
    2ff8:	761a      	strb	r2, [r3, #24]
}
    2ffa:	bf00      	nop
    2ffc:	370c      	adds	r7, #12
    2ffe:	46bd      	mov	sp, r7
    3000:	f85d 7b04 	ldr.w	r7, [sp], #4
    3004:	4770      	bx	lr

00003006 <hri_sercomi2cm_read_INTFLAG_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_sercomi2cm_intflag_reg_t hri_sercomi2cm_read_INTFLAG_reg(const void *const hw)
{
    3006:	b480      	push	{r7}
    3008:	b083      	sub	sp, #12
    300a:	af00      	add	r7, sp, #0
    300c:	6078      	str	r0, [r7, #4]
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
    300e:	687b      	ldr	r3, [r7, #4]
    3010:	7e1b      	ldrb	r3, [r3, #24]
    3012:	b2db      	uxtb	r3, r3
}
    3014:	4618      	mov	r0, r3
    3016:	370c      	adds	r7, #12
    3018:	46bd      	mov	sp, r7
    301a:	f85d 7b04 	ldr.w	r7, [sp], #4
    301e:	4770      	bx	lr

00003020 <hri_sercomspi_get_INTFLAG_reg>:
	((Sercom *)hw)->SPI.INTFLAG.reg = SERCOM_SPI_INTFLAG_ERROR;
}

static inline hri_sercomspi_intflag_reg_t hri_sercomspi_get_INTFLAG_reg(const void *const           hw,
                                                                        hri_sercomspi_intflag_reg_t mask)
{
    3020:	b480      	push	{r7}
    3022:	b085      	sub	sp, #20
    3024:	af00      	add	r7, sp, #0
    3026:	6078      	str	r0, [r7, #4]
    3028:	460b      	mov	r3, r1
    302a:	70fb      	strb	r3, [r7, #3]
	uint8_t tmp;
	tmp = ((Sercom *)hw)->SPI.INTFLAG.reg;
    302c:	687b      	ldr	r3, [r7, #4]
    302e:	7e1b      	ldrb	r3, [r3, #24]
    3030:	73fb      	strb	r3, [r7, #15]
	tmp &= mask;
    3032:	7bfa      	ldrb	r2, [r7, #15]
    3034:	78fb      	ldrb	r3, [r7, #3]
    3036:	4013      	ands	r3, r2
    3038:	73fb      	strb	r3, [r7, #15]
	return tmp;
    303a:	7bfb      	ldrb	r3, [r7, #15]
}
    303c:	4618      	mov	r0, r3
    303e:	3714      	adds	r7, #20
    3040:	46bd      	mov	sp, r7
    3042:	f85d 7b04 	ldr.w	r7, [sp], #4
    3046:	4770      	bx	lr

00003048 <hri_sercomspi_read_INTFLAG_reg>:

static inline hri_sercomspi_intflag_reg_t hri_sercomspi_read_INTFLAG_reg(const void *const hw)
{
    3048:	b480      	push	{r7}
    304a:	b083      	sub	sp, #12
    304c:	af00      	add	r7, sp, #0
    304e:	6078      	str	r0, [r7, #4]
	return ((Sercom *)hw)->SPI.INTFLAG.reg;
    3050:	687b      	ldr	r3, [r7, #4]
    3052:	7e1b      	ldrb	r3, [r3, #24]
    3054:	b2db      	uxtb	r3, r3
}
    3056:	4618      	mov	r0, r3
    3058:	370c      	adds	r7, #12
    305a:	46bd      	mov	sp, r7
    305c:	f85d 7b04 	ldr.w	r7, [sp], #4
    3060:	4770      	bx	lr

00003062 <hri_sercomspi_clear_INTFLAG_reg>:

static inline void hri_sercomspi_clear_INTFLAG_reg(const void *const hw, hri_sercomspi_intflag_reg_t mask)
{
    3062:	b480      	push	{r7}
    3064:	b083      	sub	sp, #12
    3066:	af00      	add	r7, sp, #0
    3068:	6078      	str	r0, [r7, #4]
    306a:	460b      	mov	r3, r1
    306c:	70fb      	strb	r3, [r7, #3]
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    306e:	687b      	ldr	r3, [r7, #4]
    3070:	78fa      	ldrb	r2, [r7, #3]
    3072:	761a      	strb	r2, [r3, #24]
}
    3074:	bf00      	nop
    3076:	370c      	adds	r7, #12
    3078:	46bd      	mov	sp, r7
    307a:	f85d 7b04 	ldr.w	r7, [sp], #4
    307e:	4770      	bx	lr

00003080 <hri_sercomusart_get_interrupt_DRE_bit>:
{
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
}

static inline bool hri_sercomusart_get_interrupt_DRE_bit(const void *const hw)
{
    3080:	b480      	push	{r7}
    3082:	b083      	sub	sp, #12
    3084:	af00      	add	r7, sp, #0
    3086:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    3088:	687b      	ldr	r3, [r7, #4]
    308a:	7e1b      	ldrb	r3, [r3, #24]
    308c:	b2db      	uxtb	r3, r3
    308e:	f003 0301 	and.w	r3, r3, #1
    3092:	2b00      	cmp	r3, #0
    3094:	bf14      	ite	ne
    3096:	2301      	movne	r3, #1
    3098:	2300      	moveq	r3, #0
    309a:	b2db      	uxtb	r3, r3
}
    309c:	4618      	mov	r0, r3
    309e:	370c      	adds	r7, #12
    30a0:	46bd      	mov	sp, r7
    30a2:	f85d 7b04 	ldr.w	r7, [sp], #4
    30a6:	4770      	bx	lr

000030a8 <hri_sercomusart_get_interrupt_TXC_bit>:
{
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_DRE;
}

static inline bool hri_sercomusart_get_interrupt_TXC_bit(const void *const hw)
{
    30a8:	b480      	push	{r7}
    30aa:	b083      	sub	sp, #12
    30ac:	af00      	add	r7, sp, #0
    30ae:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    30b0:	687b      	ldr	r3, [r7, #4]
    30b2:	7e1b      	ldrb	r3, [r3, #24]
    30b4:	b2db      	uxtb	r3, r3
    30b6:	085b      	lsrs	r3, r3, #1
    30b8:	f003 0301 	and.w	r3, r3, #1
    30bc:	2b00      	cmp	r3, #0
    30be:	bf14      	ite	ne
    30c0:	2301      	movne	r3, #1
    30c2:	2300      	moveq	r3, #0
    30c4:	b2db      	uxtb	r3, r3
}
    30c6:	4618      	mov	r0, r3
    30c8:	370c      	adds	r7, #12
    30ca:	46bd      	mov	sp, r7
    30cc:	f85d 7b04 	ldr.w	r7, [sp], #4
    30d0:	4770      	bx	lr

000030d2 <hri_sercomusart_get_interrupt_RXC_bit>:
{
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_TXC;
}

static inline bool hri_sercomusart_get_interrupt_RXC_bit(const void *const hw)
{
    30d2:	b480      	push	{r7}
    30d4:	b083      	sub	sp, #12
    30d6:	af00      	add	r7, sp, #0
    30d8:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    30da:	687b      	ldr	r3, [r7, #4]
    30dc:	7e1b      	ldrb	r3, [r3, #24]
    30de:	b2db      	uxtb	r3, r3
    30e0:	089b      	lsrs	r3, r3, #2
    30e2:	f003 0301 	and.w	r3, r3, #1
    30e6:	2b00      	cmp	r3, #0
    30e8:	bf14      	ite	ne
    30ea:	2301      	movne	r3, #1
    30ec:	2300      	moveq	r3, #0
    30ee:	b2db      	uxtb	r3, r3
}
    30f0:	4618      	mov	r0, r3
    30f2:	370c      	adds	r7, #12
    30f4:	46bd      	mov	sp, r7
    30f6:	f85d 7b04 	ldr.w	r7, [sp], #4
    30fa:	4770      	bx	lr

000030fc <hri_sercomi2cm_set_CTRLA_ENABLE_bit>:
	tmp = (tmp & SERCOM_I2CM_CTRLA_SWRST) >> SERCOM_I2CM_CTRLA_SWRST_Pos;
	return (bool)tmp;
}

static inline void hri_sercomi2cm_set_CTRLA_ENABLE_bit(const void *const hw)
{
    30fc:	b580      	push	{r7, lr}
    30fe:	b082      	sub	sp, #8
    3100:	af00      	add	r7, sp, #0
    3102:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLA.reg |= SERCOM_I2CM_CTRLA_ENABLE;
    3104:	687b      	ldr	r3, [r7, #4]
    3106:	681b      	ldr	r3, [r3, #0]
    3108:	f043 0202 	orr.w	r2, r3, #2
    310c:	687b      	ldr	r3, [r7, #4]
    310e:	601a      	str	r2, [r3, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
    3110:	2103      	movs	r1, #3
    3112:	6878      	ldr	r0, [r7, #4]
    3114:	4b02      	ldr	r3, [pc, #8]	; (3120 <hri_sercomi2cm_set_CTRLA_ENABLE_bit+0x24>)
    3116:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3118:	bf00      	nop
    311a:	3708      	adds	r7, #8
    311c:	46bd      	mov	sp, r7
    311e:	bd80      	pop	{r7, pc}
    3120:	00002ee9 	.word	0x00002ee9

00003124 <hri_sercomi2cm_clear_CTRLA_ENABLE_bit>:
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomi2cm_clear_CTRLA_ENABLE_bit(const void *const hw)
{
    3124:	b580      	push	{r7, lr}
    3126:	b082      	sub	sp, #8
    3128:	af00      	add	r7, sp, #0
    312a:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
    312c:	687b      	ldr	r3, [r7, #4]
    312e:	681b      	ldr	r3, [r3, #0]
    3130:	f023 0202 	bic.w	r2, r3, #2
    3134:	687b      	ldr	r3, [r7, #4]
    3136:	601a      	str	r2, [r3, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
    3138:	2103      	movs	r1, #3
    313a:	6878      	ldr	r0, [r7, #4]
    313c:	4b02      	ldr	r3, [pc, #8]	; (3148 <hri_sercomi2cm_clear_CTRLA_ENABLE_bit+0x24>)
    313e:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3140:	bf00      	nop
    3142:	3708      	adds	r7, #8
    3144:	46bd      	mov	sp, r7
    3146:	bd80      	pop	{r7, pc}
    3148:	00002ee9 	.word	0x00002ee9

0000314c <hri_sercomi2cm_get_CTRLA_SCLSM_bit>:
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_MASK);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_sercomi2cm_get_CTRLA_SCLSM_bit(const void *const hw)
{
    314c:	b480      	push	{r7}
    314e:	b085      	sub	sp, #20
    3150:	af00      	add	r7, sp, #0
    3152:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    3154:	687b      	ldr	r3, [r7, #4]
    3156:	681b      	ldr	r3, [r3, #0]
    3158:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & SERCOM_I2CM_CTRLA_SCLSM) >> SERCOM_I2CM_CTRLA_SCLSM_Pos;
    315a:	68fb      	ldr	r3, [r7, #12]
    315c:	0edb      	lsrs	r3, r3, #27
    315e:	f003 0301 	and.w	r3, r3, #1
    3162:	60fb      	str	r3, [r7, #12]
	return (bool)tmp;
    3164:	68fb      	ldr	r3, [r7, #12]
    3166:	2b00      	cmp	r3, #0
    3168:	bf14      	ite	ne
    316a:	2301      	movne	r3, #1
    316c:	2300      	moveq	r3, #0
    316e:	b2db      	uxtb	r3, r3
}
    3170:	4618      	mov	r0, r3
    3172:	3714      	adds	r7, #20
    3174:	46bd      	mov	sp, r7
    3176:	f85d 7b04 	ldr.w	r7, [sp], #4
    317a:	4770      	bx	lr

0000317c <hri_sercomi2cm_get_CTRLA_reg>:
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomi2cm_ctrla_reg_t hri_sercomi2cm_get_CTRLA_reg(const void *const          hw,
                                                                      hri_sercomi2cm_ctrla_reg_t mask)
{
    317c:	b580      	push	{r7, lr}
    317e:	b084      	sub	sp, #16
    3180:	af00      	add	r7, sp, #0
    3182:	6078      	str	r0, [r7, #4]
    3184:	6039      	str	r1, [r7, #0]
	uint32_t tmp;
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
    3186:	2103      	movs	r1, #3
    3188:	6878      	ldr	r0, [r7, #4]
    318a:	4b07      	ldr	r3, [pc, #28]	; (31a8 <hri_sercomi2cm_get_CTRLA_reg+0x2c>)
    318c:	4798      	blx	r3
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
    318e:	687b      	ldr	r3, [r7, #4]
    3190:	681b      	ldr	r3, [r3, #0]
    3192:	60fb      	str	r3, [r7, #12]
	tmp &= mask;
    3194:	68fa      	ldr	r2, [r7, #12]
    3196:	683b      	ldr	r3, [r7, #0]
    3198:	4013      	ands	r3, r2
    319a:	60fb      	str	r3, [r7, #12]
	return tmp;
    319c:	68fb      	ldr	r3, [r7, #12]
}
    319e:	4618      	mov	r0, r3
    31a0:	3710      	adds	r7, #16
    31a2:	46bd      	mov	sp, r7
    31a4:	bd80      	pop	{r7, pc}
    31a6:	bf00      	nop
    31a8:	00002ee9 	.word	0x00002ee9

000031ac <hri_sercomi2cm_write_CTRLA_reg>:

static inline void hri_sercomi2cm_write_CTRLA_reg(const void *const hw, hri_sercomi2cm_ctrla_reg_t data)
{
    31ac:	b580      	push	{r7, lr}
    31ae:	b082      	sub	sp, #8
    31b0:	af00      	add	r7, sp, #0
    31b2:	6078      	str	r0, [r7, #4]
    31b4:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
    31b6:	687b      	ldr	r3, [r7, #4]
    31b8:	683a      	ldr	r2, [r7, #0]
    31ba:	601a      	str	r2, [r3, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
    31bc:	2103      	movs	r1, #3
    31be:	6878      	ldr	r0, [r7, #4]
    31c0:	4b02      	ldr	r3, [pc, #8]	; (31cc <hri_sercomi2cm_write_CTRLA_reg+0x20>)
    31c2:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    31c4:	bf00      	nop
    31c6:	3708      	adds	r7, #8
    31c8:	46bd      	mov	sp, r7
    31ca:	bd80      	pop	{r7, pc}
    31cc:	00002ee9 	.word	0x00002ee9

000031d0 <hri_sercomspi_get_CTRLA_ENABLE_bit>:
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_sercomspi_get_CTRLA_ENABLE_bit(const void *const hw)
{
    31d0:	b580      	push	{r7, lr}
    31d2:	b084      	sub	sp, #16
    31d4:	af00      	add	r7, sp, #0
    31d6:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
    31d8:	2103      	movs	r1, #3
    31da:	6878      	ldr	r0, [r7, #4]
    31dc:	4b09      	ldr	r3, [pc, #36]	; (3204 <hri_sercomspi_get_CTRLA_ENABLE_bit+0x34>)
    31de:	4798      	blx	r3
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    31e0:	687b      	ldr	r3, [r7, #4]
    31e2:	681b      	ldr	r3, [r3, #0]
    31e4:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & SERCOM_SPI_CTRLA_ENABLE) >> SERCOM_SPI_CTRLA_ENABLE_Pos;
    31e6:	68fb      	ldr	r3, [r7, #12]
    31e8:	085b      	lsrs	r3, r3, #1
    31ea:	f003 0301 	and.w	r3, r3, #1
    31ee:	60fb      	str	r3, [r7, #12]
	return (bool)tmp;
    31f0:	68fb      	ldr	r3, [r7, #12]
    31f2:	2b00      	cmp	r3, #0
    31f4:	bf14      	ite	ne
    31f6:	2301      	movne	r3, #1
    31f8:	2300      	moveq	r3, #0
    31fa:	b2db      	uxtb	r3, r3
}
    31fc:	4618      	mov	r0, r3
    31fe:	3710      	adds	r7, #16
    3200:	46bd      	mov	sp, r7
    3202:	bd80      	pop	{r7, pc}
    3204:	00002f37 	.word	0x00002f37

00003208 <hri_sercomspi_clear_CTRLA_ENABLE_bit>:
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomspi_clear_CTRLA_ENABLE_bit(const void *const hw)
{
    3208:	b580      	push	{r7, lr}
    320a:	b082      	sub	sp, #8
    320c:	af00      	add	r7, sp, #0
    320e:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
    3210:	687b      	ldr	r3, [r7, #4]
    3212:	681b      	ldr	r3, [r3, #0]
    3214:	f023 0202 	bic.w	r2, r3, #2
    3218:	687b      	ldr	r3, [r7, #4]
    321a:	601a      	str	r2, [r3, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
    321c:	2103      	movs	r1, #3
    321e:	6878      	ldr	r0, [r7, #4]
    3220:	4b02      	ldr	r3, [pc, #8]	; (322c <hri_sercomspi_clear_CTRLA_ENABLE_bit+0x24>)
    3222:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3224:	bf00      	nop
    3226:	3708      	adds	r7, #8
    3228:	46bd      	mov	sp, r7
    322a:	bd80      	pop	{r7, pc}
    322c:	00002f37 	.word	0x00002f37

00003230 <hri_sercomspi_get_CTRLA_reg>:
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomspi_ctrla_reg_t hri_sercomspi_get_CTRLA_reg(const void *const         hw,
                                                                    hri_sercomspi_ctrla_reg_t mask)
{
    3230:	b580      	push	{r7, lr}
    3232:	b084      	sub	sp, #16
    3234:	af00      	add	r7, sp, #0
    3236:	6078      	str	r0, [r7, #4]
    3238:	6039      	str	r1, [r7, #0]
	uint32_t tmp;
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
    323a:	2103      	movs	r1, #3
    323c:	6878      	ldr	r0, [r7, #4]
    323e:	4b07      	ldr	r3, [pc, #28]	; (325c <hri_sercomspi_get_CTRLA_reg+0x2c>)
    3240:	4798      	blx	r3
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    3242:	687b      	ldr	r3, [r7, #4]
    3244:	681b      	ldr	r3, [r3, #0]
    3246:	60fb      	str	r3, [r7, #12]
	tmp &= mask;
    3248:	68fa      	ldr	r2, [r7, #12]
    324a:	683b      	ldr	r3, [r7, #0]
    324c:	4013      	ands	r3, r2
    324e:	60fb      	str	r3, [r7, #12]
	return tmp;
    3250:	68fb      	ldr	r3, [r7, #12]
}
    3252:	4618      	mov	r0, r3
    3254:	3710      	adds	r7, #16
    3256:	46bd      	mov	sp, r7
    3258:	bd80      	pop	{r7, pc}
    325a:	bf00      	nop
    325c:	00002f37 	.word	0x00002f37

00003260 <hri_sercomspi_write_CTRLA_reg>:

static inline void hri_sercomspi_write_CTRLA_reg(const void *const hw, hri_sercomspi_ctrla_reg_t data)
{
    3260:	b580      	push	{r7, lr}
    3262:	b082      	sub	sp, #8
    3264:	af00      	add	r7, sp, #0
    3266:	6078      	str	r0, [r7, #4]
    3268:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    326a:	687b      	ldr	r3, [r7, #4]
    326c:	683a      	ldr	r2, [r7, #0]
    326e:	601a      	str	r2, [r3, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
    3270:	2103      	movs	r1, #3
    3272:	6878      	ldr	r0, [r7, #4]
    3274:	4b02      	ldr	r3, [pc, #8]	; (3280 <hri_sercomspi_write_CTRLA_reg+0x20>)
    3276:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3278:	bf00      	nop
    327a:	3708      	adds	r7, #8
    327c:	46bd      	mov	sp, r7
    327e:	bd80      	pop	{r7, pc}
    3280:	00002f37 	.word	0x00002f37

00003284 <hri_sercomusart_clear_CTRLA_ENABLE_bit>:
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomusart_clear_CTRLA_ENABLE_bit(const void *const hw)
{
    3284:	b580      	push	{r7, lr}
    3286:	b082      	sub	sp, #8
    3288:	af00      	add	r7, sp, #0
    328a:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
    328c:	687b      	ldr	r3, [r7, #4]
    328e:	681b      	ldr	r3, [r3, #0]
    3290:	f023 0202 	bic.w	r2, r3, #2
    3294:	687b      	ldr	r3, [r7, #4]
    3296:	601a      	str	r2, [r3, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    3298:	2103      	movs	r1, #3
    329a:	6878      	ldr	r0, [r7, #4]
    329c:	4b02      	ldr	r3, [pc, #8]	; (32a8 <hri_sercomusart_clear_CTRLA_ENABLE_bit+0x24>)
    329e:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    32a0:	bf00      	nop
    32a2:	3708      	adds	r7, #8
    32a4:	46bd      	mov	sp, r7
    32a6:	bd80      	pop	{r7, pc}
    32a8:	00002f85 	.word	0x00002f85

000032ac <hri_sercomusart_get_CTRLA_reg>:
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_ctrla_reg_t hri_sercomusart_get_CTRLA_reg(const void *const           hw,
                                                                        hri_sercomusart_ctrla_reg_t mask)
{
    32ac:	b580      	push	{r7, lr}
    32ae:	b084      	sub	sp, #16
    32b0:	af00      	add	r7, sp, #0
    32b2:	6078      	str	r0, [r7, #4]
    32b4:	6039      	str	r1, [r7, #0]
	uint32_t tmp;
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    32b6:	2103      	movs	r1, #3
    32b8:	6878      	ldr	r0, [r7, #4]
    32ba:	4b07      	ldr	r3, [pc, #28]	; (32d8 <hri_sercomusart_get_CTRLA_reg+0x2c>)
    32bc:	4798      	blx	r3
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
    32be:	687b      	ldr	r3, [r7, #4]
    32c0:	681b      	ldr	r3, [r3, #0]
    32c2:	60fb      	str	r3, [r7, #12]
	tmp &= mask;
    32c4:	68fa      	ldr	r2, [r7, #12]
    32c6:	683b      	ldr	r3, [r7, #0]
    32c8:	4013      	ands	r3, r2
    32ca:	60fb      	str	r3, [r7, #12]
	return tmp;
    32cc:	68fb      	ldr	r3, [r7, #12]
}
    32ce:	4618      	mov	r0, r3
    32d0:	3710      	adds	r7, #16
    32d2:	46bd      	mov	sp, r7
    32d4:	bd80      	pop	{r7, pc}
    32d6:	bf00      	nop
    32d8:	00002f85 	.word	0x00002f85

000032dc <hri_sercomusart_write_CTRLA_reg>:

static inline void hri_sercomusart_write_CTRLA_reg(const void *const hw, hri_sercomusart_ctrla_reg_t data)
{
    32dc:	b580      	push	{r7, lr}
    32de:	b082      	sub	sp, #8
    32e0:	af00      	add	r7, sp, #0
    32e2:	6078      	str	r0, [r7, #4]
    32e4:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg = data;
    32e6:	687b      	ldr	r3, [r7, #4]
    32e8:	683a      	ldr	r2, [r7, #0]
    32ea:	601a      	str	r2, [r3, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    32ec:	2103      	movs	r1, #3
    32ee:	6878      	ldr	r0, [r7, #4]
    32f0:	4b02      	ldr	r3, [pc, #8]	; (32fc <hri_sercomusart_write_CTRLA_reg+0x20>)
    32f2:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    32f4:	bf00      	nop
    32f6:	3708      	adds	r7, #8
    32f8:	46bd      	mov	sp, r7
    32fa:	bd80      	pop	{r7, pc}
    32fc:	00002f85 	.word	0x00002f85

00003300 <hri_sercomi2cm_set_CTRLB_SMEN_bit>:
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
	return ((Sercom *)hw)->USART.CTRLA.reg;
}

static inline void hri_sercomi2cm_set_CTRLB_SMEN_bit(const void *const hw)
{
    3300:	b580      	push	{r7, lr}
    3302:	b082      	sub	sp, #8
    3304:	af00      	add	r7, sp, #0
    3306:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_SMEN;
    3308:	687b      	ldr	r3, [r7, #4]
    330a:	685b      	ldr	r3, [r3, #4]
    330c:	f443 7280 	orr.w	r2, r3, #256	; 0x100
    3310:	687b      	ldr	r3, [r7, #4]
    3312:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    3314:	2104      	movs	r1, #4
    3316:	6878      	ldr	r0, [r7, #4]
    3318:	4b02      	ldr	r3, [pc, #8]	; (3324 <hri_sercomi2cm_set_CTRLB_SMEN_bit+0x24>)
    331a:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    331c:	bf00      	nop
    331e:	3708      	adds	r7, #8
    3320:	46bd      	mov	sp, r7
    3322:	bd80      	pop	{r7, pc}
    3324:	00002ee9 	.word	0x00002ee9

00003328 <hri_sercomi2cm_clear_CTRLB_SMEN_bit>:
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomi2cm_clear_CTRLB_SMEN_bit(const void *const hw)
{
    3328:	b580      	push	{r7, lr}
    332a:	b082      	sub	sp, #8
    332c:	af00      	add	r7, sp, #0
    332e:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
    3330:	687b      	ldr	r3, [r7, #4]
    3332:	685b      	ldr	r3, [r3, #4]
    3334:	f423 7280 	bic.w	r2, r3, #256	; 0x100
    3338:	687b      	ldr	r3, [r7, #4]
    333a:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    333c:	2104      	movs	r1, #4
    333e:	6878      	ldr	r0, [r7, #4]
    3340:	4b02      	ldr	r3, [pc, #8]	; (334c <hri_sercomi2cm_clear_CTRLB_SMEN_bit+0x24>)
    3342:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3344:	bf00      	nop
    3346:	3708      	adds	r7, #8
    3348:	46bd      	mov	sp, r7
    334a:	bd80      	pop	{r7, pc}
    334c:	00002ee9 	.word	0x00002ee9

00003350 <hri_sercomi2cm_set_CTRLB_ACKACT_bit>:
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomi2cm_set_CTRLB_ACKACT_bit(const void *const hw)
{
    3350:	b580      	push	{r7, lr}
    3352:	b082      	sub	sp, #8
    3354:	af00      	add	r7, sp, #0
    3356:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
    3358:	687b      	ldr	r3, [r7, #4]
    335a:	685b      	ldr	r3, [r3, #4]
    335c:	f443 2280 	orr.w	r2, r3, #262144	; 0x40000
    3360:	687b      	ldr	r3, [r7, #4]
    3362:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    3364:	2104      	movs	r1, #4
    3366:	6878      	ldr	r0, [r7, #4]
    3368:	4b02      	ldr	r3, [pc, #8]	; (3374 <hri_sercomi2cm_set_CTRLB_ACKACT_bit+0x24>)
    336a:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    336c:	bf00      	nop
    336e:	3708      	adds	r7, #8
    3370:	46bd      	mov	sp, r7
    3372:	bd80      	pop	{r7, pc}
    3374:	00002ee9 	.word	0x00002ee9

00003378 <hri_sercomi2cm_clear_CTRLB_ACKACT_bit>:
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomi2cm_clear_CTRLB_ACKACT_bit(const void *const hw)
{
    3378:	b580      	push	{r7, lr}
    337a:	b082      	sub	sp, #8
    337c:	af00      	add	r7, sp, #0
    337e:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
    3380:	687b      	ldr	r3, [r7, #4]
    3382:	685b      	ldr	r3, [r3, #4]
    3384:	f423 2280 	bic.w	r2, r3, #262144	; 0x40000
    3388:	687b      	ldr	r3, [r7, #4]
    338a:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    338c:	2104      	movs	r1, #4
    338e:	6878      	ldr	r0, [r7, #4]
    3390:	4b02      	ldr	r3, [pc, #8]	; (339c <hri_sercomi2cm_clear_CTRLB_ACKACT_bit+0x24>)
    3392:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3394:	bf00      	nop
    3396:	3708      	adds	r7, #8
    3398:	46bd      	mov	sp, r7
    339a:	bd80      	pop	{r7, pc}
    339c:	00002ee9 	.word	0x00002ee9

000033a0 <hri_sercomi2cm_set_CTRLB_CMD_bf>:
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomi2cm_set_CTRLB_CMD_bf(const void *const hw, hri_sercomi2cm_ctrlb_reg_t mask)
{
    33a0:	b580      	push	{r7, lr}
    33a2:	b082      	sub	sp, #8
    33a4:	af00      	add	r7, sp, #0
    33a6:	6078      	str	r0, [r7, #4]
    33a8:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
    33aa:	687b      	ldr	r3, [r7, #4]
    33ac:	685a      	ldr	r2, [r3, #4]
    33ae:	683b      	ldr	r3, [r7, #0]
    33b0:	041b      	lsls	r3, r3, #16
    33b2:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
    33b6:	431a      	orrs	r2, r3
    33b8:	687b      	ldr	r3, [r7, #4]
    33ba:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    33bc:	2104      	movs	r1, #4
    33be:	6878      	ldr	r0, [r7, #4]
    33c0:	4b02      	ldr	r3, [pc, #8]	; (33cc <hri_sercomi2cm_set_CTRLB_CMD_bf+0x2c>)
    33c2:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    33c4:	bf00      	nop
    33c6:	3708      	adds	r7, #8
    33c8:	46bd      	mov	sp, r7
    33ca:	bd80      	pop	{r7, pc}
    33cc:	00002ee9 	.word	0x00002ee9

000033d0 <hri_sercomi2cm_write_CTRLB_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomi2cm_write_CTRLB_reg(const void *const hw, hri_sercomi2cm_ctrlb_reg_t data)
{
    33d0:	b580      	push	{r7, lr}
    33d2:	b082      	sub	sp, #8
    33d4:	af00      	add	r7, sp, #0
    33d6:	6078      	str	r0, [r7, #4]
    33d8:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg = data;
    33da:	687b      	ldr	r3, [r7, #4]
    33dc:	683a      	ldr	r2, [r7, #0]
    33de:	605a      	str	r2, [r3, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    33e0:	2104      	movs	r1, #4
    33e2:	6878      	ldr	r0, [r7, #4]
    33e4:	4b02      	ldr	r3, [pc, #8]	; (33f0 <hri_sercomi2cm_write_CTRLB_reg+0x20>)
    33e6:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    33e8:	bf00      	nop
    33ea:	3708      	adds	r7, #8
    33ec:	46bd      	mov	sp, r7
    33ee:	bd80      	pop	{r7, pc}
    33f0:	00002ee9 	.word	0x00002ee9

000033f4 <hri_sercomspi_write_CTRLB_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomspi_write_CTRLB_reg(const void *const hw, hri_sercomspi_ctrlb_reg_t data)
{
    33f4:	b580      	push	{r7, lr}
    33f6:	b082      	sub	sp, #8
    33f8:	af00      	add	r7, sp, #0
    33fa:	6078      	str	r0, [r7, #4]
    33fc:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLB.reg = data;
    33fe:	687b      	ldr	r3, [r7, #4]
    3400:	683a      	ldr	r2, [r7, #0]
    3402:	605a      	str	r2, [r3, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
    3404:	2117      	movs	r1, #23
    3406:	6878      	ldr	r0, [r7, #4]
    3408:	4b02      	ldr	r3, [pc, #8]	; (3414 <hri_sercomspi_write_CTRLB_reg+0x20>)
    340a:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    340c:	bf00      	nop
    340e:	3708      	adds	r7, #8
    3410:	46bd      	mov	sp, r7
    3412:	bd80      	pop	{r7, pc}
    3414:	00002f37 	.word	0x00002f37

00003418 <hri_sercomusart_write_CTRLB_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_CTRLB_reg(const void *const hw, hri_sercomusart_ctrlb_reg_t data)
{
    3418:	b580      	push	{r7, lr}
    341a:	b082      	sub	sp, #8
    341c:	af00      	add	r7, sp, #0
    341e:	6078      	str	r0, [r7, #4]
    3420:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLB.reg = data;
    3422:	687b      	ldr	r3, [r7, #4]
    3424:	683a      	ldr	r2, [r7, #0]
    3426:	605a      	str	r2, [r3, #4]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
    3428:	211f      	movs	r1, #31
    342a:	6878      	ldr	r0, [r7, #4]
    342c:	4b02      	ldr	r3, [pc, #8]	; (3438 <hri_sercomusart_write_CTRLB_reg+0x20>)
    342e:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3430:	bf00      	nop
    3432:	3708      	adds	r7, #8
    3434:	46bd      	mov	sp, r7
    3436:	bd80      	pop	{r7, pc}
    3438:	00002f85 	.word	0x00002f85

0000343c <hri_sercomusart_write_CTRLC_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_CTRLC_reg(const void *const hw, hri_sercomusart_ctrlc_reg_t data)
{
    343c:	b480      	push	{r7}
    343e:	b083      	sub	sp, #12
    3440:	af00      	add	r7, sp, #0
    3442:	6078      	str	r0, [r7, #4]
    3444:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLC.reg = data;
    3446:	687b      	ldr	r3, [r7, #4]
    3448:	683a      	ldr	r2, [r7, #0]
    344a:	609a      	str	r2, [r3, #8]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    344c:	bf00      	nop
    344e:	370c      	adds	r7, #12
    3450:	46bd      	mov	sp, r7
    3452:	f85d 7b04 	ldr.w	r7, [sp], #4
    3456:	4770      	bx	lr

00003458 <hri_sercomi2cm_write_BAUD_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomi2cm_write_BAUD_reg(const void *const hw, hri_sercomi2cm_baud_reg_t data)
{
    3458:	b480      	push	{r7}
    345a:	b083      	sub	sp, #12
    345c:	af00      	add	r7, sp, #0
    345e:	6078      	str	r0, [r7, #4]
    3460:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.BAUD.reg = data;
    3462:	687b      	ldr	r3, [r7, #4]
    3464:	683a      	ldr	r2, [r7, #0]
    3466:	60da      	str	r2, [r3, #12]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3468:	bf00      	nop
    346a:	370c      	adds	r7, #12
    346c:	46bd      	mov	sp, r7
    346e:	f85d 7b04 	ldr.w	r7, [sp], #4
    3472:	4770      	bx	lr

00003474 <hri_sercomspi_write_BAUD_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomspi_write_BAUD_reg(const void *const hw, hri_sercomspi_baud_reg_t data)
{
    3474:	b480      	push	{r7}
    3476:	b083      	sub	sp, #12
    3478:	af00      	add	r7, sp, #0
    347a:	6078      	str	r0, [r7, #4]
    347c:	460b      	mov	r3, r1
    347e:	70fb      	strb	r3, [r7, #3]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.BAUD.reg = data;
    3480:	687b      	ldr	r3, [r7, #4]
    3482:	78fa      	ldrb	r2, [r7, #3]
    3484:	731a      	strb	r2, [r3, #12]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3486:	bf00      	nop
    3488:	370c      	adds	r7, #12
    348a:	46bd      	mov	sp, r7
    348c:	f85d 7b04 	ldr.w	r7, [sp], #4
    3490:	4770      	bx	lr

00003492 <hri_sercomusart_write_BAUD_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_BAUD_reg(const void *const hw, hri_sercomusart_baud_reg_t data)
{
    3492:	b480      	push	{r7}
    3494:	b083      	sub	sp, #12
    3496:	af00      	add	r7, sp, #0
    3498:	6078      	str	r0, [r7, #4]
    349a:	460b      	mov	r3, r1
    349c:	807b      	strh	r3, [r7, #2]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.BAUD.reg = data;
    349e:	687b      	ldr	r3, [r7, #4]
    34a0:	887a      	ldrh	r2, [r7, #2]
    34a2:	819a      	strh	r2, [r3, #12]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    34a4:	bf00      	nop
    34a6:	370c      	adds	r7, #12
    34a8:	46bd      	mov	sp, r7
    34aa:	f85d 7b04 	ldr.w	r7, [sp], #4
    34ae:	4770      	bx	lr

000034b0 <hri_sercomusart_write_RXPL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_RXPL_reg(const void *const hw, hri_sercomusart_rxpl_reg_t data)
{
    34b0:	b480      	push	{r7}
    34b2:	b083      	sub	sp, #12
    34b4:	af00      	add	r7, sp, #0
    34b6:	6078      	str	r0, [r7, #4]
    34b8:	460b      	mov	r3, r1
    34ba:	70fb      	strb	r3, [r7, #3]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.RXPL.reg = data;
    34bc:	687b      	ldr	r3, [r7, #4]
    34be:	78fa      	ldrb	r2, [r7, #3]
    34c0:	739a      	strb	r2, [r3, #14]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    34c2:	bf00      	nop
    34c4:	370c      	adds	r7, #12
    34c6:	46bd      	mov	sp, r7
    34c8:	f85d 7b04 	ldr.w	r7, [sp], #4
    34cc:	4770      	bx	lr
	...

000034d0 <hri_sercomi2cm_write_ADDR_HS_bit>:
	tmp = (tmp & SERCOM_I2CM_ADDR_HS) >> SERCOM_I2CM_ADDR_HS_Pos;
	return (bool)tmp;
}

static inline void hri_sercomi2cm_write_ADDR_HS_bit(const void *const hw, bool value)
{
    34d0:	b580      	push	{r7, lr}
    34d2:	b084      	sub	sp, #16
    34d4:	af00      	add	r7, sp, #0
    34d6:	6078      	str	r0, [r7, #4]
    34d8:	460b      	mov	r3, r1
    34da:	70fb      	strb	r3, [r7, #3]
	uint32_t tmp;
	SERCOM_CRITICAL_SECTION_ENTER();
	tmp = ((Sercom *)hw)->I2CM.ADDR.reg;
    34dc:	687b      	ldr	r3, [r7, #4]
    34de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    34e0:	60fb      	str	r3, [r7, #12]
	tmp &= ~SERCOM_I2CM_ADDR_HS;
    34e2:	68fb      	ldr	r3, [r7, #12]
    34e4:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    34e8:	60fb      	str	r3, [r7, #12]
	tmp |= value << SERCOM_I2CM_ADDR_HS_Pos;
    34ea:	78fb      	ldrb	r3, [r7, #3]
    34ec:	039b      	lsls	r3, r3, #14
    34ee:	461a      	mov	r2, r3
    34f0:	68fb      	ldr	r3, [r7, #12]
    34f2:	4313      	orrs	r3, r2
    34f4:	60fb      	str	r3, [r7, #12]
	((Sercom *)hw)->I2CM.ADDR.reg = tmp;
    34f6:	687b      	ldr	r3, [r7, #4]
    34f8:	68fa      	ldr	r2, [r7, #12]
    34fa:	625a      	str	r2, [r3, #36]	; 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    34fc:	2104      	movs	r1, #4
    34fe:	6878      	ldr	r0, [r7, #4]
    3500:	4b02      	ldr	r3, [pc, #8]	; (350c <hri_sercomi2cm_write_ADDR_HS_bit+0x3c>)
    3502:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3504:	bf00      	nop
    3506:	3710      	adds	r7, #16
    3508:	46bd      	mov	sp, r7
    350a:	bd80      	pop	{r7, pc}
    350c:	00002ee9 	.word	0x00002ee9

00003510 <hri_sercomi2cm_write_ADDR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomi2cm_write_ADDR_reg(const void *const hw, hri_sercomi2cm_addr_reg_t data)
{
    3510:	b580      	push	{r7, lr}
    3512:	b082      	sub	sp, #8
    3514:	af00      	add	r7, sp, #0
    3516:	6078      	str	r0, [r7, #4]
    3518:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.ADDR.reg = data;
    351a:	687b      	ldr	r3, [r7, #4]
    351c:	683a      	ldr	r2, [r7, #0]
    351e:	625a      	str	r2, [r3, #36]	; 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    3520:	2104      	movs	r1, #4
    3522:	6878      	ldr	r0, [r7, #4]
    3524:	4b02      	ldr	r3, [pc, #8]	; (3530 <hri_sercomi2cm_write_ADDR_reg+0x20>)
    3526:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3528:	bf00      	nop
    352a:	3708      	adds	r7, #8
    352c:	46bd      	mov	sp, r7
    352e:	bd80      	pop	{r7, pc}
    3530:	00002ee9 	.word	0x00002ee9

00003534 <hri_sercomi2cm_read_ADDR_reg>:
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomi2cm_addr_reg_t hri_sercomi2cm_read_ADDR_reg(const void *const hw)
{
    3534:	b580      	push	{r7, lr}
    3536:	b082      	sub	sp, #8
    3538:	af00      	add	r7, sp, #0
    353a:	6078      	str	r0, [r7, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    353c:	2104      	movs	r1, #4
    353e:	6878      	ldr	r0, [r7, #4]
    3540:	4b03      	ldr	r3, [pc, #12]	; (3550 <hri_sercomi2cm_read_ADDR_reg+0x1c>)
    3542:	4798      	blx	r3
	return ((Sercom *)hw)->I2CM.ADDR.reg;
    3544:	687b      	ldr	r3, [r7, #4]
    3546:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
    3548:	4618      	mov	r0, r3
    354a:	3708      	adds	r7, #8
    354c:	46bd      	mov	sp, r7
    354e:	bd80      	pop	{r7, pc}
    3550:	00002ee9 	.word	0x00002ee9

00003554 <hri_sercomspi_write_ADDR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomspi_write_ADDR_reg(const void *const hw, hri_sercomspi_addr_reg_t data)
{
    3554:	b480      	push	{r7}
    3556:	b083      	sub	sp, #12
    3558:	af00      	add	r7, sp, #0
    355a:	6078      	str	r0, [r7, #4]
    355c:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.ADDR.reg = data;
    355e:	687b      	ldr	r3, [r7, #4]
    3560:	683a      	ldr	r2, [r7, #0]
    3562:	625a      	str	r2, [r3, #36]	; 0x24
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3564:	bf00      	nop
    3566:	370c      	adds	r7, #12
    3568:	46bd      	mov	sp, r7
    356a:	f85d 7b04 	ldr.w	r7, [sp], #4
    356e:	4770      	bx	lr

00003570 <hri_sercomi2cm_write_DATA_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomi2cm_write_DATA_reg(const void *const hw, hri_sercomi2cm_data_reg_t data)
{
    3570:	b580      	push	{r7, lr}
    3572:	b082      	sub	sp, #8
    3574:	af00      	add	r7, sp, #0
    3576:	6078      	str	r0, [r7, #4]
    3578:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.DATA.reg = data;
    357a:	687b      	ldr	r3, [r7, #4]
    357c:	683a      	ldr	r2, [r7, #0]
    357e:	629a      	str	r2, [r3, #40]	; 0x28
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    3580:	2104      	movs	r1, #4
    3582:	6878      	ldr	r0, [r7, #4]
    3584:	4b02      	ldr	r3, [pc, #8]	; (3590 <hri_sercomi2cm_write_DATA_reg+0x20>)
    3586:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3588:	bf00      	nop
    358a:	3708      	adds	r7, #8
    358c:	46bd      	mov	sp, r7
    358e:	bd80      	pop	{r7, pc}
    3590:	00002ee9 	.word	0x00002ee9

00003594 <hri_sercomi2cm_read_DATA_reg>:
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomi2cm_data_reg_t hri_sercomi2cm_read_DATA_reg(const void *const hw)
{
    3594:	b580      	push	{r7, lr}
    3596:	b082      	sub	sp, #8
    3598:	af00      	add	r7, sp, #0
    359a:	6078      	str	r0, [r7, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    359c:	2104      	movs	r1, #4
    359e:	6878      	ldr	r0, [r7, #4]
    35a0:	4b03      	ldr	r3, [pc, #12]	; (35b0 <hri_sercomi2cm_read_DATA_reg+0x1c>)
    35a2:	4798      	blx	r3
	return ((Sercom *)hw)->I2CM.DATA.reg;
    35a4:	687b      	ldr	r3, [r7, #4]
    35a6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
}
    35a8:	4618      	mov	r0, r3
    35aa:	3708      	adds	r7, #8
    35ac:	46bd      	mov	sp, r7
    35ae:	bd80      	pop	{r7, pc}
    35b0:	00002ee9 	.word	0x00002ee9

000035b4 <hri_sercomspi_write_DATA_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomspi_write_DATA_reg(const void *const hw, hri_sercomspi_data_reg_t data)
{
    35b4:	b480      	push	{r7}
    35b6:	b083      	sub	sp, #12
    35b8:	af00      	add	r7, sp, #0
    35ba:	6078      	str	r0, [r7, #4]
    35bc:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.DATA.reg = data;
    35be:	687b      	ldr	r3, [r7, #4]
    35c0:	683a      	ldr	r2, [r7, #0]
    35c2:	629a      	str	r2, [r3, #40]	; 0x28
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    35c4:	bf00      	nop
    35c6:	370c      	adds	r7, #12
    35c8:	46bd      	mov	sp, r7
    35ca:	f85d 7b04 	ldr.w	r7, [sp], #4
    35ce:	4770      	bx	lr

000035d0 <hri_sercomspi_read_DATA_reg>:
	((Sercom *)hw)->SPI.DATA.reg ^= mask;
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomspi_data_reg_t hri_sercomspi_read_DATA_reg(const void *const hw)
{
    35d0:	b480      	push	{r7}
    35d2:	b083      	sub	sp, #12
    35d4:	af00      	add	r7, sp, #0
    35d6:	6078      	str	r0, [r7, #4]
	return ((Sercom *)hw)->SPI.DATA.reg;
    35d8:	687b      	ldr	r3, [r7, #4]
    35da:	6a9b      	ldr	r3, [r3, #40]	; 0x28
}
    35dc:	4618      	mov	r0, r3
    35de:	370c      	adds	r7, #12
    35e0:	46bd      	mov	sp, r7
    35e2:	f85d 7b04 	ldr.w	r7, [sp], #4
    35e6:	4770      	bx	lr

000035e8 <hri_sercomusart_write_DATA_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_DATA_reg(const void *const hw, hri_sercomusart_data_reg_t data)
{
    35e8:	b480      	push	{r7}
    35ea:	b083      	sub	sp, #12
    35ec:	af00      	add	r7, sp, #0
    35ee:	6078      	str	r0, [r7, #4]
    35f0:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DATA.reg = data;
    35f2:	687b      	ldr	r3, [r7, #4]
    35f4:	683a      	ldr	r2, [r7, #0]
    35f6:	629a      	str	r2, [r3, #40]	; 0x28
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    35f8:	bf00      	nop
    35fa:	370c      	adds	r7, #12
    35fc:	46bd      	mov	sp, r7
    35fe:	f85d 7b04 	ldr.w	r7, [sp], #4
    3602:	4770      	bx	lr

00003604 <hri_sercomusart_read_DATA_reg>:
	((Sercom *)hw)->USART.DATA.reg ^= mask;
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_data_reg_t hri_sercomusart_read_DATA_reg(const void *const hw)
{
    3604:	b480      	push	{r7}
    3606:	b083      	sub	sp, #12
    3608:	af00      	add	r7, sp, #0
    360a:	6078      	str	r0, [r7, #4]
	return ((Sercom *)hw)->USART.DATA.reg;
    360c:	687b      	ldr	r3, [r7, #4]
    360e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
}
    3610:	4618      	mov	r0, r3
    3612:	370c      	adds	r7, #12
    3614:	46bd      	mov	sp, r7
    3616:	f85d 7b04 	ldr.w	r7, [sp], #4
    361a:	4770      	bx	lr

0000361c <hri_sercomspi_write_DBGCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomspi_write_DBGCTRL_reg(const void *const hw, hri_sercomspi_dbgctrl_reg_t data)
{
    361c:	b480      	push	{r7}
    361e:	b083      	sub	sp, #12
    3620:	af00      	add	r7, sp, #0
    3622:	6078      	str	r0, [r7, #4]
    3624:	460b      	mov	r3, r1
    3626:	70fb      	strb	r3, [r7, #3]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
    3628:	687b      	ldr	r3, [r7, #4]
    362a:	78fa      	ldrb	r2, [r7, #3]
    362c:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3630:	bf00      	nop
    3632:	370c      	adds	r7, #12
    3634:	46bd      	mov	sp, r7
    3636:	f85d 7b04 	ldr.w	r7, [sp], #4
    363a:	4770      	bx	lr

0000363c <hri_sercomusart_write_DBGCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_DBGCTRL_reg(const void *const hw, hri_sercomusart_dbgctrl_reg_t data)
{
    363c:	b480      	push	{r7}
    363e:	b083      	sub	sp, #12
    3640:	af00      	add	r7, sp, #0
    3642:	6078      	str	r0, [r7, #4]
    3644:	460b      	mov	r3, r1
    3646:	70fb      	strb	r3, [r7, #3]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
    3648:	687b      	ldr	r3, [r7, #4]
    364a:	78fa      	ldrb	r2, [r7, #3]
    364c:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    3650:	bf00      	nop
    3652:	370c      	adds	r7, #12
    3654:	46bd      	mov	sp, r7
    3656:	f85d 7b04 	ldr.w	r7, [sp], #4
    365a:	4770      	bx	lr

0000365c <hri_sercomspi_clear_STATUS_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomspi_clear_STATUS_reg(const void *const hw, hri_sercomspi_status_reg_t mask)
{
    365c:	b480      	push	{r7}
    365e:	b083      	sub	sp, #12
    3660:	af00      	add	r7, sp, #0
    3662:	6078      	str	r0, [r7, #4]
    3664:	460b      	mov	r3, r1
    3666:	807b      	strh	r3, [r7, #2]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.STATUS.reg = mask;
    3668:	687b      	ldr	r3, [r7, #4]
    366a:	887a      	ldrh	r2, [r7, #2]
    366c:	835a      	strh	r2, [r3, #26]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    366e:	bf00      	nop
    3670:	370c      	adds	r7, #12
    3672:	46bd      	mov	sp, r7
    3674:	f85d 7b04 	ldr.w	r7, [sp], #4
    3678:	4770      	bx	lr
	...

0000367c <hri_sercomi2cm_read_STATUS_BUSSTATE_bf>:
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomi2cm_status_reg_t hri_sercomi2cm_read_STATUS_BUSSTATE_bf(const void *const hw)
{
    367c:	b580      	push	{r7, lr}
    367e:	b082      	sub	sp, #8
    3680:	af00      	add	r7, sp, #0
    3682:	6078      	str	r0, [r7, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    3684:	2104      	movs	r1, #4
    3686:	6878      	ldr	r0, [r7, #4]
    3688:	4b06      	ldr	r3, [pc, #24]	; (36a4 <hri_sercomi2cm_read_STATUS_BUSSTATE_bf+0x28>)
    368a:	4798      	blx	r3
	return (((Sercom *)hw)->I2CM.STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE_Msk) >> SERCOM_I2CM_STATUS_BUSSTATE_Pos;
    368c:	687b      	ldr	r3, [r7, #4]
    368e:	8b5b      	ldrh	r3, [r3, #26]
    3690:	b29b      	uxth	r3, r3
    3692:	091b      	lsrs	r3, r3, #4
    3694:	b29b      	uxth	r3, r3
    3696:	f003 0303 	and.w	r3, r3, #3
    369a:	b29b      	uxth	r3, r3
}
    369c:	4618      	mov	r0, r3
    369e:	3708      	adds	r7, #8
    36a0:	46bd      	mov	sp, r7
    36a2:	bd80      	pop	{r7, pc}
    36a4:	00002ee9 	.word	0x00002ee9

000036a8 <hri_sercomi2cm_read_STATUS_reg>:
{
	((Sercom *)hw)->I2CM.STATUS.reg |= mask;
}

static inline hri_sercomi2cm_status_reg_t hri_sercomi2cm_read_STATUS_reg(const void *const hw)
{
    36a8:	b580      	push	{r7, lr}
    36aa:	b082      	sub	sp, #8
    36ac:	af00      	add	r7, sp, #0
    36ae:	6078      	str	r0, [r7, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    36b0:	2104      	movs	r1, #4
    36b2:	6878      	ldr	r0, [r7, #4]
    36b4:	4b04      	ldr	r3, [pc, #16]	; (36c8 <hri_sercomi2cm_read_STATUS_reg+0x20>)
    36b6:	4798      	blx	r3
	return ((Sercom *)hw)->I2CM.STATUS.reg;
    36b8:	687b      	ldr	r3, [r7, #4]
    36ba:	8b5b      	ldrh	r3, [r3, #26]
    36bc:	b29b      	uxth	r3, r3
}
    36be:	4618      	mov	r0, r3
    36c0:	3708      	adds	r7, #8
    36c2:	46bd      	mov	sp, r7
    36c4:	bd80      	pop	{r7, pc}
    36c6:	bf00      	nop
    36c8:	00002ee9 	.word	0x00002ee9

000036cc <hri_sercomi2cm_clear_STATUS_reg>:
{
	((Sercom *)hw)->I2CM.STATUS.reg ^= mask;
}

static inline void hri_sercomi2cm_clear_STATUS_reg(const void *const hw, hri_sercomi2cm_status_reg_t mask)
{
    36cc:	b580      	push	{r7, lr}
    36ce:	b082      	sub	sp, #8
    36d0:	af00      	add	r7, sp, #0
    36d2:	6078      	str	r0, [r7, #4]
    36d4:	460b      	mov	r3, r1
    36d6:	807b      	strh	r3, [r7, #2]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.STATUS.reg = mask;
    36d8:	687b      	ldr	r3, [r7, #4]
    36da:	887a      	ldrh	r2, [r7, #2]
    36dc:	835a      	strh	r2, [r3, #26]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
    36de:	2104      	movs	r1, #4
    36e0:	6878      	ldr	r0, [r7, #4]
    36e2:	4b03      	ldr	r3, [pc, #12]	; (36f0 <hri_sercomi2cm_clear_STATUS_reg+0x24>)
    36e4:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    36e6:	bf00      	nop
    36e8:	3708      	adds	r7, #8
    36ea:	46bd      	mov	sp, r7
    36ec:	bd80      	pop	{r7, pc}
    36ee:	bf00      	nop
    36f0:	00002ee9 	.word	0x00002ee9

000036f4 <_usart_sync_init>:

/**
 * \brief Initialize synchronous SERCOM USART
 */
int32_t _usart_sync_init(struct _usart_sync_device *const device, void *const hw)
{
    36f4:	b580      	push	{r7, lr}
    36f6:	b082      	sub	sp, #8
    36f8:	af00      	add	r7, sp, #0
    36fa:	6078      	str	r0, [r7, #4]
    36fc:	6039      	str	r1, [r7, #0]
	ASSERT(device);
    36fe:	687b      	ldr	r3, [r7, #4]
    3700:	2b00      	cmp	r3, #0
    3702:	bf14      	ite	ne
    3704:	2301      	movne	r3, #1
    3706:	2300      	moveq	r3, #0
    3708:	b2db      	uxtb	r3, r3
    370a:	22bb      	movs	r2, #187	; 0xbb
    370c:	4907      	ldr	r1, [pc, #28]	; (372c <_usart_sync_init+0x38>)
    370e:	4618      	mov	r0, r3
    3710:	4b07      	ldr	r3, [pc, #28]	; (3730 <_usart_sync_init+0x3c>)
    3712:	4798      	blx	r3

	device->hw = hw;
    3714:	687b      	ldr	r3, [r7, #4]
    3716:	683a      	ldr	r2, [r7, #0]
    3718:	601a      	str	r2, [r3, #0]

	return _usart_init(hw);
    371a:	6838      	ldr	r0, [r7, #0]
    371c:	4b05      	ldr	r3, [pc, #20]	; (3734 <_usart_sync_init+0x40>)
    371e:	4798      	blx	r3
    3720:	4603      	mov	r3, r0
}
    3722:	4618      	mov	r0, r3
    3724:	3708      	adds	r7, #8
    3726:	46bd      	mov	sp, r7
    3728:	bd80      	pop	{r7, pc}
    372a:	bf00      	nop
    372c:	0000561c 	.word	0x0000561c
    3730:	00001c39 	.word	0x00001c39
    3734:	000038a1 	.word	0x000038a1

00003738 <_usart_sync_write_byte>:

/**
 * \brief Write a byte to the given SERCOM USART instance
 */
void _usart_sync_write_byte(struct _usart_sync_device *const device, uint8_t data)
{
    3738:	b580      	push	{r7, lr}
    373a:	b082      	sub	sp, #8
    373c:	af00      	add	r7, sp, #0
    373e:	6078      	str	r0, [r7, #4]
    3740:	460b      	mov	r3, r1
    3742:	70fb      	strb	r3, [r7, #3]
	hri_sercomusart_write_DATA_reg(device->hw, data);
    3744:	687b      	ldr	r3, [r7, #4]
    3746:	681b      	ldr	r3, [r3, #0]
    3748:	78fa      	ldrb	r2, [r7, #3]
    374a:	4611      	mov	r1, r2
    374c:	4618      	mov	r0, r3
    374e:	4b03      	ldr	r3, [pc, #12]	; (375c <_usart_sync_write_byte+0x24>)
    3750:	4798      	blx	r3
}
    3752:	bf00      	nop
    3754:	3708      	adds	r7, #8
    3756:	46bd      	mov	sp, r7
    3758:	bd80      	pop	{r7, pc}
    375a:	bf00      	nop
    375c:	000035e9 	.word	0x000035e9

00003760 <_usart_sync_read_byte>:

/**
 * \brief Read a byte from the given SERCOM USART instance
 */
uint8_t _usart_sync_read_byte(const struct _usart_sync_device *const device)
{
    3760:	b580      	push	{r7, lr}
    3762:	b082      	sub	sp, #8
    3764:	af00      	add	r7, sp, #0
    3766:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_read_DATA_reg(device->hw);
    3768:	687b      	ldr	r3, [r7, #4]
    376a:	681b      	ldr	r3, [r3, #0]
    376c:	4618      	mov	r0, r3
    376e:	4b04      	ldr	r3, [pc, #16]	; (3780 <_usart_sync_read_byte+0x20>)
    3770:	4798      	blx	r3
    3772:	4603      	mov	r3, r0
    3774:	b2db      	uxtb	r3, r3
}
    3776:	4618      	mov	r0, r3
    3778:	3708      	adds	r7, #8
    377a:	46bd      	mov	sp, r7
    377c:	bd80      	pop	{r7, pc}
    377e:	bf00      	nop
    3780:	00003605 	.word	0x00003605

00003784 <_usart_sync_is_ready_to_send>:

/**
 * \brief Check if USART is ready to send next byte
 */
bool _usart_sync_is_ready_to_send(const struct _usart_sync_device *const device)
{
    3784:	b580      	push	{r7, lr}
    3786:	b082      	sub	sp, #8
    3788:	af00      	add	r7, sp, #0
    378a:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
    378c:	687b      	ldr	r3, [r7, #4]
    378e:	681b      	ldr	r3, [r3, #0]
    3790:	4618      	mov	r0, r3
    3792:	4b03      	ldr	r3, [pc, #12]	; (37a0 <_usart_sync_is_ready_to_send+0x1c>)
    3794:	4798      	blx	r3
    3796:	4603      	mov	r3, r0
}
    3798:	4618      	mov	r0, r3
    379a:	3708      	adds	r7, #8
    379c:	46bd      	mov	sp, r7
    379e:	bd80      	pop	{r7, pc}
    37a0:	00003081 	.word	0x00003081

000037a4 <_usart_sync_is_transmit_done>:

/**
 * \brief Check if USART transmission complete
 */
bool _usart_sync_is_transmit_done(const struct _usart_sync_device *const device)
{
    37a4:	b580      	push	{r7, lr}
    37a6:	b082      	sub	sp, #8
    37a8:	af00      	add	r7, sp, #0
    37aa:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
    37ac:	687b      	ldr	r3, [r7, #4]
    37ae:	681b      	ldr	r3, [r3, #0]
    37b0:	4618      	mov	r0, r3
    37b2:	4b03      	ldr	r3, [pc, #12]	; (37c0 <_usart_sync_is_transmit_done+0x1c>)
    37b4:	4798      	blx	r3
    37b6:	4603      	mov	r3, r0
}
    37b8:	4618      	mov	r0, r3
    37ba:	3708      	adds	r7, #8
    37bc:	46bd      	mov	sp, r7
    37be:	bd80      	pop	{r7, pc}
    37c0:	000030a9 	.word	0x000030a9

000037c4 <_usart_sync_is_byte_received>:

/**
 * \brief Check if there is data received by USART
 */
bool _usart_sync_is_byte_received(const struct _usart_sync_device *const device)
{
    37c4:	b580      	push	{r7, lr}
    37c6:	b082      	sub	sp, #8
    37c8:	af00      	add	r7, sp, #0
    37ca:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
    37cc:	687b      	ldr	r3, [r7, #4]
    37ce:	681b      	ldr	r3, [r3, #0]
    37d0:	4618      	mov	r0, r3
    37d2:	4b03      	ldr	r3, [pc, #12]	; (37e0 <_usart_sync_is_byte_received+0x1c>)
    37d4:	4798      	blx	r3
    37d6:	4603      	mov	r3, r0
}
    37d8:	4618      	mov	r0, r3
    37da:	3708      	adds	r7, #8
    37dc:	46bd      	mov	sp, r7
    37de:	bd80      	pop	{r7, pc}
    37e0:	000030d3 	.word	0x000030d3

000037e4 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
    37e4:	b4b0      	push	{r4, r5, r7}
    37e6:	b08d      	sub	sp, #52	; 0x34
    37e8:	af00      	add	r7, sp, #0
    37ea:	6078      	str	r0, [r7, #4]
	Sercom *const sercom_modules[] = SERCOM_INSTS;
    37ec:	4b12      	ldr	r3, [pc, #72]	; (3838 <_sercom_get_hardware_index+0x54>)
    37ee:	f107 040c 	add.w	r4, r7, #12
    37f2:	461d      	mov	r5, r3
    37f4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    37f6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    37f8:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    37fc:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	/* Find index for SERCOM instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    3800:	2300      	movs	r3, #0
    3802:	62fb      	str	r3, [r7, #44]	; 0x2c
    3804:	e00f      	b.n	3826 <_sercom_get_hardware_index+0x42>
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
    3806:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    3808:	009b      	lsls	r3, r3, #2
    380a:	3330      	adds	r3, #48	; 0x30
    380c:	443b      	add	r3, r7
    380e:	f853 3c24 	ldr.w	r3, [r3, #-36]
    3812:	461a      	mov	r2, r3
    3814:	687b      	ldr	r3, [r7, #4]
    3816:	429a      	cmp	r2, r3
    3818:	d102      	bne.n	3820 <_sercom_get_hardware_index+0x3c>
			return i;
    381a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    381c:	b2db      	uxtb	r3, r3
    381e:	e006      	b.n	382e <_sercom_get_hardware_index+0x4a>
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    3820:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    3822:	3301      	adds	r3, #1
    3824:	62fb      	str	r3, [r7, #44]	; 0x2c
    3826:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    3828:	2b07      	cmp	r3, #7
    382a:	d9ec      	bls.n	3806 <_sercom_get_hardware_index+0x22>
		}
	}
	return 0;
    382c:	2300      	movs	r3, #0
}
    382e:	4618      	mov	r0, r3
    3830:	3734      	adds	r7, #52	; 0x34
    3832:	46bd      	mov	sp, r7
    3834:	bcb0      	pop	{r4, r5, r7}
    3836:	4770      	bx	lr
    3838:	00005638 	.word	0x00005638

0000383c <_get_sercom_index>:
 * \param[in] hw The pointer to hardware instance

 * \return The ordinal number of the given sercom hardware instance
 */
static uint8_t _get_sercom_index(const void *const hw)
{
    383c:	b580      	push	{r7, lr}
    383e:	b084      	sub	sp, #16
    3840:	af00      	add	r7, sp, #0
    3842:	6078      	str	r0, [r7, #4]
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    3844:	6878      	ldr	r0, [r7, #4]
    3846:	4b12      	ldr	r3, [pc, #72]	; (3890 <_get_sercom_index+0x54>)
    3848:	4798      	blx	r3
    384a:	4603      	mov	r3, r0
    384c:	73bb      	strb	r3, [r7, #14]
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
    384e:	2300      	movs	r3, #0
    3850:	73fb      	strb	r3, [r7, #15]
    3852:	e00f      	b.n	3874 <_get_sercom_index+0x38>
		if (_usarts[i].number == sercom_offset) {
    3854:	7bfa      	ldrb	r2, [r7, #15]
    3856:	490f      	ldr	r1, [pc, #60]	; (3894 <_get_sercom_index+0x58>)
    3858:	4613      	mov	r3, r2
    385a:	005b      	lsls	r3, r3, #1
    385c:	4413      	add	r3, r2
    385e:	00db      	lsls	r3, r3, #3
    3860:	440b      	add	r3, r1
    3862:	781b      	ldrb	r3, [r3, #0]
    3864:	7bba      	ldrb	r2, [r7, #14]
    3866:	429a      	cmp	r2, r3
    3868:	d101      	bne.n	386e <_get_sercom_index+0x32>
			return i;
    386a:	7bfb      	ldrb	r3, [r7, #15]
    386c:	e00c      	b.n	3888 <_get_sercom_index+0x4c>
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
    386e:	7bfb      	ldrb	r3, [r7, #15]
    3870:	3301      	adds	r3, #1
    3872:	73fb      	strb	r3, [r7, #15]
    3874:	7bfb      	ldrb	r3, [r7, #15]
    3876:	2b00      	cmp	r3, #0
    3878:	d0ec      	beq.n	3854 <_get_sercom_index+0x18>
		}
	}

	ASSERT(false);
    387a:	f240 2247 	movw	r2, #583	; 0x247
    387e:	4906      	ldr	r1, [pc, #24]	; (3898 <_get_sercom_index+0x5c>)
    3880:	2000      	movs	r0, #0
    3882:	4b06      	ldr	r3, [pc, #24]	; (389c <_get_sercom_index+0x60>)
    3884:	4798      	blx	r3
	return 0;
    3886:	2300      	movs	r3, #0
}
    3888:	4618      	mov	r0, r3
    388a:	3710      	adds	r7, #16
    388c:	46bd      	mov	sp, r7
    388e:	bd80      	pop	{r7, pc}
    3890:	000037e5 	.word	0x000037e5
    3894:	20000000 	.word	0x20000000
    3898:	0000561c 	.word	0x0000561c
    389c:	00001c39 	.word	0x00001c39

000038a0 <_usart_init>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The status of initialization
 */
static int32_t _usart_init(void *const hw)
{
    38a0:	b580      	push	{r7, lr}
    38a2:	b084      	sub	sp, #16
    38a4:	af00      	add	r7, sp, #0
    38a6:	6078      	str	r0, [r7, #4]
	uint8_t i = _get_sercom_index(hw);
    38a8:	6878      	ldr	r0, [r7, #4]
    38aa:	4b61      	ldr	r3, [pc, #388]	; (3a30 <_usart_init+0x190>)
    38ac:	4798      	blx	r3
    38ae:	4603      	mov	r3, r0
    38b0:	73fb      	strb	r3, [r7, #15]

	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
    38b2:	2101      	movs	r1, #1
    38b4:	6878      	ldr	r0, [r7, #4]
    38b6:	4b5f      	ldr	r3, [pc, #380]	; (3a34 <_usart_init+0x194>)
    38b8:	4798      	blx	r3
    38ba:	4603      	mov	r3, r0
    38bc:	f083 0301 	eor.w	r3, r3, #1
    38c0:	b2db      	uxtb	r3, r3
    38c2:	2b00      	cmp	r3, #0
    38c4:	d020      	beq.n	3908 <_usart_init+0x68>
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
    38c6:	7bfa      	ldrb	r2, [r7, #15]
    38c8:	495b      	ldr	r1, [pc, #364]	; (3a38 <_usart_init+0x198>)
    38ca:	4613      	mov	r3, r2
    38cc:	005b      	lsls	r3, r3, #1
    38ce:	4413      	add	r3, r2
    38d0:	00db      	lsls	r3, r3, #3
    38d2:	440b      	add	r3, r1
    38d4:	3304      	adds	r3, #4
    38d6:	681b      	ldr	r3, [r3, #0]
    38d8:	f003 031c 	and.w	r3, r3, #28
    38dc:	60bb      	str	r3, [r7, #8]
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
    38de:	2102      	movs	r1, #2
    38e0:	6878      	ldr	r0, [r7, #4]
    38e2:	4b56      	ldr	r3, [pc, #344]	; (3a3c <_usart_init+0x19c>)
    38e4:	4798      	blx	r3
    38e6:	4603      	mov	r3, r0
    38e8:	2b00      	cmp	r3, #0
    38ea:	d006      	beq.n	38fa <_usart_init+0x5a>
			hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
    38ec:	6878      	ldr	r0, [r7, #4]
    38ee:	4b54      	ldr	r3, [pc, #336]	; (3a40 <_usart_init+0x1a0>)
    38f0:	4798      	blx	r3
			hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_ENABLE);
    38f2:	2102      	movs	r1, #2
    38f4:	6878      	ldr	r0, [r7, #4]
    38f6:	4b53      	ldr	r3, [pc, #332]	; (3a44 <_usart_init+0x1a4>)
    38f8:	4798      	blx	r3
		}
		hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST | mode);
    38fa:	68bb      	ldr	r3, [r7, #8]
    38fc:	f043 0301 	orr.w	r3, r3, #1
    3900:	4619      	mov	r1, r3
    3902:	6878      	ldr	r0, [r7, #4]
    3904:	4b50      	ldr	r3, [pc, #320]	; (3a48 <_usart_init+0x1a8>)
    3906:	4798      	blx	r3
	}
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST);
    3908:	2101      	movs	r1, #1
    390a:	6878      	ldr	r0, [r7, #4]
    390c:	4b4d      	ldr	r3, [pc, #308]	; (3a44 <_usart_init+0x1a4>)
    390e:	4798      	blx	r3

	hri_sercomusart_write_CTRLA_reg(hw, _usarts[i].ctrl_a);
    3910:	7bfa      	ldrb	r2, [r7, #15]
    3912:	4949      	ldr	r1, [pc, #292]	; (3a38 <_usart_init+0x198>)
    3914:	4613      	mov	r3, r2
    3916:	005b      	lsls	r3, r3, #1
    3918:	4413      	add	r3, r2
    391a:	00db      	lsls	r3, r3, #3
    391c:	440b      	add	r3, r1
    391e:	3304      	adds	r3, #4
    3920:	681b      	ldr	r3, [r3, #0]
    3922:	4619      	mov	r1, r3
    3924:	6878      	ldr	r0, [r7, #4]
    3926:	4b48      	ldr	r3, [pc, #288]	; (3a48 <_usart_init+0x1a8>)
    3928:	4798      	blx	r3
	hri_sercomusart_write_CTRLB_reg(hw, _usarts[i].ctrl_b);
    392a:	7bfa      	ldrb	r2, [r7, #15]
    392c:	4942      	ldr	r1, [pc, #264]	; (3a38 <_usart_init+0x198>)
    392e:	4613      	mov	r3, r2
    3930:	005b      	lsls	r3, r3, #1
    3932:	4413      	add	r3, r2
    3934:	00db      	lsls	r3, r3, #3
    3936:	440b      	add	r3, r1
    3938:	3308      	adds	r3, #8
    393a:	681b      	ldr	r3, [r3, #0]
    393c:	4619      	mov	r1, r3
    393e:	6878      	ldr	r0, [r7, #4]
    3940:	4b42      	ldr	r3, [pc, #264]	; (3a4c <_usart_init+0x1ac>)
    3942:	4798      	blx	r3
	hri_sercomusart_write_CTRLC_reg(hw, _usarts[i].ctrl_c);
    3944:	7bfa      	ldrb	r2, [r7, #15]
    3946:	493c      	ldr	r1, [pc, #240]	; (3a38 <_usart_init+0x198>)
    3948:	4613      	mov	r3, r2
    394a:	005b      	lsls	r3, r3, #1
    394c:	4413      	add	r3, r2
    394e:	00db      	lsls	r3, r3, #3
    3950:	440b      	add	r3, r1
    3952:	330c      	adds	r3, #12
    3954:	681b      	ldr	r3, [r3, #0]
    3956:	4619      	mov	r1, r3
    3958:	6878      	ldr	r0, [r7, #4]
    395a:	4b3d      	ldr	r3, [pc, #244]	; (3a50 <_usart_init+0x1b0>)
    395c:	4798      	blx	r3
	if ((_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x1)) || (_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x3))) {
    395e:	7bfa      	ldrb	r2, [r7, #15]
    3960:	4935      	ldr	r1, [pc, #212]	; (3a38 <_usart_init+0x198>)
    3962:	4613      	mov	r3, r2
    3964:	005b      	lsls	r3, r3, #1
    3966:	4413      	add	r3, r2
    3968:	00db      	lsls	r3, r3, #3
    396a:	440b      	add	r3, r1
    396c:	3304      	adds	r3, #4
    396e:	681b      	ldr	r3, [r3, #0]
    3970:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
    3974:	2b00      	cmp	r3, #0
    3976:	d10c      	bne.n	3992 <_usart_init+0xf2>
    3978:	7bfa      	ldrb	r2, [r7, #15]
    397a:	492f      	ldr	r1, [pc, #188]	; (3a38 <_usart_init+0x198>)
    397c:	4613      	mov	r3, r2
    397e:	005b      	lsls	r3, r3, #1
    3980:	4413      	add	r3, r2
    3982:	00db      	lsls	r3, r3, #3
    3984:	440b      	add	r3, r1
    3986:	3304      	adds	r3, #4
    3988:	681b      	ldr	r3, [r3, #0]
    398a:	f403 43c0 	and.w	r3, r3, #24576	; 0x6000
    398e:	2b00      	cmp	r3, #0
    3990:	d022      	beq.n	39d8 <_usart_init+0x138>
		((Sercom *)hw)->USART.BAUD.FRAC.BAUD = _usarts[i].baud;
    3992:	7bfa      	ldrb	r2, [r7, #15]
    3994:	4928      	ldr	r1, [pc, #160]	; (3a38 <_usart_init+0x198>)
    3996:	4613      	mov	r3, r2
    3998:	005b      	lsls	r3, r3, #1
    399a:	4413      	add	r3, r2
    399c:	00db      	lsls	r3, r3, #3
    399e:	440b      	add	r3, r1
    39a0:	3310      	adds	r3, #16
    39a2:	881b      	ldrh	r3, [r3, #0]
    39a4:	f3c3 030c 	ubfx	r3, r3, #0, #13
    39a8:	b299      	uxth	r1, r3
    39aa:	687a      	ldr	r2, [r7, #4]
    39ac:	8993      	ldrh	r3, [r2, #12]
    39ae:	f361 030c 	bfi	r3, r1, #0, #13
    39b2:	8193      	strh	r3, [r2, #12]
		((Sercom *)hw)->USART.BAUD.FRAC.FP   = _usarts[i].fractional;
    39b4:	7bfa      	ldrb	r2, [r7, #15]
    39b6:	4920      	ldr	r1, [pc, #128]	; (3a38 <_usart_init+0x198>)
    39b8:	4613      	mov	r3, r2
    39ba:	005b      	lsls	r3, r3, #1
    39bc:	4413      	add	r3, r2
    39be:	00db      	lsls	r3, r3, #3
    39c0:	440b      	add	r3, r1
    39c2:	3312      	adds	r3, #18
    39c4:	781b      	ldrb	r3, [r3, #0]
    39c6:	f003 0307 	and.w	r3, r3, #7
    39ca:	b2d9      	uxtb	r1, r3
    39cc:	687a      	ldr	r2, [r7, #4]
    39ce:	8993      	ldrh	r3, [r2, #12]
    39d0:	f361 334f 	bfi	r3, r1, #13, #3
    39d4:	8193      	strh	r3, [r2, #12]
    39d6:	e00c      	b.n	39f2 <_usart_init+0x152>
	} else {
		hri_sercomusart_write_BAUD_reg(hw, _usarts[i].baud);
    39d8:	7bfa      	ldrb	r2, [r7, #15]
    39da:	4917      	ldr	r1, [pc, #92]	; (3a38 <_usart_init+0x198>)
    39dc:	4613      	mov	r3, r2
    39de:	005b      	lsls	r3, r3, #1
    39e0:	4413      	add	r3, r2
    39e2:	00db      	lsls	r3, r3, #3
    39e4:	440b      	add	r3, r1
    39e6:	3310      	adds	r3, #16
    39e8:	881b      	ldrh	r3, [r3, #0]
    39ea:	4619      	mov	r1, r3
    39ec:	6878      	ldr	r0, [r7, #4]
    39ee:	4b19      	ldr	r3, [pc, #100]	; (3a54 <_usart_init+0x1b4>)
    39f0:	4798      	blx	r3
	}

	hri_sercomusart_write_RXPL_reg(hw, _usarts[i].rxpl);
    39f2:	7bfa      	ldrb	r2, [r7, #15]
    39f4:	4910      	ldr	r1, [pc, #64]	; (3a38 <_usart_init+0x198>)
    39f6:	4613      	mov	r3, r2
    39f8:	005b      	lsls	r3, r3, #1
    39fa:	4413      	add	r3, r2
    39fc:	00db      	lsls	r3, r3, #3
    39fe:	440b      	add	r3, r1
    3a00:	3313      	adds	r3, #19
    3a02:	781b      	ldrb	r3, [r3, #0]
    3a04:	4619      	mov	r1, r3
    3a06:	6878      	ldr	r0, [r7, #4]
    3a08:	4b13      	ldr	r3, [pc, #76]	; (3a58 <_usart_init+0x1b8>)
    3a0a:	4798      	blx	r3
	hri_sercomusart_write_DBGCTRL_reg(hw, _usarts[i].debug_ctrl);
    3a0c:	7bfa      	ldrb	r2, [r7, #15]
    3a0e:	490a      	ldr	r1, [pc, #40]	; (3a38 <_usart_init+0x198>)
    3a10:	4613      	mov	r3, r2
    3a12:	005b      	lsls	r3, r3, #1
    3a14:	4413      	add	r3, r2
    3a16:	00db      	lsls	r3, r3, #3
    3a18:	440b      	add	r3, r1
    3a1a:	3314      	adds	r3, #20
    3a1c:	781b      	ldrb	r3, [r3, #0]
    3a1e:	4619      	mov	r1, r3
    3a20:	6878      	ldr	r0, [r7, #4]
    3a22:	4b0e      	ldr	r3, [pc, #56]	; (3a5c <_usart_init+0x1bc>)
    3a24:	4798      	blx	r3

	return ERR_NONE;
    3a26:	2300      	movs	r3, #0
}
    3a28:	4618      	mov	r0, r3
    3a2a:	3710      	adds	r7, #16
    3a2c:	46bd      	mov	sp, r7
    3a2e:	bd80      	pop	{r7, pc}
    3a30:	0000383d 	.word	0x0000383d
    3a34:	00002fab 	.word	0x00002fab
    3a38:	20000000 	.word	0x20000000
    3a3c:	000032ad 	.word	0x000032ad
    3a40:	00003285 	.word	0x00003285
    3a44:	00002f85 	.word	0x00002f85
    3a48:	000032dd 	.word	0x000032dd
    3a4c:	00003419 	.word	0x00003419
    3a50:	0000343d 	.word	0x0000343d
    3a54:	00003493 	.word	0x00003493
    3a58:	000034b1 	.word	0x000034b1
    3a5c:	0000363d 	.word	0x0000363d

00003a60 <_get_i2cm_index>:
 * \param[in] hw The pointer to hardware instance

 * \return The ordinal number of the given sercom hardware instance
 */
static int8_t _get_i2cm_index(const void *const hw)
{
    3a60:	b580      	push	{r7, lr}
    3a62:	b084      	sub	sp, #16
    3a64:	af00      	add	r7, sp, #0
    3a66:	6078      	str	r0, [r7, #4]
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    3a68:	6878      	ldr	r0, [r7, #4]
    3a6a:	4b13      	ldr	r3, [pc, #76]	; (3ab8 <_get_i2cm_index+0x58>)
    3a6c:	4798      	blx	r3
    3a6e:	4603      	mov	r3, r0
    3a70:	73bb      	strb	r3, [r7, #14]
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_i2cms); i++) {
    3a72:	2300      	movs	r3, #0
    3a74:	73fb      	strb	r3, [r7, #15]
    3a76:	e010      	b.n	3a9a <_get_i2cm_index+0x3a>
		if (_i2cms[i].number == sercom_offset) {
    3a78:	7bfa      	ldrb	r2, [r7, #15]
    3a7a:	4910      	ldr	r1, [pc, #64]	; (3abc <_get_i2cm_index+0x5c>)
    3a7c:	4613      	mov	r3, r2
    3a7e:	005b      	lsls	r3, r3, #1
    3a80:	4413      	add	r3, r2
    3a82:	00db      	lsls	r3, r3, #3
    3a84:	440b      	add	r3, r1
    3a86:	781b      	ldrb	r3, [r3, #0]
    3a88:	7bba      	ldrb	r2, [r7, #14]
    3a8a:	429a      	cmp	r2, r3
    3a8c:	d102      	bne.n	3a94 <_get_i2cm_index+0x34>
			return i;
    3a8e:	f997 300f 	ldrsb.w	r3, [r7, #15]
    3a92:	e00d      	b.n	3ab0 <_get_i2cm_index+0x50>
	for (i = 0; i < ARRAY_SIZE(_i2cms); i++) {
    3a94:	7bfb      	ldrb	r3, [r7, #15]
    3a96:	3301      	adds	r3, #1
    3a98:	73fb      	strb	r3, [r7, #15]
    3a9a:	7bfb      	ldrb	r3, [r7, #15]
    3a9c:	2b00      	cmp	r3, #0
    3a9e:	d0eb      	beq.n	3a78 <_get_i2cm_index+0x18>
		}
	}

	ASSERT(false);
    3aa0:	f240 32a6 	movw	r2, #934	; 0x3a6
    3aa4:	4906      	ldr	r1, [pc, #24]	; (3ac0 <_get_i2cm_index+0x60>)
    3aa6:	2000      	movs	r0, #0
    3aa8:	4b06      	ldr	r3, [pc, #24]	; (3ac4 <_get_i2cm_index+0x64>)
    3aaa:	4798      	blx	r3
	return -1;
    3aac:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
    3ab0:	4618      	mov	r0, r3
    3ab2:	3710      	adds	r7, #16
    3ab4:	46bd      	mov	sp, r7
    3ab6:	bd80      	pop	{r7, pc}
    3ab8:	000037e5 	.word	0x000037e5
    3abc:	20000018 	.word	0x20000018
    3ac0:	0000561c 	.word	0x0000561c
    3ac4:	00001c39 	.word	0x00001c39

00003ac8 <_sercom_i2c_send_stop>:

static inline void _sercom_i2c_send_stop(void *const hw)
{
    3ac8:	b580      	push	{r7, lr}
    3aca:	b082      	sub	sp, #8
    3acc:	af00      	add	r7, sp, #0
    3ace:	6078      	str	r0, [r7, #4]
	hri_sercomi2cm_set_CTRLB_CMD_bf(hw, CMD_STOP);
    3ad0:	2103      	movs	r1, #3
    3ad2:	6878      	ldr	r0, [r7, #4]
    3ad4:	4b02      	ldr	r3, [pc, #8]	; (3ae0 <_sercom_i2c_send_stop+0x18>)
    3ad6:	4798      	blx	r3
}
    3ad8:	bf00      	nop
    3ada:	3708      	adds	r7, #8
    3adc:	46bd      	mov	sp, r7
    3ade:	bd80      	pop	{r7, pc}
    3ae0:	000033a1 	.word	0x000033a1

00003ae4 <_sercom_i2c_sync_analyse_flags>:

/**
 * \brief SERCOM I2CM analyze hardware status and transfer next byte
 */
static inline int32_t _sercom_i2c_sync_analyse_flags(void *const hw, uint32_t flags, struct _i2c_m_msg *const msg)
{
    3ae4:	b590      	push	{r4, r7, lr}
    3ae6:	b087      	sub	sp, #28
    3ae8:	af00      	add	r7, sp, #0
    3aea:	60f8      	str	r0, [r7, #12]
    3aec:	60b9      	str	r1, [r7, #8]
    3aee:	607a      	str	r2, [r7, #4]
	int      sclsm  = hri_sercomi2cm_get_CTRLA_SCLSM_bit(hw);
    3af0:	68f8      	ldr	r0, [r7, #12]
    3af2:	4b7c      	ldr	r3, [pc, #496]	; (3ce4 <_sercom_i2c_sync_analyse_flags+0x200>)
    3af4:	4798      	blx	r3
    3af6:	4603      	mov	r3, r0
    3af8:	617b      	str	r3, [r7, #20]
	uint16_t status = hri_sercomi2cm_read_STATUS_reg(hw);
    3afa:	68f8      	ldr	r0, [r7, #12]
    3afc:	4b7a      	ldr	r3, [pc, #488]	; (3ce8 <_sercom_i2c_sync_analyse_flags+0x204>)
    3afe:	4798      	blx	r3
    3b00:	4603      	mov	r3, r0
    3b02:	827b      	strh	r3, [r7, #18]

	if (flags & MB_FLAG) {
    3b04:	68bb      	ldr	r3, [r7, #8]
    3b06:	f003 0301 	and.w	r3, r3, #1
    3b0a:	2b00      	cmp	r3, #0
    3b0c:	f000 8095 	beq.w	3c3a <_sercom_i2c_sync_analyse_flags+0x156>
		/* tx error */
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
    3b10:	8a7b      	ldrh	r3, [r7, #18]
    3b12:	f003 0302 	and.w	r3, r3, #2
    3b16:	2b00      	cmp	r3, #0
    3b18:	d01d      	beq.n	3b56 <_sercom_i2c_sync_analyse_flags+0x72>
			hri_sercomi2cm_clear_interrupt_MB_bit(hw);
    3b1a:	68f8      	ldr	r0, [r7, #12]
    3b1c:	4b73      	ldr	r3, [pc, #460]	; (3cec <_sercom_i2c_sync_analyse_flags+0x208>)
    3b1e:	4798      	blx	r3
			msg->flags |= I2C_M_FAIL;
    3b20:	687b      	ldr	r3, [r7, #4]
    3b22:	885b      	ldrh	r3, [r3, #2]
    3b24:	b29b      	uxth	r3, r3
    3b26:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    3b2a:	b29a      	uxth	r2, r3
    3b2c:	687b      	ldr	r3, [r7, #4]
    3b2e:	805a      	strh	r2, [r3, #2]
			msg->flags &= ~I2C_M_BUSY;
    3b30:	687b      	ldr	r3, [r7, #4]
    3b32:	885b      	ldrh	r3, [r3, #2]
    3b34:	b29b      	uxth	r3, r3
    3b36:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    3b3a:	b29a      	uxth	r2, r3
    3b3c:	687b      	ldr	r3, [r7, #4]
    3b3e:	805a      	strh	r2, [r3, #2]

			if (status & SERCOM_I2CM_STATUS_BUSERR) {
    3b40:	8a7b      	ldrh	r3, [r7, #18]
    3b42:	f003 0301 	and.w	r3, r3, #1
    3b46:	2b00      	cmp	r3, #0
    3b48:	d002      	beq.n	3b50 <_sercom_i2c_sync_analyse_flags+0x6c>
				return I2C_ERR_BUS;
    3b4a:	f06f 0304 	mvn.w	r3, #4
    3b4e:	e0c5      	b.n	3cdc <_sercom_i2c_sync_analyse_flags+0x1f8>
			}

			return I2C_ERR_BAD_ADDRESS;
    3b50:	f06f 0303 	mvn.w	r3, #3
    3b54:	e0c2      	b.n	3cdc <_sercom_i2c_sync_analyse_flags+0x1f8>
		} else {
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
    3b56:	8a7b      	ldrh	r3, [r7, #18]
    3b58:	f003 0304 	and.w	r3, r3, #4
    3b5c:	2b00      	cmp	r3, #0
    3b5e:	d01f      	beq.n	3ba0 <_sercom_i2c_sync_analyse_flags+0xbc>

				/* Slave rejects to receive more data */
				if (msg->len > 0) {
    3b60:	687b      	ldr	r3, [r7, #4]
    3b62:	685b      	ldr	r3, [r3, #4]
    3b64:	2b00      	cmp	r3, #0
    3b66:	dd07      	ble.n	3b78 <_sercom_i2c_sync_analyse_flags+0x94>
					msg->flags |= I2C_M_FAIL;
    3b68:	687b      	ldr	r3, [r7, #4]
    3b6a:	885b      	ldrh	r3, [r3, #2]
    3b6c:	b29b      	uxth	r3, r3
    3b6e:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    3b72:	b29a      	uxth	r2, r3
    3b74:	687b      	ldr	r3, [r7, #4]
    3b76:	805a      	strh	r2, [r3, #2]
				}

				if (msg->flags & I2C_M_STOP) {
    3b78:	687b      	ldr	r3, [r7, #4]
    3b7a:	885b      	ldrh	r3, [r3, #2]
    3b7c:	b29b      	uxth	r3, r3
    3b7e:	b21b      	sxth	r3, r3
    3b80:	2b00      	cmp	r3, #0
    3b82:	da02      	bge.n	3b8a <_sercom_i2c_sync_analyse_flags+0xa6>
					_sercom_i2c_send_stop(hw);
    3b84:	68f8      	ldr	r0, [r7, #12]
    3b86:	4b5a      	ldr	r3, [pc, #360]	; (3cf0 <_sercom_i2c_sync_analyse_flags+0x20c>)
    3b88:	4798      	blx	r3
				}

				msg->flags &= ~I2C_M_BUSY;
    3b8a:	687b      	ldr	r3, [r7, #4]
    3b8c:	885b      	ldrh	r3, [r3, #2]
    3b8e:	b29b      	uxth	r3, r3
    3b90:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    3b94:	b29a      	uxth	r2, r3
    3b96:	687b      	ldr	r3, [r7, #4]
    3b98:	805a      	strh	r2, [r3, #2]

				return I2C_NACK;
    3b9a:	f06f 0301 	mvn.w	r3, #1
    3b9e:	e09d      	b.n	3cdc <_sercom_i2c_sync_analyse_flags+0x1f8>
			}

			if (msg->flags & I2C_M_TEN) {
    3ba0:	687b      	ldr	r3, [r7, #4]
    3ba2:	885b      	ldrh	r3, [r3, #2]
    3ba4:	b29b      	uxth	r3, r3
    3ba6:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    3baa:	2b00      	cmp	r3, #0
    3bac:	d01c      	beq.n	3be8 <_sercom_i2c_sync_analyse_flags+0x104>
				hri_sercomi2cm_write_ADDR_reg(hw,
				                              ((((msg->addr & TEN_ADDR_MASK) >> 8) | TEN_ADDR_FRAME) << 1) | I2C_M_RD
    3bae:	687b      	ldr	r3, [r7, #4]
    3bb0:	881b      	ldrh	r3, [r3, #0]
    3bb2:	121b      	asrs	r3, r3, #8
    3bb4:	005b      	lsls	r3, r3, #1
				                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    3bb6:	f003 0406 	and.w	r4, r3, #6
    3bba:	68f8      	ldr	r0, [r7, #12]
    3bbc:	4b4d      	ldr	r3, [pc, #308]	; (3cf4 <_sercom_i2c_sync_analyse_flags+0x210>)
    3bbe:	4798      	blx	r3
    3bc0:	4603      	mov	r3, r0
    3bc2:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    3bc6:	4323      	orrs	r3, r4
				hri_sercomi2cm_write_ADDR_reg(hw,
    3bc8:	f043 03f1 	orr.w	r3, r3, #241	; 0xf1
    3bcc:	4619      	mov	r1, r3
    3bce:	68f8      	ldr	r0, [r7, #12]
    3bd0:	4b49      	ldr	r3, [pc, #292]	; (3cf8 <_sercom_i2c_sync_analyse_flags+0x214>)
    3bd2:	4798      	blx	r3
				msg->flags &= ~I2C_M_TEN;
    3bd4:	687b      	ldr	r3, [r7, #4]
    3bd6:	885b      	ldrh	r3, [r3, #2]
    3bd8:	b29b      	uxth	r3, r3
    3bda:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
    3bde:	b29a      	uxth	r2, r3
    3be0:	687b      	ldr	r3, [r7, #4]
    3be2:	805a      	strh	r2, [r3, #2]

				return I2C_OK;
    3be4:	2300      	movs	r3, #0
    3be6:	e079      	b.n	3cdc <_sercom_i2c_sync_analyse_flags+0x1f8>
			}

			if (msg->len == 0) {
    3be8:	687b      	ldr	r3, [r7, #4]
    3bea:	685b      	ldr	r3, [r3, #4]
    3bec:	2b00      	cmp	r3, #0
    3bee:	d111      	bne.n	3c14 <_sercom_i2c_sync_analyse_flags+0x130>
				if (msg->flags & I2C_M_STOP) {
    3bf0:	687b      	ldr	r3, [r7, #4]
    3bf2:	885b      	ldrh	r3, [r3, #2]
    3bf4:	b29b      	uxth	r3, r3
    3bf6:	b21b      	sxth	r3, r3
    3bf8:	2b00      	cmp	r3, #0
    3bfa:	da02      	bge.n	3c02 <_sercom_i2c_sync_analyse_flags+0x11e>
					_sercom_i2c_send_stop(hw);
    3bfc:	68f8      	ldr	r0, [r7, #12]
    3bfe:	4b3c      	ldr	r3, [pc, #240]	; (3cf0 <_sercom_i2c_sync_analyse_flags+0x20c>)
    3c00:	4798      	blx	r3
				}

				msg->flags &= ~I2C_M_BUSY;
    3c02:	687b      	ldr	r3, [r7, #4]
    3c04:	885b      	ldrh	r3, [r3, #2]
    3c06:	b29b      	uxth	r3, r3
    3c08:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    3c0c:	b29a      	uxth	r2, r3
    3c0e:	687b      	ldr	r3, [r7, #4]
    3c10:	805a      	strh	r2, [r3, #2]
    3c12:	e010      	b.n	3c36 <_sercom_i2c_sync_analyse_flags+0x152>
			} else {
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
    3c14:	687b      	ldr	r3, [r7, #4]
    3c16:	689b      	ldr	r3, [r3, #8]
    3c18:	781b      	ldrb	r3, [r3, #0]
    3c1a:	4619      	mov	r1, r3
    3c1c:	68f8      	ldr	r0, [r7, #12]
    3c1e:	4b37      	ldr	r3, [pc, #220]	; (3cfc <_sercom_i2c_sync_analyse_flags+0x218>)
    3c20:	4798      	blx	r3
				msg->buffer++;
    3c22:	687b      	ldr	r3, [r7, #4]
    3c24:	689b      	ldr	r3, [r3, #8]
    3c26:	1c5a      	adds	r2, r3, #1
    3c28:	687b      	ldr	r3, [r7, #4]
    3c2a:	609a      	str	r2, [r3, #8]
				msg->len--;
    3c2c:	687b      	ldr	r3, [r7, #4]
    3c2e:	685b      	ldr	r3, [r3, #4]
    3c30:	1e5a      	subs	r2, r3, #1
    3c32:	687b      	ldr	r3, [r7, #4]
    3c34:	605a      	str	r2, [r3, #4]
			}

			return I2C_OK;
    3c36:	2300      	movs	r3, #0
    3c38:	e050      	b.n	3cdc <_sercom_i2c_sync_analyse_flags+0x1f8>
		}
	} else if (flags & SB_FLAG) {
    3c3a:	68bb      	ldr	r3, [r7, #8]
    3c3c:	f003 0302 	and.w	r3, r3, #2
    3c40:	2b00      	cmp	r3, #0
    3c42:	d04a      	beq.n	3cda <_sercom_i2c_sync_analyse_flags+0x1f6>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
    3c44:	687b      	ldr	r3, [r7, #4]
    3c46:	685b      	ldr	r3, [r3, #4]
    3c48:	2b00      	cmp	r3, #0
    3c4a:	d040      	beq.n	3cce <_sercom_i2c_sync_analyse_flags+0x1ea>
    3c4c:	8a7b      	ldrh	r3, [r7, #18]
    3c4e:	f003 0304 	and.w	r3, r3, #4
    3c52:	2b00      	cmp	r3, #0
    3c54:	d13b      	bne.n	3cce <_sercom_i2c_sync_analyse_flags+0x1ea>
			msg->len--;
    3c56:	687b      	ldr	r3, [r7, #4]
    3c58:	685b      	ldr	r3, [r3, #4]
    3c5a:	1e5a      	subs	r2, r3, #1
    3c5c:	687b      	ldr	r3, [r7, #4]
    3c5e:	605a      	str	r2, [r3, #4]

			/* last byte, send nack */
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
    3c60:	687b      	ldr	r3, [r7, #4]
    3c62:	685b      	ldr	r3, [r3, #4]
    3c64:	2b00      	cmp	r3, #0
    3c66:	d102      	bne.n	3c6e <_sercom_i2c_sync_analyse_flags+0x18a>
    3c68:	697b      	ldr	r3, [r7, #20]
    3c6a:	2b00      	cmp	r3, #0
    3c6c:	d006      	beq.n	3c7c <_sercom_i2c_sync_analyse_flags+0x198>
    3c6e:	687b      	ldr	r3, [r7, #4]
    3c70:	685b      	ldr	r3, [r3, #4]
    3c72:	2b01      	cmp	r3, #1
    3c74:	d105      	bne.n	3c82 <_sercom_i2c_sync_analyse_flags+0x19e>
    3c76:	697b      	ldr	r3, [r7, #20]
    3c78:	2b00      	cmp	r3, #0
    3c7a:	d002      	beq.n	3c82 <_sercom_i2c_sync_analyse_flags+0x19e>
				hri_sercomi2cm_set_CTRLB_ACKACT_bit(hw);
    3c7c:	68f8      	ldr	r0, [r7, #12]
    3c7e:	4b20      	ldr	r3, [pc, #128]	; (3d00 <_sercom_i2c_sync_analyse_flags+0x21c>)
    3c80:	4798      	blx	r3
			}

			if (msg->len == 0) {
    3c82:	687b      	ldr	r3, [r7, #4]
    3c84:	685b      	ldr	r3, [r3, #4]
    3c86:	2b00      	cmp	r3, #0
    3c88:	d113      	bne.n	3cb2 <_sercom_i2c_sync_analyse_flags+0x1ce>
				if (msg->flags & I2C_M_STOP) {
    3c8a:	687b      	ldr	r3, [r7, #4]
    3c8c:	885b      	ldrh	r3, [r3, #2]
    3c8e:	b29b      	uxth	r3, r3
    3c90:	b21b      	sxth	r3, r3
    3c92:	2b00      	cmp	r3, #0
    3c94:	da05      	bge.n	3ca2 <_sercom_i2c_sync_analyse_flags+0x1be>
					hri_sercomi2cm_clear_CTRLB_SMEN_bit(hw);
    3c96:	68f8      	ldr	r0, [r7, #12]
    3c98:	4b1a      	ldr	r3, [pc, #104]	; (3d04 <_sercom_i2c_sync_analyse_flags+0x220>)
    3c9a:	4798      	blx	r3
					_sercom_i2c_send_stop(hw);
    3c9c:	68f8      	ldr	r0, [r7, #12]
    3c9e:	4b14      	ldr	r3, [pc, #80]	; (3cf0 <_sercom_i2c_sync_analyse_flags+0x20c>)
    3ca0:	4798      	blx	r3
				}

				msg->flags &= ~I2C_M_BUSY;
    3ca2:	687b      	ldr	r3, [r7, #4]
    3ca4:	885b      	ldrh	r3, [r3, #2]
    3ca6:	b29b      	uxth	r3, r3
    3ca8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    3cac:	b29a      	uxth	r2, r3
    3cae:	687b      	ldr	r3, [r7, #4]
    3cb0:	805a      	strh	r2, [r3, #2]

			/* Accessing DATA.DATA auto-triggers I2C bus operations.
			 * The operation performed depends on the state of
			 * CTRLB.ACKACT, CTRLB.SMEN
			 **/
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
    3cb2:	68f8      	ldr	r0, [r7, #12]
    3cb4:	4b14      	ldr	r3, [pc, #80]	; (3d08 <_sercom_i2c_sync_analyse_flags+0x224>)
    3cb6:	4798      	blx	r3
    3cb8:	687b      	ldr	r3, [r7, #4]
    3cba:	689b      	ldr	r3, [r3, #8]
    3cbc:	1c59      	adds	r1, r3, #1
    3cbe:	687a      	ldr	r2, [r7, #4]
    3cc0:	6091      	str	r1, [r2, #8]
    3cc2:	b2c2      	uxtb	r2, r0
    3cc4:	701a      	strb	r2, [r3, #0]
		} else {
			hri_sercomi2cm_clear_interrupt_SB_bit(hw);
			return I2C_NACK;
		}

		hri_sercomi2cm_clear_interrupt_SB_bit(hw);
    3cc6:	68f8      	ldr	r0, [r7, #12]
    3cc8:	4b10      	ldr	r3, [pc, #64]	; (3d0c <_sercom_i2c_sync_analyse_flags+0x228>)
    3cca:	4798      	blx	r3
    3ccc:	e005      	b.n	3cda <_sercom_i2c_sync_analyse_flags+0x1f6>
			hri_sercomi2cm_clear_interrupt_SB_bit(hw);
    3cce:	68f8      	ldr	r0, [r7, #12]
    3cd0:	4b0e      	ldr	r3, [pc, #56]	; (3d0c <_sercom_i2c_sync_analyse_flags+0x228>)
    3cd2:	4798      	blx	r3
			return I2C_NACK;
    3cd4:	f06f 0301 	mvn.w	r3, #1
    3cd8:	e000      	b.n	3cdc <_sercom_i2c_sync_analyse_flags+0x1f8>
	}

	return I2C_OK;
    3cda:	2300      	movs	r3, #0
}
    3cdc:	4618      	mov	r0, r3
    3cde:	371c      	adds	r7, #28
    3ce0:	46bd      	mov	sp, r7
    3ce2:	bd90      	pop	{r4, r7, pc}
    3ce4:	0000314d 	.word	0x0000314d
    3ce8:	000036a9 	.word	0x000036a9
    3cec:	00002fd3 	.word	0x00002fd3
    3cf0:	00003ac9 	.word	0x00003ac9
    3cf4:	00003535 	.word	0x00003535
    3cf8:	00003511 	.word	0x00003511
    3cfc:	00003571 	.word	0x00003571
    3d00:	00003351 	.word	0x00003351
    3d04:	00003329 	.word	0x00003329
    3d08:	00003595 	.word	0x00003595
    3d0c:	00002fed 	.word	0x00002fed

00003d10 <_i2c_m_sync_init>:
 * \brief Initialize sercom i2c module to use in sync mode
 *
 * \param[in] i2c_dev The pointer to i2c device
 */
int32_t _i2c_m_sync_init(struct _i2c_m_sync_device *const i2c_dev, void *const hw)
{
    3d10:	b580      	push	{r7, lr}
    3d12:	b082      	sub	sp, #8
    3d14:	af00      	add	r7, sp, #0
    3d16:	6078      	str	r0, [r7, #4]
    3d18:	6039      	str	r1, [r7, #0]
	ASSERT(i2c_dev);
    3d1a:	687b      	ldr	r3, [r7, #4]
    3d1c:	2b00      	cmp	r3, #0
    3d1e:	bf14      	ite	ne
    3d20:	2301      	movne	r3, #1
    3d22:	2300      	moveq	r3, #0
    3d24:	b2db      	uxtb	r3, r3
    3d26:	f44f 62a3 	mov.w	r2, #1304	; 0x518
    3d2a:	4908      	ldr	r1, [pc, #32]	; (3d4c <_i2c_m_sync_init+0x3c>)
    3d2c:	4618      	mov	r0, r3
    3d2e:	4b08      	ldr	r3, [pc, #32]	; (3d50 <_i2c_m_sync_init+0x40>)
    3d30:	4798      	blx	r3

	i2c_dev->hw = hw;
    3d32:	687b      	ldr	r3, [r7, #4]
    3d34:	683a      	ldr	r2, [r7, #0]
    3d36:	611a      	str	r2, [r3, #16]

	return _i2c_m_sync_init_impl(&i2c_dev->service, hw);
    3d38:	687b      	ldr	r3, [r7, #4]
    3d3a:	6839      	ldr	r1, [r7, #0]
    3d3c:	4618      	mov	r0, r3
    3d3e:	4b05      	ldr	r3, [pc, #20]	; (3d54 <_i2c_m_sync_init+0x44>)
    3d40:	4798      	blx	r3
    3d42:	4603      	mov	r3, r0
}
    3d44:	4618      	mov	r0, r3
    3d46:	3708      	adds	r7, #8
    3d48:	46bd      	mov	sp, r7
    3d4a:	bd80      	pop	{r7, pc}
    3d4c:	0000561c 	.word	0x0000561c
    3d50:	00001c39 	.word	0x00001c39
    3d54:	000040cd 	.word	0x000040cd

00003d58 <_i2c_m_sync_enable>:
 * \brief Enable the i2c master module
 *
 * \param[in] i2c_dev The pointer to i2c device
 */
int32_t _i2c_m_sync_enable(struct _i2c_m_sync_device *const i2c_dev)
{
    3d58:	b580      	push	{r7, lr}
    3d5a:	b082      	sub	sp, #8
    3d5c:	af00      	add	r7, sp, #0
    3d5e:	6078      	str	r0, [r7, #4]
	ASSERT(i2c_dev);
    3d60:	687b      	ldr	r3, [r7, #4]
    3d62:	2b00      	cmp	r3, #0
    3d64:	bf14      	ite	ne
    3d66:	2301      	movne	r3, #1
    3d68:	2300      	moveq	r3, #0
    3d6a:	b2db      	uxtb	r3, r3
    3d6c:	f240 5235 	movw	r2, #1333	; 0x535
    3d70:	4906      	ldr	r1, [pc, #24]	; (3d8c <_i2c_m_sync_enable+0x34>)
    3d72:	4618      	mov	r0, r3
    3d74:	4b06      	ldr	r3, [pc, #24]	; (3d90 <_i2c_m_sync_enable+0x38>)
    3d76:	4798      	blx	r3

	return _i2c_m_enable_implementation(i2c_dev->hw);
    3d78:	687b      	ldr	r3, [r7, #4]
    3d7a:	691b      	ldr	r3, [r3, #16]
    3d7c:	4618      	mov	r0, r3
    3d7e:	4b05      	ldr	r3, [pc, #20]	; (3d94 <_i2c_m_sync_enable+0x3c>)
    3d80:	4798      	blx	r3
    3d82:	4603      	mov	r3, r0
}
    3d84:	4618      	mov	r0, r3
    3d86:	3708      	adds	r7, #8
    3d88:	46bd      	mov	sp, r7
    3d8a:	bd80      	pop	{r7, pc}
    3d8c:	0000561c 	.word	0x0000561c
    3d90:	00001c39 	.word	0x00001c39
    3d94:	00004041 	.word	0x00004041

00003d98 <_sercom_i2c_sync_wait_bus>:
 * \return Bus response status.
 * \retval 0 Bus response status OK
 * \retval <0 Bus response fail
 */
inline static int32_t _sercom_i2c_sync_wait_bus(struct _i2c_m_sync_device *const i2c_dev, uint32_t *flags)
{
    3d98:	b580      	push	{r7, lr}
    3d9a:	b084      	sub	sp, #16
    3d9c:	af00      	add	r7, sp, #0
    3d9e:	6078      	str	r0, [r7, #4]
    3da0:	6039      	str	r1, [r7, #0]
	uint32_t timeout = 65535;
    3da2:	f64f 73ff 	movw	r3, #65535	; 0xffff
    3da6:	60fb      	str	r3, [r7, #12]
	void *   hw      = i2c_dev->hw;
    3da8:	687b      	ldr	r3, [r7, #4]
    3daa:	691b      	ldr	r3, [r3, #16]
    3dac:	60bb      	str	r3, [r7, #8]

	do {
		*flags = hri_sercomi2cm_read_INTFLAG_reg(hw);
    3dae:	68b8      	ldr	r0, [r7, #8]
    3db0:	4b0f      	ldr	r3, [pc, #60]	; (3df0 <_sercom_i2c_sync_wait_bus+0x58>)
    3db2:	4798      	blx	r3
    3db4:	4603      	mov	r3, r0
    3db6:	461a      	mov	r2, r3
    3db8:	683b      	ldr	r3, [r7, #0]
    3dba:	601a      	str	r2, [r3, #0]

		if (timeout-- == 0) {
    3dbc:	68fb      	ldr	r3, [r7, #12]
    3dbe:	1e5a      	subs	r2, r3, #1
    3dc0:	60fa      	str	r2, [r7, #12]
    3dc2:	2b00      	cmp	r3, #0
    3dc4:	d102      	bne.n	3dcc <_sercom_i2c_sync_wait_bus+0x34>
			return I2C_ERR_BUS;
    3dc6:	f06f 0304 	mvn.w	r3, #4
    3dca:	e00c      	b.n	3de6 <_sercom_i2c_sync_wait_bus+0x4e>
		}
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
    3dcc:	683b      	ldr	r3, [r7, #0]
    3dce:	681b      	ldr	r3, [r3, #0]
    3dd0:	f003 0301 	and.w	r3, r3, #1
    3dd4:	2b00      	cmp	r3, #0
    3dd6:	d105      	bne.n	3de4 <_sercom_i2c_sync_wait_bus+0x4c>
    3dd8:	683b      	ldr	r3, [r7, #0]
    3dda:	681b      	ldr	r3, [r3, #0]
    3ddc:	f003 0302 	and.w	r3, r3, #2
    3de0:	2b00      	cmp	r3, #0
    3de2:	d0e4      	beq.n	3dae <_sercom_i2c_sync_wait_bus+0x16>

	return I2C_OK;
    3de4:	2300      	movs	r3, #0
}
    3de6:	4618      	mov	r0, r3
    3de8:	3710      	adds	r7, #16
    3dea:	46bd      	mov	sp, r7
    3dec:	bd80      	pop	{r7, pc}
    3dee:	bf00      	nop
    3df0:	00003007 	.word	0x00003007

00003df4 <_sercom_i2c_sync_send_address>:
 * \brief Send the slave address to bus, which will start the transfer
 *
 * \param[in] i2c_dev The pointer to i2c device
 */
static int32_t _sercom_i2c_sync_send_address(struct _i2c_m_sync_device *const i2c_dev)
{
    3df4:	b590      	push	{r4, r7, lr}
    3df6:	b087      	sub	sp, #28
    3df8:	af00      	add	r7, sp, #0
    3dfa:	6078      	str	r0, [r7, #4]
	void *             hw    = i2c_dev->hw;
    3dfc:	687b      	ldr	r3, [r7, #4]
    3dfe:	691b      	ldr	r3, [r3, #16]
    3e00:	617b      	str	r3, [r7, #20]
	struct _i2c_m_msg *msg   = &i2c_dev->service.msg;
    3e02:	687b      	ldr	r3, [r7, #4]
    3e04:	613b      	str	r3, [r7, #16]
	int                sclsm = hri_sercomi2cm_get_CTRLA_SCLSM_bit(hw);
    3e06:	6978      	ldr	r0, [r7, #20]
    3e08:	4b39      	ldr	r3, [pc, #228]	; (3ef0 <_sercom_i2c_sync_send_address+0xfc>)
    3e0a:	4798      	blx	r3
    3e0c:	4603      	mov	r3, r0
    3e0e:	60fb      	str	r3, [r7, #12]
	uint32_t           flags;

	ASSERT(i2c_dev);
    3e10:	687b      	ldr	r3, [r7, #4]
    3e12:	2b00      	cmp	r3, #0
    3e14:	bf14      	ite	ne
    3e16:	2301      	movne	r3, #1
    3e18:	2300      	moveq	r3, #0
    3e1a:	b2db      	uxtb	r3, r3
    3e1c:	f240 52a5 	movw	r2, #1445	; 0x5a5
    3e20:	4934      	ldr	r1, [pc, #208]	; (3ef4 <_sercom_i2c_sync_send_address+0x100>)
    3e22:	4618      	mov	r0, r3
    3e24:	4b34      	ldr	r3, [pc, #208]	; (3ef8 <_sercom_i2c_sync_send_address+0x104>)
    3e26:	4798      	blx	r3

	if (msg->len == 1 && sclsm) {
    3e28:	693b      	ldr	r3, [r7, #16]
    3e2a:	685b      	ldr	r3, [r3, #4]
    3e2c:	2b01      	cmp	r3, #1
    3e2e:	d106      	bne.n	3e3e <_sercom_i2c_sync_send_address+0x4a>
    3e30:	68fb      	ldr	r3, [r7, #12]
    3e32:	2b00      	cmp	r3, #0
    3e34:	d003      	beq.n	3e3e <_sercom_i2c_sync_send_address+0x4a>
		hri_sercomi2cm_set_CTRLB_ACKACT_bit(hw);
    3e36:	6978      	ldr	r0, [r7, #20]
    3e38:	4b30      	ldr	r3, [pc, #192]	; (3efc <_sercom_i2c_sync_send_address+0x108>)
    3e3a:	4798      	blx	r3
    3e3c:	e002      	b.n	3e44 <_sercom_i2c_sync_send_address+0x50>
	} else {
		hri_sercomi2cm_clear_CTRLB_ACKACT_bit(hw);
    3e3e:	6978      	ldr	r0, [r7, #20]
    3e40:	4b2f      	ldr	r3, [pc, #188]	; (3f00 <_sercom_i2c_sync_send_address+0x10c>)
    3e42:	4798      	blx	r3
	}

	/* ten bit address */
	if (msg->addr & I2C_M_TEN) {
    3e44:	693b      	ldr	r3, [r7, #16]
    3e46:	881b      	ldrh	r3, [r3, #0]
    3e48:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    3e4c:	2b00      	cmp	r3, #0
    3e4e:	d022      	beq.n	3e96 <_sercom_i2c_sync_send_address+0xa2>
		if (msg->flags & I2C_M_RD) {
    3e50:	693b      	ldr	r3, [r7, #16]
    3e52:	885b      	ldrh	r3, [r3, #2]
    3e54:	b29b      	uxth	r3, r3
    3e56:	f003 0301 	and.w	r3, r3, #1
    3e5a:	2b00      	cmp	r3, #0
    3e5c:	d007      	beq.n	3e6e <_sercom_i2c_sync_send_address+0x7a>
			msg->flags |= I2C_M_TEN;
    3e5e:	693b      	ldr	r3, [r7, #16]
    3e60:	885b      	ldrh	r3, [r3, #2]
    3e62:	b29b      	uxth	r3, r3
    3e64:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    3e68:	b29a      	uxth	r2, r3
    3e6a:	693b      	ldr	r3, [r7, #16]
    3e6c:	805a      	strh	r2, [r3, #2]
		}

		hri_sercomi2cm_write_ADDR_reg(hw,
		                              ((msg->addr & TEN_ADDR_MASK) << 1) | SERCOM_I2CM_ADDR_TENBITEN
    3e6e:	693b      	ldr	r3, [r7, #16]
    3e70:	881b      	ldrh	r3, [r3, #0]
    3e72:	005b      	lsls	r3, r3, #1
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    3e74:	f240 74fe 	movw	r4, #2046	; 0x7fe
    3e78:	401c      	ands	r4, r3
    3e7a:	6978      	ldr	r0, [r7, #20]
    3e7c:	4b21      	ldr	r3, [pc, #132]	; (3f04 <_sercom_i2c_sync_send_address+0x110>)
    3e7e:	4798      	blx	r3
    3e80:	4603      	mov	r3, r0
    3e82:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    3e86:	4323      	orrs	r3, r4
		hri_sercomi2cm_write_ADDR_reg(hw,
    3e88:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    3e8c:	4619      	mov	r1, r3
    3e8e:	6978      	ldr	r0, [r7, #20]
    3e90:	4b1d      	ldr	r3, [pc, #116]	; (3f08 <_sercom_i2c_sync_send_address+0x114>)
    3e92:	4798      	blx	r3
    3e94:	e01a      	b.n	3ecc <_sercom_i2c_sync_send_address+0xd8>
	} else {
		hri_sercomi2cm_write_ADDR_reg(hw,
		                              ((msg->addr & SEVEN_ADDR_MASK) << 1) | (msg->flags & I2C_M_RD ? I2C_M_RD : 0x0)
    3e96:	693b      	ldr	r3, [r7, #16]
    3e98:	881b      	ldrh	r3, [r3, #0]
    3e9a:	005b      	lsls	r3, r3, #1
    3e9c:	b2db      	uxtb	r3, r3
    3e9e:	693a      	ldr	r2, [r7, #16]
    3ea0:	8852      	ldrh	r2, [r2, #2]
    3ea2:	b292      	uxth	r2, r2
    3ea4:	f002 0201 	and.w	r2, r2, #1
    3ea8:	2a00      	cmp	r2, #0
    3eaa:	bf14      	ite	ne
    3eac:	2201      	movne	r2, #1
    3eae:	2200      	moveq	r2, #0
    3eb0:	b2d2      	uxtb	r2, r2
    3eb2:	4313      	orrs	r3, r2
    3eb4:	461c      	mov	r4, r3
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
    3eb6:	6978      	ldr	r0, [r7, #20]
    3eb8:	4b12      	ldr	r3, [pc, #72]	; (3f04 <_sercom_i2c_sync_send_address+0x110>)
    3eba:	4798      	blx	r3
    3ebc:	4603      	mov	r3, r0
    3ebe:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
		hri_sercomi2cm_write_ADDR_reg(hw,
    3ec2:	4323      	orrs	r3, r4
    3ec4:	4619      	mov	r1, r3
    3ec6:	6978      	ldr	r0, [r7, #20]
    3ec8:	4b0f      	ldr	r3, [pc, #60]	; (3f08 <_sercom_i2c_sync_send_address+0x114>)
    3eca:	4798      	blx	r3
	}

	_sercom_i2c_sync_wait_bus(i2c_dev, &flags);
    3ecc:	f107 0308 	add.w	r3, r7, #8
    3ed0:	4619      	mov	r1, r3
    3ed2:	6878      	ldr	r0, [r7, #4]
    3ed4:	4b0d      	ldr	r3, [pc, #52]	; (3f0c <_sercom_i2c_sync_send_address+0x118>)
    3ed6:	4798      	blx	r3
	return _sercom_i2c_sync_analyse_flags(hw, flags, msg);
    3ed8:	68bb      	ldr	r3, [r7, #8]
    3eda:	693a      	ldr	r2, [r7, #16]
    3edc:	4619      	mov	r1, r3
    3ede:	6978      	ldr	r0, [r7, #20]
    3ee0:	4b0b      	ldr	r3, [pc, #44]	; (3f10 <_sercom_i2c_sync_send_address+0x11c>)
    3ee2:	4798      	blx	r3
    3ee4:	4603      	mov	r3, r0
}
    3ee6:	4618      	mov	r0, r3
    3ee8:	371c      	adds	r7, #28
    3eea:	46bd      	mov	sp, r7
    3eec:	bd90      	pop	{r4, r7, pc}
    3eee:	bf00      	nop
    3ef0:	0000314d 	.word	0x0000314d
    3ef4:	0000561c 	.word	0x0000561c
    3ef8:	00001c39 	.word	0x00001c39
    3efc:	00003351 	.word	0x00003351
    3f00:	00003379 	.word	0x00003379
    3f04:	00003535 	.word	0x00003535
    3f08:	00003511 	.word	0x00003511
    3f0c:	00003d99 	.word	0x00003d99
    3f10:	00003ae5 	.word	0x00003ae5

00003f14 <_i2c_m_sync_transfer>:
 * \return Transfer status.
 * \retval 0 Transfer success
 * \retval <0 Transfer fail or partial fail, return the error code
 */
int32_t _i2c_m_sync_transfer(struct _i2c_m_sync_device *const i2c_dev, struct _i2c_m_msg *msg)
{
    3f14:	b580      	push	{r7, lr}
    3f16:	b086      	sub	sp, #24
    3f18:	af00      	add	r7, sp, #0
    3f1a:	6078      	str	r0, [r7, #4]
    3f1c:	6039      	str	r1, [r7, #0]
	uint32_t flags;
	int      ret;
	void *   hw = i2c_dev->hw;
    3f1e:	687b      	ldr	r3, [r7, #4]
    3f20:	691b      	ldr	r3, [r3, #16]
    3f22:	613b      	str	r3, [r7, #16]

	ASSERT(i2c_dev);
    3f24:	687b      	ldr	r3, [r7, #4]
    3f26:	2b00      	cmp	r3, #0
    3f28:	bf14      	ite	ne
    3f2a:	2301      	movne	r3, #1
    3f2c:	2300      	moveq	r3, #0
    3f2e:	b2db      	uxtb	r3, r3
    3f30:	f44f 62ba 	mov.w	r2, #1488	; 0x5d0
    3f34:	493b      	ldr	r1, [pc, #236]	; (4024 <_i2c_m_sync_transfer+0x110>)
    3f36:	4618      	mov	r0, r3
    3f38:	4b3b      	ldr	r3, [pc, #236]	; (4028 <_i2c_m_sync_transfer+0x114>)
    3f3a:	4798      	blx	r3
	ASSERT(i2c_dev->hw);
    3f3c:	687b      	ldr	r3, [r7, #4]
    3f3e:	691b      	ldr	r3, [r3, #16]
    3f40:	2b00      	cmp	r3, #0
    3f42:	bf14      	ite	ne
    3f44:	2301      	movne	r3, #1
    3f46:	2300      	moveq	r3, #0
    3f48:	b2db      	uxtb	r3, r3
    3f4a:	f240 52d1 	movw	r2, #1489	; 0x5d1
    3f4e:	4935      	ldr	r1, [pc, #212]	; (4024 <_i2c_m_sync_transfer+0x110>)
    3f50:	4618      	mov	r0, r3
    3f52:	4b35      	ldr	r3, [pc, #212]	; (4028 <_i2c_m_sync_transfer+0x114>)
    3f54:	4798      	blx	r3
	ASSERT(msg);
    3f56:	683b      	ldr	r3, [r7, #0]
    3f58:	2b00      	cmp	r3, #0
    3f5a:	bf14      	ite	ne
    3f5c:	2301      	movne	r3, #1
    3f5e:	2300      	moveq	r3, #0
    3f60:	b2db      	uxtb	r3, r3
    3f62:	f240 52d2 	movw	r2, #1490	; 0x5d2
    3f66:	492f      	ldr	r1, [pc, #188]	; (4024 <_i2c_m_sync_transfer+0x110>)
    3f68:	4618      	mov	r0, r3
    3f6a:	4b2f      	ldr	r3, [pc, #188]	; (4028 <_i2c_m_sync_transfer+0x114>)
    3f6c:	4798      	blx	r3

	if (i2c_dev->service.msg.flags & I2C_M_BUSY) {
    3f6e:	687b      	ldr	r3, [r7, #4]
    3f70:	885b      	ldrh	r3, [r3, #2]
    3f72:	b29b      	uxth	r3, r3
    3f74:	f403 7380 	and.w	r3, r3, #256	; 0x100
    3f78:	2b00      	cmp	r3, #0
    3f7a:	d002      	beq.n	3f82 <_i2c_m_sync_transfer+0x6e>
		return I2C_ERR_BUSY;
    3f7c:	f06f 0305 	mvn.w	r3, #5
    3f80:	e04c      	b.n	401c <_i2c_m_sync_transfer+0x108>
	}

	msg->flags |= I2C_M_BUSY;
    3f82:	683b      	ldr	r3, [r7, #0]
    3f84:	885b      	ldrh	r3, [r3, #2]
    3f86:	b29b      	uxth	r3, r3
    3f88:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    3f8c:	b29a      	uxth	r2, r3
    3f8e:	683b      	ldr	r3, [r7, #0]
    3f90:	805a      	strh	r2, [r3, #2]
	i2c_dev->service.msg = *msg;
    3f92:	687b      	ldr	r3, [r7, #4]
    3f94:	683a      	ldr	r2, [r7, #0]
    3f96:	ca07      	ldmia	r2, {r0, r1, r2}
    3f98:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	hri_sercomi2cm_set_CTRLB_SMEN_bit(hw);
    3f9c:	6938      	ldr	r0, [r7, #16]
    3f9e:	4b23      	ldr	r3, [pc, #140]	; (402c <_i2c_m_sync_transfer+0x118>)
    3fa0:	4798      	blx	r3

	ret = _sercom_i2c_sync_send_address(i2c_dev);
    3fa2:	6878      	ldr	r0, [r7, #4]
    3fa4:	4b22      	ldr	r3, [pc, #136]	; (4030 <_i2c_m_sync_transfer+0x11c>)
    3fa6:	4798      	blx	r3
    3fa8:	6178      	str	r0, [r7, #20]

	if (ret) {
    3faa:	697b      	ldr	r3, [r7, #20]
    3fac:	2b00      	cmp	r3, #0
    3fae:	d02d      	beq.n	400c <_i2c_m_sync_transfer+0xf8>
		i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
    3fb0:	687b      	ldr	r3, [r7, #4]
    3fb2:	885b      	ldrh	r3, [r3, #2]
    3fb4:	b29b      	uxth	r3, r3
    3fb6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    3fba:	b29a      	uxth	r2, r3
    3fbc:	687b      	ldr	r3, [r7, #4]
    3fbe:	805a      	strh	r2, [r3, #2]

		return ret;
    3fc0:	697b      	ldr	r3, [r7, #20]
    3fc2:	e02b      	b.n	401c <_i2c_m_sync_transfer+0x108>
	}

	while (i2c_dev->service.msg.flags & I2C_M_BUSY) {
		ret = _sercom_i2c_sync_wait_bus(i2c_dev, &flags);
    3fc4:	f107 030c 	add.w	r3, r7, #12
    3fc8:	4619      	mov	r1, r3
    3fca:	6878      	ldr	r0, [r7, #4]
    3fcc:	4b19      	ldr	r3, [pc, #100]	; (4034 <_i2c_m_sync_transfer+0x120>)
    3fce:	4798      	blx	r3
    3fd0:	6178      	str	r0, [r7, #20]

		if (ret) {
    3fd2:	697b      	ldr	r3, [r7, #20]
    3fd4:	2b00      	cmp	r3, #0
    3fd6:	d012      	beq.n	3ffe <_i2c_m_sync_transfer+0xea>
			if (msg->flags & I2C_M_STOP) {
    3fd8:	683b      	ldr	r3, [r7, #0]
    3fda:	885b      	ldrh	r3, [r3, #2]
    3fdc:	b29b      	uxth	r3, r3
    3fde:	b21b      	sxth	r3, r3
    3fe0:	2b00      	cmp	r3, #0
    3fe2:	da02      	bge.n	3fea <_i2c_m_sync_transfer+0xd6>
				_sercom_i2c_send_stop(hw);
    3fe4:	6938      	ldr	r0, [r7, #16]
    3fe6:	4b14      	ldr	r3, [pc, #80]	; (4038 <_i2c_m_sync_transfer+0x124>)
    3fe8:	4798      	blx	r3
			}

			i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
    3fea:	687b      	ldr	r3, [r7, #4]
    3fec:	885b      	ldrh	r3, [r3, #2]
    3fee:	b29b      	uxth	r3, r3
    3ff0:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    3ff4:	b29a      	uxth	r2, r3
    3ff6:	687b      	ldr	r3, [r7, #4]
    3ff8:	805a      	strh	r2, [r3, #2]

			return ret;
    3ffa:	697b      	ldr	r3, [r7, #20]
    3ffc:	e00e      	b.n	401c <_i2c_m_sync_transfer+0x108>
		}

		ret = _sercom_i2c_sync_analyse_flags(hw, flags, &i2c_dev->service.msg);
    3ffe:	68fb      	ldr	r3, [r7, #12]
    4000:	687a      	ldr	r2, [r7, #4]
    4002:	4619      	mov	r1, r3
    4004:	6938      	ldr	r0, [r7, #16]
    4006:	4b0d      	ldr	r3, [pc, #52]	; (403c <_i2c_m_sync_transfer+0x128>)
    4008:	4798      	blx	r3
    400a:	6178      	str	r0, [r7, #20]
	while (i2c_dev->service.msg.flags & I2C_M_BUSY) {
    400c:	687b      	ldr	r3, [r7, #4]
    400e:	885b      	ldrh	r3, [r3, #2]
    4010:	b29b      	uxth	r3, r3
    4012:	f403 7380 	and.w	r3, r3, #256	; 0x100
    4016:	2b00      	cmp	r3, #0
    4018:	d1d4      	bne.n	3fc4 <_i2c_m_sync_transfer+0xb0>
	}

	return ret;
    401a:	697b      	ldr	r3, [r7, #20]
}
    401c:	4618      	mov	r0, r3
    401e:	3718      	adds	r7, #24
    4020:	46bd      	mov	sp, r7
    4022:	bd80      	pop	{r7, pc}
    4024:	0000561c 	.word	0x0000561c
    4028:	00001c39 	.word	0x00001c39
    402c:	00003301 	.word	0x00003301
    4030:	00003df5 	.word	0x00003df5
    4034:	00003d99 	.word	0x00003d99
    4038:	00003ac9 	.word	0x00003ac9
    403c:	00003ae5 	.word	0x00003ae5

00004040 <_i2c_m_enable_implementation>:

	return I2C_OK;
}

static inline int32_t _i2c_m_enable_implementation(void *const hw)
{
    4040:	b580      	push	{r7, lr}
    4042:	b084      	sub	sp, #16
    4044:	af00      	add	r7, sp, #0
    4046:	6078      	str	r0, [r7, #4]
	int timeout         = 65535;
    4048:	f64f 73ff 	movw	r3, #65535	; 0xffff
    404c:	60fb      	str	r3, [r7, #12]
	int timeout_attempt = 4;
    404e:	2304      	movs	r3, #4
    4050:	60bb      	str	r3, [r7, #8]

	ASSERT(hw);
    4052:	687b      	ldr	r3, [r7, #4]
    4054:	2b00      	cmp	r3, #0
    4056:	bf14      	ite	ne
    4058:	2301      	movne	r3, #1
    405a:	2300      	moveq	r3, #0
    405c:	b2db      	uxtb	r3, r3
    405e:	f240 6205 	movw	r2, #1541	; 0x605
    4062:	4915      	ldr	r1, [pc, #84]	; (40b8 <_i2c_m_enable_implementation+0x78>)
    4064:	4618      	mov	r0, r3
    4066:	4b15      	ldr	r3, [pc, #84]	; (40bc <_i2c_m_enable_implementation+0x7c>)
    4068:	4798      	blx	r3

	/* Enable interrupts */
	hri_sercomi2cm_set_CTRLA_ENABLE_bit(hw);
    406a:	6878      	ldr	r0, [r7, #4]
    406c:	4b14      	ldr	r3, [pc, #80]	; (40c0 <_i2c_m_enable_implementation+0x80>)
    406e:	4798      	blx	r3

	while (hri_sercomi2cm_read_STATUS_BUSSTATE_bf(hw) != I2C_IDLE) {
    4070:	e016      	b.n	40a0 <_i2c_m_enable_implementation+0x60>
		timeout--;
    4072:	68fb      	ldr	r3, [r7, #12]
    4074:	3b01      	subs	r3, #1
    4076:	60fb      	str	r3, [r7, #12]

		if (timeout <= 0) {
    4078:	68fb      	ldr	r3, [r7, #12]
    407a:	2b00      	cmp	r3, #0
    407c:	dc10      	bgt.n	40a0 <_i2c_m_enable_implementation+0x60>
			if (--timeout_attempt)
    407e:	68bb      	ldr	r3, [r7, #8]
    4080:	3b01      	subs	r3, #1
    4082:	60bb      	str	r3, [r7, #8]
    4084:	68bb      	ldr	r3, [r7, #8]
    4086:	2b00      	cmp	r3, #0
    4088:	d007      	beq.n	409a <_i2c_m_enable_implementation+0x5a>
				timeout = 65535;
    408a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    408e:	60fb      	str	r3, [r7, #12]
			else
				return I2C_ERR_BUSY;
			hri_sercomi2cm_clear_STATUS_reg(hw, SERCOM_I2CM_STATUS_BUSSTATE(I2C_IDLE));
    4090:	2110      	movs	r1, #16
    4092:	6878      	ldr	r0, [r7, #4]
    4094:	4b0b      	ldr	r3, [pc, #44]	; (40c4 <_i2c_m_enable_implementation+0x84>)
    4096:	4798      	blx	r3
    4098:	e002      	b.n	40a0 <_i2c_m_enable_implementation+0x60>
				return I2C_ERR_BUSY;
    409a:	f06f 0305 	mvn.w	r3, #5
    409e:	e006      	b.n	40ae <_i2c_m_enable_implementation+0x6e>
	while (hri_sercomi2cm_read_STATUS_BUSSTATE_bf(hw) != I2C_IDLE) {
    40a0:	6878      	ldr	r0, [r7, #4]
    40a2:	4b09      	ldr	r3, [pc, #36]	; (40c8 <_i2c_m_enable_implementation+0x88>)
    40a4:	4798      	blx	r3
    40a6:	4603      	mov	r3, r0
    40a8:	2b01      	cmp	r3, #1
    40aa:	d1e2      	bne.n	4072 <_i2c_m_enable_implementation+0x32>
		}
	}
	return ERR_NONE;
    40ac:	2300      	movs	r3, #0
}
    40ae:	4618      	mov	r0, r3
    40b0:	3710      	adds	r7, #16
    40b2:	46bd      	mov	sp, r7
    40b4:	bd80      	pop	{r7, pc}
    40b6:	bf00      	nop
    40b8:	0000561c 	.word	0x0000561c
    40bc:	00001c39 	.word	0x00001c39
    40c0:	000030fd 	.word	0x000030fd
    40c4:	000036cd 	.word	0x000036cd
    40c8:	0000367d 	.word	0x0000367d

000040cc <_i2c_m_sync_init_impl>:

static int32_t _i2c_m_sync_init_impl(struct _i2c_m_service *const service, void *const hw)
{
    40cc:	b580      	push	{r7, lr}
    40ce:	b084      	sub	sp, #16
    40d0:	af00      	add	r7, sp, #0
    40d2:	6078      	str	r0, [r7, #4]
    40d4:	6039      	str	r1, [r7, #0]
	uint8_t i = _get_i2cm_index(hw);
    40d6:	6838      	ldr	r0, [r7, #0]
    40d8:	4b42      	ldr	r3, [pc, #264]	; (41e4 <_i2c_m_sync_init_impl+0x118>)
    40da:	4798      	blx	r3
    40dc:	4603      	mov	r3, r0
    40de:	73fb      	strb	r3, [r7, #15]

	if (!hri_sercomi2cm_is_syncing(hw, SERCOM_I2CM_SYNCBUSY_SWRST)) {
    40e0:	2101      	movs	r1, #1
    40e2:	6838      	ldr	r0, [r7, #0]
    40e4:	4b40      	ldr	r3, [pc, #256]	; (41e8 <_i2c_m_sync_init_impl+0x11c>)
    40e6:	4798      	blx	r3
    40e8:	4603      	mov	r3, r0
    40ea:	f083 0301 	eor.w	r3, r3, #1
    40ee:	b2db      	uxtb	r3, r3
    40f0:	2b00      	cmp	r3, #0
    40f2:	d020      	beq.n	4136 <_i2c_m_sync_init_impl+0x6a>
		uint32_t mode = _i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_MODE_Msk;
    40f4:	7bfa      	ldrb	r2, [r7, #15]
    40f6:	493d      	ldr	r1, [pc, #244]	; (41ec <_i2c_m_sync_init_impl+0x120>)
    40f8:	4613      	mov	r3, r2
    40fa:	005b      	lsls	r3, r3, #1
    40fc:	4413      	add	r3, r2
    40fe:	00db      	lsls	r3, r3, #3
    4100:	440b      	add	r3, r1
    4102:	3304      	adds	r3, #4
    4104:	681b      	ldr	r3, [r3, #0]
    4106:	f003 031c 	and.w	r3, r3, #28
    410a:	60bb      	str	r3, [r7, #8]
		if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
    410c:	2102      	movs	r1, #2
    410e:	6838      	ldr	r0, [r7, #0]
    4110:	4b37      	ldr	r3, [pc, #220]	; (41f0 <_i2c_m_sync_init_impl+0x124>)
    4112:	4798      	blx	r3
    4114:	4603      	mov	r3, r0
    4116:	2b00      	cmp	r3, #0
    4118:	d006      	beq.n	4128 <_i2c_m_sync_init_impl+0x5c>
			hri_sercomi2cm_clear_CTRLA_ENABLE_bit(hw);
    411a:	6838      	ldr	r0, [r7, #0]
    411c:	4b35      	ldr	r3, [pc, #212]	; (41f4 <_i2c_m_sync_init_impl+0x128>)
    411e:	4798      	blx	r3
			hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_ENABLE);
    4120:	2102      	movs	r1, #2
    4122:	6838      	ldr	r0, [r7, #0]
    4124:	4b34      	ldr	r3, [pc, #208]	; (41f8 <_i2c_m_sync_init_impl+0x12c>)
    4126:	4798      	blx	r3
		}
		hri_sercomi2cm_write_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_SWRST | mode);
    4128:	68bb      	ldr	r3, [r7, #8]
    412a:	f043 0301 	orr.w	r3, r3, #1
    412e:	4619      	mov	r1, r3
    4130:	6838      	ldr	r0, [r7, #0]
    4132:	4b32      	ldr	r3, [pc, #200]	; (41fc <_i2c_m_sync_init_impl+0x130>)
    4134:	4798      	blx	r3
	}
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST);
    4136:	2101      	movs	r1, #1
    4138:	6838      	ldr	r0, [r7, #0]
    413a:	4b2f      	ldr	r3, [pc, #188]	; (41f8 <_i2c_m_sync_init_impl+0x12c>)
    413c:	4798      	blx	r3

	hri_sercomi2cm_write_CTRLA_reg(hw, _i2cms[i].ctrl_a);
    413e:	7bfa      	ldrb	r2, [r7, #15]
    4140:	492a      	ldr	r1, [pc, #168]	; (41ec <_i2c_m_sync_init_impl+0x120>)
    4142:	4613      	mov	r3, r2
    4144:	005b      	lsls	r3, r3, #1
    4146:	4413      	add	r3, r2
    4148:	00db      	lsls	r3, r3, #3
    414a:	440b      	add	r3, r1
    414c:	3304      	adds	r3, #4
    414e:	681b      	ldr	r3, [r3, #0]
    4150:	4619      	mov	r1, r3
    4152:	6838      	ldr	r0, [r7, #0]
    4154:	4b29      	ldr	r3, [pc, #164]	; (41fc <_i2c_m_sync_init_impl+0x130>)
    4156:	4798      	blx	r3
	hri_sercomi2cm_write_CTRLB_reg(hw, _i2cms[i].ctrl_b);
    4158:	7bfa      	ldrb	r2, [r7, #15]
    415a:	4924      	ldr	r1, [pc, #144]	; (41ec <_i2c_m_sync_init_impl+0x120>)
    415c:	4613      	mov	r3, r2
    415e:	005b      	lsls	r3, r3, #1
    4160:	4413      	add	r3, r2
    4162:	00db      	lsls	r3, r3, #3
    4164:	440b      	add	r3, r1
    4166:	3308      	adds	r3, #8
    4168:	681b      	ldr	r3, [r3, #0]
    416a:	4619      	mov	r1, r3
    416c:	6838      	ldr	r0, [r7, #0]
    416e:	4b24      	ldr	r3, [pc, #144]	; (4200 <_i2c_m_sync_init_impl+0x134>)
    4170:	4798      	blx	r3
	hri_sercomi2cm_write_BAUD_reg(hw, _i2cms[i].baud);
    4172:	7bfa      	ldrb	r2, [r7, #15]
    4174:	491d      	ldr	r1, [pc, #116]	; (41ec <_i2c_m_sync_init_impl+0x120>)
    4176:	4613      	mov	r3, r2
    4178:	005b      	lsls	r3, r3, #1
    417a:	4413      	add	r3, r2
    417c:	00db      	lsls	r3, r3, #3
    417e:	440b      	add	r3, r1
    4180:	330c      	adds	r3, #12
    4182:	681b      	ldr	r3, [r3, #0]
    4184:	4619      	mov	r1, r3
    4186:	6838      	ldr	r0, [r7, #0]
    4188:	4b1e      	ldr	r3, [pc, #120]	; (4204 <_i2c_m_sync_init_impl+0x138>)
    418a:	4798      	blx	r3

	service->mode = (_i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_SPEED_Msk) >> SERCOM_I2CM_CTRLA_SPEED_Pos;
    418c:	7bfa      	ldrb	r2, [r7, #15]
    418e:	4917      	ldr	r1, [pc, #92]	; (41ec <_i2c_m_sync_init_impl+0x120>)
    4190:	4613      	mov	r3, r2
    4192:	005b      	lsls	r3, r3, #1
    4194:	4413      	add	r3, r2
    4196:	00db      	lsls	r3, r3, #3
    4198:	440b      	add	r3, r1
    419a:	3304      	adds	r3, #4
    419c:	681b      	ldr	r3, [r3, #0]
    419e:	0e1b      	lsrs	r3, r3, #24
    41a0:	b29b      	uxth	r3, r3
    41a2:	f003 0303 	and.w	r3, r3, #3
    41a6:	b29a      	uxth	r2, r3
    41a8:	687b      	ldr	r3, [r7, #4]
    41aa:	819a      	strh	r2, [r3, #12]
	hri_sercomi2cm_write_ADDR_HS_bit(hw, service->mode < I2C_HS ? 0 : 1);
    41ac:	687b      	ldr	r3, [r7, #4]
    41ae:	899b      	ldrh	r3, [r3, #12]
    41b0:	2b01      	cmp	r3, #1
    41b2:	bf8c      	ite	hi
    41b4:	2301      	movhi	r3, #1
    41b6:	2300      	movls	r3, #0
    41b8:	b2db      	uxtb	r3, r3
    41ba:	4619      	mov	r1, r3
    41bc:	6838      	ldr	r0, [r7, #0]
    41be:	4b12      	ldr	r3, [pc, #72]	; (4208 <_i2c_m_sync_init_impl+0x13c>)
    41c0:	4798      	blx	r3

	service->trise = _i2cms[i].trise;
    41c2:	7bfa      	ldrb	r2, [r7, #15]
    41c4:	4909      	ldr	r1, [pc, #36]	; (41ec <_i2c_m_sync_init_impl+0x120>)
    41c6:	4613      	mov	r3, r2
    41c8:	005b      	lsls	r3, r3, #1
    41ca:	4413      	add	r3, r2
    41cc:	00db      	lsls	r3, r3, #3
    41ce:	440b      	add	r3, r1
    41d0:	3312      	adds	r3, #18
    41d2:	881a      	ldrh	r2, [r3, #0]
    41d4:	687b      	ldr	r3, [r7, #4]
    41d6:	81da      	strh	r2, [r3, #14]

	return ERR_NONE;
    41d8:	2300      	movs	r3, #0
}
    41da:	4618      	mov	r0, r3
    41dc:	3710      	adds	r7, #16
    41de:	46bd      	mov	sp, r7
    41e0:	bd80      	pop	{r7, pc}
    41e2:	bf00      	nop
    41e4:	00003a61 	.word	0x00003a61
    41e8:	00002f0f 	.word	0x00002f0f
    41ec:	20000018 	.word	0x20000018
    41f0:	0000317d 	.word	0x0000317d
    41f4:	00003125 	.word	0x00003125
    41f8:	00002ee9 	.word	0x00002ee9
    41fc:	000031ad 	.word	0x000031ad
    4200:	000033d1 	.word	0x000033d1
    4204:	00003459 	.word	0x00003459
    4208:	000034d1 	.word	0x000034d1

0000420c <_spi_load_regs_master>:
 *  are ignored.
 *  \param[in, out] hw Pointer to the hardware register base.
 *  \param[in] regs Pointer to register configuration values.
 */
static inline void _spi_load_regs_master(void *const hw, const struct sercomspi_regs_cfg *regs)
{
    420c:	b580      	push	{r7, lr}
    420e:	b082      	sub	sp, #8
    4210:	af00      	add	r7, sp, #0
    4212:	6078      	str	r0, [r7, #4]
    4214:	6039      	str	r1, [r7, #0]
	ASSERT(hw && regs);
    4216:	687b      	ldr	r3, [r7, #4]
    4218:	2b00      	cmp	r3, #0
    421a:	d004      	beq.n	4226 <_spi_load_regs_master+0x1a>
    421c:	683b      	ldr	r3, [r7, #0]
    421e:	2b00      	cmp	r3, #0
    4220:	d001      	beq.n	4226 <_spi_load_regs_master+0x1a>
    4222:	2301      	movs	r3, #1
    4224:	e000      	b.n	4228 <_spi_load_regs_master+0x1c>
    4226:	2300      	movs	r3, #0
    4228:	f003 0301 	and.w	r3, r3, #1
    422c:	b2db      	uxtb	r3, r3
    422e:	f640 1209 	movw	r2, #2313	; 0x909
    4232:	4915      	ldr	r1, [pc, #84]	; (4288 <_spi_load_regs_master+0x7c>)
    4234:	4618      	mov	r0, r3
    4236:	4b15      	ldr	r3, [pc, #84]	; (428c <_spi_load_regs_master+0x80>)
    4238:	4798      	blx	r3
	hri_sercomspi_write_CTRLA_reg(
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    423a:	683b      	ldr	r3, [r7, #0]
    423c:	681b      	ldr	r3, [r3, #0]
	hri_sercomspi_write_CTRLA_reg(
    423e:	f423 7381 	bic.w	r3, r3, #258	; 0x102
    4242:	f023 0301 	bic.w	r3, r3, #1
    4246:	4619      	mov	r1, r3
    4248:	6878      	ldr	r0, [r7, #4]
    424a:	4b11      	ldr	r3, [pc, #68]	; (4290 <_spi_load_regs_master+0x84>)
    424c:	4798      	blx	r3
	hri_sercomspi_write_CTRLB_reg(
	    hw,
	    (regs->ctrlb
    424e:	683b      	ldr	r3, [r7, #0]
    4250:	685b      	ldr	r3, [r3, #4]
	     & ~(SERCOM_SPI_CTRLB_MSSEN | SERCOM_SPI_CTRLB_AMODE_Msk | SERCOM_SPI_CTRLB_SSDE | SERCOM_SPI_CTRLB_PLOADEN))
	        | (SERCOM_SPI_CTRLB_RXEN));
    4252:	f423 3338 	bic.w	r3, r3, #188416	; 0x2e000
    4256:	f423 7310 	bic.w	r3, r3, #576	; 0x240
	hri_sercomspi_write_CTRLB_reg(
    425a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    425e:	4619      	mov	r1, r3
    4260:	6878      	ldr	r0, [r7, #4]
    4262:	4b0c      	ldr	r3, [pc, #48]	; (4294 <_spi_load_regs_master+0x88>)
    4264:	4798      	blx	r3
	hri_sercomspi_write_BAUD_reg(hw, regs->baud);
    4266:	683b      	ldr	r3, [r7, #0]
    4268:	7b1b      	ldrb	r3, [r3, #12]
    426a:	4619      	mov	r1, r3
    426c:	6878      	ldr	r0, [r7, #4]
    426e:	4b0a      	ldr	r3, [pc, #40]	; (4298 <_spi_load_regs_master+0x8c>)
    4270:	4798      	blx	r3
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    4272:	683b      	ldr	r3, [r7, #0]
    4274:	7b5b      	ldrb	r3, [r3, #13]
    4276:	4619      	mov	r1, r3
    4278:	6878      	ldr	r0, [r7, #4]
    427a:	4b08      	ldr	r3, [pc, #32]	; (429c <_spi_load_regs_master+0x90>)
    427c:	4798      	blx	r3
}
    427e:	bf00      	nop
    4280:	3708      	adds	r7, #8
    4282:	46bd      	mov	sp, r7
    4284:	bd80      	pop	{r7, pc}
    4286:	bf00      	nop
    4288:	0000561c 	.word	0x0000561c
    428c:	00001c39 	.word	0x00001c39
    4290:	00003261 	.word	0x00003261
    4294:	000033f5 	.word	0x000033f5
    4298:	00003475 	.word	0x00003475
    429c:	0000361d 	.word	0x0000361d

000042a0 <_spi_load_regs_slave>:
 *  are ignored.
 *  \param[in, out] hw Pointer to the hardware register base.
 *  \param[in] regs Pointer to register configuration values.
 */
static inline void _spi_load_regs_slave(void *const hw, const struct sercomspi_regs_cfg *regs)
{
    42a0:	b580      	push	{r7, lr}
    42a2:	b082      	sub	sp, #8
    42a4:	af00      	add	r7, sp, #0
    42a6:	6078      	str	r0, [r7, #4]
    42a8:	6039      	str	r1, [r7, #0]
	ASSERT(hw && regs);
    42aa:	687b      	ldr	r3, [r7, #4]
    42ac:	2b00      	cmp	r3, #0
    42ae:	d004      	beq.n	42ba <_spi_load_regs_slave+0x1a>
    42b0:	683b      	ldr	r3, [r7, #0]
    42b2:	2b00      	cmp	r3, #0
    42b4:	d001      	beq.n	42ba <_spi_load_regs_slave+0x1a>
    42b6:	2301      	movs	r3, #1
    42b8:	e000      	b.n	42bc <_spi_load_regs_slave+0x1c>
    42ba:	2300      	movs	r3, #0
    42bc:	f003 0301 	and.w	r3, r3, #1
    42c0:	b2db      	uxtb	r3, r3
    42c2:	f640 121d 	movw	r2, #2333	; 0x91d
    42c6:	491b      	ldr	r1, [pc, #108]	; (4334 <_spi_load_regs_slave+0x94>)
    42c8:	4618      	mov	r0, r3
    42ca:	4b1b      	ldr	r3, [pc, #108]	; (4338 <_spi_load_regs_slave+0x98>)
    42cc:	4798      	blx	r3
	hri_sercomspi_write_CTRLA_reg(
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    42ce:	683b      	ldr	r3, [r7, #0]
    42d0:	681b      	ldr	r3, [r3, #0]
	hri_sercomspi_write_CTRLA_reg(
    42d2:	f423 7381 	bic.w	r3, r3, #258	; 0x102
    42d6:	f023 0301 	bic.w	r3, r3, #1
    42da:	4619      	mov	r1, r3
    42dc:	6878      	ldr	r0, [r7, #4]
    42de:	4b17      	ldr	r3, [pc, #92]	; (433c <_spi_load_regs_slave+0x9c>)
    42e0:	4798      	blx	r3
	hri_sercomspi_write_CTRLB_reg(hw,
	                              (regs->ctrlb & ~(SERCOM_SPI_CTRLB_MSSEN))
    42e2:	683b      	ldr	r3, [r7, #0]
    42e4:	685b      	ldr	r3, [r3, #4]
	                                  | (SERCOM_SPI_CTRLB_RXEN | SERCOM_SPI_CTRLB_SSDE | SERCOM_SPI_CTRLB_PLOADEN));
    42e6:	f423 3308 	bic.w	r3, r3, #139264	; 0x22000
    42ea:	f423 7310 	bic.w	r3, r3, #576	; 0x240
	hri_sercomspi_write_CTRLB_reg(hw,
    42ee:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    42f2:	f443 7310 	orr.w	r3, r3, #576	; 0x240
    42f6:	4619      	mov	r1, r3
    42f8:	6878      	ldr	r0, [r7, #4]
    42fa:	4b11      	ldr	r3, [pc, #68]	; (4340 <_spi_load_regs_slave+0xa0>)
    42fc:	4798      	blx	r3
	hri_sercomspi_write_ADDR_reg(hw, regs->addr);
    42fe:	683b      	ldr	r3, [r7, #0]
    4300:	689b      	ldr	r3, [r3, #8]
    4302:	4619      	mov	r1, r3
    4304:	6878      	ldr	r0, [r7, #4]
    4306:	4b0f      	ldr	r3, [pc, #60]	; (4344 <_spi_load_regs_slave+0xa4>)
    4308:	4798      	blx	r3
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    430a:	683b      	ldr	r3, [r7, #0]
    430c:	7b5b      	ldrb	r3, [r3, #13]
    430e:	4619      	mov	r1, r3
    4310:	6878      	ldr	r0, [r7, #4]
    4312:	4b0d      	ldr	r3, [pc, #52]	; (4348 <_spi_load_regs_slave+0xa8>)
    4314:	4798      	blx	r3
	while (hri_sercomspi_is_syncing(hw, 0xFFFFFFFF))
    4316:	bf00      	nop
    4318:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    431c:	6878      	ldr	r0, [r7, #4]
    431e:	4b0b      	ldr	r3, [pc, #44]	; (434c <_spi_load_regs_slave+0xac>)
    4320:	4798      	blx	r3
    4322:	4603      	mov	r3, r0
    4324:	2b00      	cmp	r3, #0
    4326:	d1f7      	bne.n	4318 <_spi_load_regs_slave+0x78>
		;
}
    4328:	bf00      	nop
    432a:	bf00      	nop
    432c:	3708      	adds	r7, #8
    432e:	46bd      	mov	sp, r7
    4330:	bd80      	pop	{r7, pc}
    4332:	bf00      	nop
    4334:	0000561c 	.word	0x0000561c
    4338:	00001c39 	.word	0x00001c39
    433c:	00003261 	.word	0x00003261
    4340:	000033f5 	.word	0x000033f5
    4344:	00003555 	.word	0x00003555
    4348:	0000361d 	.word	0x0000361d
    434c:	00002f5d 	.word	0x00002f5d

00004350 <_spi_get_regs>:
/** \brief Return the pointer to register settings of specific SERCOM
 *  \param[in] hw_addr The hardware register base address.
 *  \return Pointer to register settings of specific SERCOM.
 */
static inline const struct sercomspi_regs_cfg *_spi_get_regs(const uint32_t hw_addr)
{
    4350:	b580      	push	{r7, lr}
    4352:	b084      	sub	sp, #16
    4354:	af00      	add	r7, sp, #0
    4356:	6078      	str	r0, [r7, #4]
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
    4358:	687b      	ldr	r3, [r7, #4]
    435a:	4618      	mov	r0, r3
    435c:	4b0e      	ldr	r3, [pc, #56]	; (4398 <_spi_get_regs+0x48>)
    435e:	4798      	blx	r3
    4360:	4603      	mov	r3, r0
    4362:	73bb      	strb	r3, [r7, #14]
	uint8_t i;

	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
    4364:	2300      	movs	r3, #0
    4366:	73fb      	strb	r3, [r7, #15]
    4368:	e00d      	b.n	4386 <_spi_get_regs+0x36>
		if (sercomspi_regs[i].n == n) {
    436a:	2202      	movs	r2, #2
    436c:	7bbb      	ldrb	r3, [r7, #14]
    436e:	4293      	cmp	r3, r2
    4370:	d106      	bne.n	4380 <_spi_get_regs+0x30>
			return &sercomspi_regs[i];
    4372:	7bfa      	ldrb	r2, [r7, #15]
    4374:	4613      	mov	r3, r2
    4376:	011b      	lsls	r3, r3, #4
    4378:	4413      	add	r3, r2
    437a:	4a08      	ldr	r2, [pc, #32]	; (439c <_spi_get_regs+0x4c>)
    437c:	4413      	add	r3, r2
    437e:	e006      	b.n	438e <_spi_get_regs+0x3e>
	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
    4380:	7bfb      	ldrb	r3, [r7, #15]
    4382:	3301      	adds	r3, #1
    4384:	73fb      	strb	r3, [r7, #15]
    4386:	7bfb      	ldrb	r3, [r7, #15]
    4388:	2b00      	cmp	r3, #0
    438a:	d0ee      	beq.n	436a <_spi_get_regs+0x1a>
		}
	}

	return NULL;
    438c:	2300      	movs	r3, #0
}
    438e:	4618      	mov	r0, r3
    4390:	3710      	adds	r7, #16
    4392:	46bd      	mov	sp, r7
    4394:	bd80      	pop	{r7, pc}
    4396:	bf00      	nop
    4398:	000037e5 	.word	0x000037e5
    439c:	00005658 	.word	0x00005658

000043a0 <_spi_m_sync_init>:

int32_t _spi_m_sync_init(struct _spi_m_sync_dev *dev, void *const hw)
{
    43a0:	b580      	push	{r7, lr}
    43a2:	b084      	sub	sp, #16
    43a4:	af00      	add	r7, sp, #0
    43a6:	6078      	str	r0, [r7, #4]
    43a8:	6039      	str	r1, [r7, #0]
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
    43aa:	683b      	ldr	r3, [r7, #0]
    43ac:	4618      	mov	r0, r3
    43ae:	4b35      	ldr	r3, [pc, #212]	; (4484 <_spi_m_sync_init+0xe4>)
    43b0:	4798      	blx	r3
    43b2:	60f8      	str	r0, [r7, #12]

	ASSERT(dev && hw);
    43b4:	687b      	ldr	r3, [r7, #4]
    43b6:	2b00      	cmp	r3, #0
    43b8:	d004      	beq.n	43c4 <_spi_m_sync_init+0x24>
    43ba:	683b      	ldr	r3, [r7, #0]
    43bc:	2b00      	cmp	r3, #0
    43be:	d001      	beq.n	43c4 <_spi_m_sync_init+0x24>
    43c0:	2301      	movs	r3, #1
    43c2:	e000      	b.n	43c6 <_spi_m_sync_init+0x26>
    43c4:	2300      	movs	r3, #0
    43c6:	f003 0301 	and.w	r3, r3, #1
    43ca:	b2db      	uxtb	r3, r3
    43cc:	f640 123f 	movw	r2, #2367	; 0x93f
    43d0:	492d      	ldr	r1, [pc, #180]	; (4488 <_spi_m_sync_init+0xe8>)
    43d2:	4618      	mov	r0, r3
    43d4:	4b2d      	ldr	r3, [pc, #180]	; (448c <_spi_m_sync_init+0xec>)
    43d6:	4798      	blx	r3

	if (regs == NULL) {
    43d8:	68fb      	ldr	r3, [r7, #12]
    43da:	2b00      	cmp	r3, #0
    43dc:	d102      	bne.n	43e4 <_spi_m_sync_init+0x44>
		return ERR_INVALID_ARG;
    43de:	f06f 030c 	mvn.w	r3, #12
    43e2:	e04a      	b.n	447a <_spi_m_sync_init+0xda>
	}

	if (!hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
    43e4:	2101      	movs	r1, #1
    43e6:	6838      	ldr	r0, [r7, #0]
    43e8:	4b29      	ldr	r3, [pc, #164]	; (4490 <_spi_m_sync_init+0xf0>)
    43ea:	4798      	blx	r3
    43ec:	4603      	mov	r3, r0
    43ee:	f083 0301 	eor.w	r3, r3, #1
    43f2:	b2db      	uxtb	r3, r3
    43f4:	2b00      	cmp	r3, #0
    43f6:	d019      	beq.n	442c <_spi_m_sync_init+0x8c>
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
    43f8:	68fb      	ldr	r3, [r7, #12]
    43fa:	681b      	ldr	r3, [r3, #0]
    43fc:	f003 031c 	and.w	r3, r3, #28
    4400:	60bb      	str	r3, [r7, #8]
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
    4402:	2102      	movs	r1, #2
    4404:	6838      	ldr	r0, [r7, #0]
    4406:	4b23      	ldr	r3, [pc, #140]	; (4494 <_spi_m_sync_init+0xf4>)
    4408:	4798      	blx	r3
    440a:	4603      	mov	r3, r0
    440c:	2b00      	cmp	r3, #0
    440e:	d006      	beq.n	441e <_spi_m_sync_init+0x7e>
			hri_sercomspi_clear_CTRLA_ENABLE_bit(hw);
    4410:	6838      	ldr	r0, [r7, #0]
    4412:	4b21      	ldr	r3, [pc, #132]	; (4498 <_spi_m_sync_init+0xf8>)
    4414:	4798      	blx	r3
			hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_ENABLE);
    4416:	2102      	movs	r1, #2
    4418:	6838      	ldr	r0, [r7, #0]
    441a:	4b20      	ldr	r3, [pc, #128]	; (449c <_spi_m_sync_init+0xfc>)
    441c:	4798      	blx	r3
		}
		hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST | mode);
    441e:	68bb      	ldr	r3, [r7, #8]
    4420:	f043 0301 	orr.w	r3, r3, #1
    4424:	4619      	mov	r1, r3
    4426:	6838      	ldr	r0, [r7, #0]
    4428:	4b1d      	ldr	r3, [pc, #116]	; (44a0 <_spi_m_sync_init+0x100>)
    442a:	4798      	blx	r3
	}
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);
    442c:	2101      	movs	r1, #1
    442e:	6838      	ldr	r0, [r7, #0]
    4430:	4b1a      	ldr	r3, [pc, #104]	; (449c <_spi_m_sync_init+0xfc>)
    4432:	4798      	blx	r3

	dev->prvt = hw;
    4434:	687b      	ldr	r3, [r7, #4]
    4436:	683a      	ldr	r2, [r7, #0]
    4438:	601a      	str	r2, [r3, #0]

	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
    443a:	68fb      	ldr	r3, [r7, #12]
    443c:	681b      	ldr	r3, [r3, #0]
    443e:	f003 031c 	and.w	r3, r3, #28
    4442:	2b08      	cmp	r3, #8
    4444:	d104      	bne.n	4450 <_spi_m_sync_init+0xb0>
		_spi_load_regs_slave(hw, regs);
    4446:	68f9      	ldr	r1, [r7, #12]
    4448:	6838      	ldr	r0, [r7, #0]
    444a:	4b16      	ldr	r3, [pc, #88]	; (44a4 <_spi_m_sync_init+0x104>)
    444c:	4798      	blx	r3
    444e:	e003      	b.n	4458 <_spi_m_sync_init+0xb8>
	} else {
		_spi_load_regs_master(hw, regs);
    4450:	68f9      	ldr	r1, [r7, #12]
    4452:	6838      	ldr	r0, [r7, #0]
    4454:	4b14      	ldr	r3, [pc, #80]	; (44a8 <_spi_m_sync_init+0x108>)
    4456:	4798      	blx	r3
	}

	/* Load character size from default hardware configuration */
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
    4458:	68fb      	ldr	r3, [r7, #12]
    445a:	685b      	ldr	r3, [r3, #4]
    445c:	f003 0307 	and.w	r3, r3, #7
    4460:	2b00      	cmp	r3, #0
    4462:	d101      	bne.n	4468 <_spi_m_sync_init+0xc8>
    4464:	2201      	movs	r2, #1
    4466:	e000      	b.n	446a <_spi_m_sync_init+0xca>
    4468:	2202      	movs	r2, #2
    446a:	687b      	ldr	r3, [r7, #4]
    446c:	711a      	strb	r2, [r3, #4]

	dev->dummy_byte = regs->dummy_byte;
    446e:	68fb      	ldr	r3, [r7, #12]
    4470:	89db      	ldrh	r3, [r3, #14]
    4472:	b29a      	uxth	r2, r3
    4474:	687b      	ldr	r3, [r7, #4]
    4476:	80da      	strh	r2, [r3, #6]

	return ERR_NONE;
    4478:	2300      	movs	r3, #0
}
    447a:	4618      	mov	r0, r3
    447c:	3710      	adds	r7, #16
    447e:	46bd      	mov	sp, r7
    4480:	bd80      	pop	{r7, pc}
    4482:	bf00      	nop
    4484:	00004351 	.word	0x00004351
    4488:	0000561c 	.word	0x0000561c
    448c:	00001c39 	.word	0x00001c39
    4490:	00002f5d 	.word	0x00002f5d
    4494:	00003231 	.word	0x00003231
    4498:	00003209 	.word	0x00003209
    449c:	00002f37 	.word	0x00002f37
    44a0:	00003261 	.word	0x00003261
    44a4:	000042a1 	.word	0x000042a1
    44a8:	0000420d 	.word	0x0000420d

000044ac <_spi_wait_bus_idle>:
	return _spi_set_data_order(dev->prvt, dord);
}

/** Wait until SPI bus idle. */
static inline void _spi_wait_bus_idle(void *const hw)
{
    44ac:	b580      	push	{r7, lr}
    44ae:	b082      	sub	sp, #8
    44b0:	af00      	add	r7, sp, #0
    44b2:	6078      	str	r0, [r7, #4]
	while (!(hri_sercomspi_get_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_TXC | SERCOM_SPI_INTFLAG_DRE))) {
    44b4:	bf00      	nop
    44b6:	2103      	movs	r1, #3
    44b8:	6878      	ldr	r0, [r7, #4]
    44ba:	4b06      	ldr	r3, [pc, #24]	; (44d4 <_spi_wait_bus_idle+0x28>)
    44bc:	4798      	blx	r3
    44be:	4603      	mov	r3, r0
    44c0:	2b00      	cmp	r3, #0
    44c2:	d0f8      	beq.n	44b6 <_spi_wait_bus_idle+0xa>
		;
	}
	hri_sercomspi_clear_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_TXC | SERCOM_SPI_INTFLAG_DRE);
    44c4:	2103      	movs	r1, #3
    44c6:	6878      	ldr	r0, [r7, #4]
    44c8:	4b03      	ldr	r3, [pc, #12]	; (44d8 <_spi_wait_bus_idle+0x2c>)
    44ca:	4798      	blx	r3
}
    44cc:	bf00      	nop
    44ce:	3708      	adds	r7, #8
    44d0:	46bd      	mov	sp, r7
    44d2:	bd80      	pop	{r7, pc}
    44d4:	00003021 	.word	0x00003021
    44d8:	00003063 	.word	0x00003063

000044dc <_spi_rx_check_and_receive>:
	uint8_t char_size;
};

/** Check interrupt flag of RXC and update transaction runtime information. */
static inline bool _spi_rx_check_and_receive(void *const hw, const uint32_t iflag, struct _spi_trans_ctrl *ctrl)
{
    44dc:	b580      	push	{r7, lr}
    44de:	b086      	sub	sp, #24
    44e0:	af00      	add	r7, sp, #0
    44e2:	60f8      	str	r0, [r7, #12]
    44e4:	60b9      	str	r1, [r7, #8]
    44e6:	607a      	str	r2, [r7, #4]
	uint32_t data;

	if (!(iflag & SERCOM_SPI_INTFLAG_RXC)) {
    44e8:	68bb      	ldr	r3, [r7, #8]
    44ea:	f003 0304 	and.w	r3, r3, #4
    44ee:	2b00      	cmp	r3, #0
    44f0:	d101      	bne.n	44f6 <_spi_rx_check_and_receive+0x1a>
		return false;
    44f2:	2300      	movs	r3, #0
    44f4:	e022      	b.n	453c <_spi_rx_check_and_receive+0x60>
	}

	data = hri_sercomspi_read_DATA_reg(hw);
    44f6:	68f8      	ldr	r0, [r7, #12]
    44f8:	4b12      	ldr	r3, [pc, #72]	; (4544 <_spi_rx_check_and_receive+0x68>)
    44fa:	4798      	blx	r3
    44fc:	6178      	str	r0, [r7, #20]

	if (ctrl->rxbuf) {
    44fe:	687b      	ldr	r3, [r7, #4]
    4500:	685b      	ldr	r3, [r3, #4]
    4502:	2b00      	cmp	r3, #0
    4504:	d014      	beq.n	4530 <_spi_rx_check_and_receive+0x54>
		*ctrl->rxbuf++ = (uint8_t)data;
    4506:	687b      	ldr	r3, [r7, #4]
    4508:	685b      	ldr	r3, [r3, #4]
    450a:	1c59      	adds	r1, r3, #1
    450c:	687a      	ldr	r2, [r7, #4]
    450e:	6051      	str	r1, [r2, #4]
    4510:	697a      	ldr	r2, [r7, #20]
    4512:	b2d2      	uxtb	r2, r2
    4514:	701a      	strb	r2, [r3, #0]

		if (ctrl->char_size > 1) {
    4516:	687b      	ldr	r3, [r7, #4]
    4518:	7c1b      	ldrb	r3, [r3, #16]
    451a:	2b01      	cmp	r3, #1
    451c:	d908      	bls.n	4530 <_spi_rx_check_and_receive+0x54>
			*ctrl->rxbuf++ = (uint8_t)(data >> 8);
    451e:	697b      	ldr	r3, [r7, #20]
    4520:	0a18      	lsrs	r0, r3, #8
    4522:	687b      	ldr	r3, [r7, #4]
    4524:	685b      	ldr	r3, [r3, #4]
    4526:	1c59      	adds	r1, r3, #1
    4528:	687a      	ldr	r2, [r7, #4]
    452a:	6051      	str	r1, [r2, #4]
    452c:	b2c2      	uxtb	r2, r0
    452e:	701a      	strb	r2, [r3, #0]
		}
	}

	ctrl->rxcnt++;
    4530:	687b      	ldr	r3, [r7, #4]
    4532:	68db      	ldr	r3, [r3, #12]
    4534:	1c5a      	adds	r2, r3, #1
    4536:	687b      	ldr	r3, [r7, #4]
    4538:	60da      	str	r2, [r3, #12]

	return true;
    453a:	2301      	movs	r3, #1
}
    453c:	4618      	mov	r0, r3
    453e:	3718      	adds	r7, #24
    4540:	46bd      	mov	sp, r7
    4542:	bd80      	pop	{r7, pc}
    4544:	000035d1 	.word	0x000035d1

00004548 <_spi_tx_check_and_send>:

/** Check interrupt flag of DRE and update transaction runtime information. */
static inline void _spi_tx_check_and_send(void *const hw, const uint32_t iflag, struct _spi_trans_ctrl *ctrl,
                                          uint16_t dummy)
{
    4548:	b580      	push	{r7, lr}
    454a:	b086      	sub	sp, #24
    454c:	af00      	add	r7, sp, #0
    454e:	60f8      	str	r0, [r7, #12]
    4550:	60b9      	str	r1, [r7, #8]
    4552:	607a      	str	r2, [r7, #4]
    4554:	807b      	strh	r3, [r7, #2]
	uint32_t data;

	if (!(SERCOM_SPI_INTFLAG_DRE & iflag)) {
    4556:	68bb      	ldr	r3, [r7, #8]
    4558:	f003 0301 	and.w	r3, r3, #1
    455c:	2b00      	cmp	r3, #0
    455e:	d028      	beq.n	45b2 <_spi_tx_check_and_send+0x6a>
		return;
	}

	if (ctrl->txbuf) {
    4560:	687b      	ldr	r3, [r7, #4]
    4562:	681b      	ldr	r3, [r3, #0]
    4564:	2b00      	cmp	r3, #0
    4566:	d018      	beq.n	459a <_spi_tx_check_and_send+0x52>
		data = *ctrl->txbuf++;
    4568:	687b      	ldr	r3, [r7, #4]
    456a:	681b      	ldr	r3, [r3, #0]
    456c:	1c59      	adds	r1, r3, #1
    456e:	687a      	ldr	r2, [r7, #4]
    4570:	6011      	str	r1, [r2, #0]
    4572:	781b      	ldrb	r3, [r3, #0]
    4574:	617b      	str	r3, [r7, #20]

		if (ctrl->char_size > 1) {
    4576:	687b      	ldr	r3, [r7, #4]
    4578:	7c1b      	ldrb	r3, [r3, #16]
    457a:	2b01      	cmp	r3, #1
    457c:	d90f      	bls.n	459e <_spi_tx_check_and_send+0x56>
			data |= (*ctrl->txbuf) << 8;
    457e:	687b      	ldr	r3, [r7, #4]
    4580:	681b      	ldr	r3, [r3, #0]
    4582:	781b      	ldrb	r3, [r3, #0]
    4584:	021b      	lsls	r3, r3, #8
    4586:	461a      	mov	r2, r3
    4588:	697b      	ldr	r3, [r7, #20]
    458a:	4313      	orrs	r3, r2
    458c:	617b      	str	r3, [r7, #20]
			ctrl->txbuf++;
    458e:	687b      	ldr	r3, [r7, #4]
    4590:	681b      	ldr	r3, [r3, #0]
    4592:	1c5a      	adds	r2, r3, #1
    4594:	687b      	ldr	r3, [r7, #4]
    4596:	601a      	str	r2, [r3, #0]
    4598:	e001      	b.n	459e <_spi_tx_check_and_send+0x56>
		}
	} else {
		data = dummy;
    459a:	887b      	ldrh	r3, [r7, #2]
    459c:	617b      	str	r3, [r7, #20]
	}

	ctrl->txcnt++;
    459e:	687b      	ldr	r3, [r7, #4]
    45a0:	689b      	ldr	r3, [r3, #8]
    45a2:	1c5a      	adds	r2, r3, #1
    45a4:	687b      	ldr	r3, [r7, #4]
    45a6:	609a      	str	r2, [r3, #8]
	hri_sercomspi_write_DATA_reg(hw, data);
    45a8:	6979      	ldr	r1, [r7, #20]
    45aa:	68f8      	ldr	r0, [r7, #12]
    45ac:	4b03      	ldr	r3, [pc, #12]	; (45bc <_spi_tx_check_and_send+0x74>)
    45ae:	4798      	blx	r3
    45b0:	e000      	b.n	45b4 <_spi_tx_check_and_send+0x6c>
		return;
    45b2:	bf00      	nop
}
    45b4:	3718      	adds	r7, #24
    45b6:	46bd      	mov	sp, r7
    45b8:	bd80      	pop	{r7, pc}
    45ba:	bf00      	nop
    45bc:	000035b5 	.word	0x000035b5

000045c0 <_spi_err_check>:

/** Check interrupt flag of ERROR and update transaction runtime information. */
static inline int32_t _spi_err_check(const uint32_t iflag, void *const hw)
{
    45c0:	b580      	push	{r7, lr}
    45c2:	b082      	sub	sp, #8
    45c4:	af00      	add	r7, sp, #0
    45c6:	6078      	str	r0, [r7, #4]
    45c8:	6039      	str	r1, [r7, #0]
	if (SERCOM_SPI_INTFLAG_ERROR & iflag) {
    45ca:	687b      	ldr	r3, [r7, #4]
    45cc:	f003 0380 	and.w	r3, r3, #128	; 0x80
    45d0:	2b00      	cmp	r3, #0
    45d2:	d00b      	beq.n	45ec <_spi_err_check+0x2c>
		hri_sercomspi_clear_STATUS_reg(hw, ~0);
    45d4:	f64f 71ff 	movw	r1, #65535	; 0xffff
    45d8:	6838      	ldr	r0, [r7, #0]
    45da:	4b07      	ldr	r3, [pc, #28]	; (45f8 <_spi_err_check+0x38>)
    45dc:	4798      	blx	r3
		hri_sercomspi_clear_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_ERROR);
    45de:	2180      	movs	r1, #128	; 0x80
    45e0:	6838      	ldr	r0, [r7, #0]
    45e2:	4b06      	ldr	r3, [pc, #24]	; (45fc <_spi_err_check+0x3c>)
    45e4:	4798      	blx	r3
		return ERR_OVERFLOW;
    45e6:	f06f 0312 	mvn.w	r3, #18
    45ea:	e000      	b.n	45ee <_spi_err_check+0x2e>
	}

	return ERR_NONE;
    45ec:	2300      	movs	r3, #0
}
    45ee:	4618      	mov	r0, r3
    45f0:	3708      	adds	r7, #8
    45f2:	46bd      	mov	sp, r7
    45f4:	bd80      	pop	{r7, pc}
    45f6:	bf00      	nop
    45f8:	0000365d 	.word	0x0000365d
    45fc:	00003063 	.word	0x00003063

00004600 <_spi_m_sync_trans>:

int32_t _spi_m_sync_trans(struct _spi_m_sync_dev *dev, const struct spi_msg *msg)
{
    4600:	b590      	push	{r4, r7, lr}
    4602:	b08b      	sub	sp, #44	; 0x2c
    4604:	af00      	add	r7, sp, #0
    4606:	6078      	str	r0, [r7, #4]
    4608:	6039      	str	r1, [r7, #0]
	void *                 hw   = dev->prvt;
    460a:	687b      	ldr	r3, [r7, #4]
    460c:	681b      	ldr	r3, [r3, #0]
    460e:	623b      	str	r3, [r7, #32]
	int32_t                rc   = 0;
    4610:	2300      	movs	r3, #0
    4612:	627b      	str	r3, [r7, #36]	; 0x24
	struct _spi_trans_ctrl ctrl = {msg->txbuf, msg->rxbuf, 0, 0, dev->char_size};
    4614:	683b      	ldr	r3, [r7, #0]
    4616:	681b      	ldr	r3, [r3, #0]
    4618:	60bb      	str	r3, [r7, #8]
    461a:	683b      	ldr	r3, [r7, #0]
    461c:	685b      	ldr	r3, [r3, #4]
    461e:	60fb      	str	r3, [r7, #12]
    4620:	2300      	movs	r3, #0
    4622:	613b      	str	r3, [r7, #16]
    4624:	2300      	movs	r3, #0
    4626:	617b      	str	r3, [r7, #20]
    4628:	687b      	ldr	r3, [r7, #4]
    462a:	791b      	ldrb	r3, [r3, #4]
    462c:	763b      	strb	r3, [r7, #24]

	ASSERT(dev && hw);
    462e:	687b      	ldr	r3, [r7, #4]
    4630:	2b00      	cmp	r3, #0
    4632:	d004      	beq.n	463e <_spi_m_sync_trans+0x3e>
    4634:	6a3b      	ldr	r3, [r7, #32]
    4636:	2b00      	cmp	r3, #0
    4638:	d001      	beq.n	463e <_spi_m_sync_trans+0x3e>
    463a:	2301      	movs	r3, #1
    463c:	e000      	b.n	4640 <_spi_m_sync_trans+0x40>
    463e:	2300      	movs	r3, #0
    4640:	f003 0301 	and.w	r3, r3, #1
    4644:	b2db      	uxtb	r3, r3
    4646:	f640 22a3 	movw	r2, #2723	; 0xaa3
    464a:	492b      	ldr	r1, [pc, #172]	; (46f8 <_spi_m_sync_trans+0xf8>)
    464c:	4618      	mov	r0, r3
    464e:	4b2b      	ldr	r3, [pc, #172]	; (46fc <_spi_m_sync_trans+0xfc>)
    4650:	4798      	blx	r3

	/* If settings are not applied (pending), we can not go on */
	if (hri_sercomspi_is_syncing(
    4652:	2107      	movs	r1, #7
    4654:	6a38      	ldr	r0, [r7, #32]
    4656:	4b2a      	ldr	r3, [pc, #168]	; (4700 <_spi_m_sync_trans+0x100>)
    4658:	4798      	blx	r3
    465a:	4603      	mov	r3, r0
    465c:	2b00      	cmp	r3, #0
    465e:	d002      	beq.n	4666 <_spi_m_sync_trans+0x66>
	        hw, (SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE | SERCOM_SPI_SYNCBUSY_CTRLB))) {
		return ERR_BUSY;
    4660:	f06f 0303 	mvn.w	r3, #3
    4664:	e043      	b.n	46ee <_spi_m_sync_trans+0xee>
	}

	/* SPI must be enabled to start synchronous transfer */
	if (!hri_sercomspi_get_CTRLA_ENABLE_bit(hw)) {
    4666:	6a38      	ldr	r0, [r7, #32]
    4668:	4b26      	ldr	r3, [pc, #152]	; (4704 <_spi_m_sync_trans+0x104>)
    466a:	4798      	blx	r3
    466c:	4603      	mov	r3, r0
    466e:	f083 0301 	eor.w	r3, r3, #1
    4672:	b2db      	uxtb	r3, r3
    4674:	2b00      	cmp	r3, #0
    4676:	d002      	beq.n	467e <_spi_m_sync_trans+0x7e>
		return ERR_NOT_INITIALIZED;
    4678:	f06f 0313 	mvn.w	r3, #19
    467c:	e037      	b.n	46ee <_spi_m_sync_trans+0xee>
	}

	for (;;) {
		uint32_t iflag = hri_sercomspi_read_INTFLAG_reg(hw);
    467e:	6a38      	ldr	r0, [r7, #32]
    4680:	4b21      	ldr	r3, [pc, #132]	; (4708 <_spi_m_sync_trans+0x108>)
    4682:	4798      	blx	r3
    4684:	4603      	mov	r3, r0
    4686:	61fb      	str	r3, [r7, #28]

		if (!_spi_rx_check_and_receive(hw, iflag, &ctrl)) {
    4688:	f107 0308 	add.w	r3, r7, #8
    468c:	461a      	mov	r2, r3
    468e:	69f9      	ldr	r1, [r7, #28]
    4690:	6a38      	ldr	r0, [r7, #32]
    4692:	4b1e      	ldr	r3, [pc, #120]	; (470c <_spi_m_sync_trans+0x10c>)
    4694:	4798      	blx	r3
    4696:	4603      	mov	r3, r0
    4698:	f083 0301 	eor.w	r3, r3, #1
    469c:	b2db      	uxtb	r3, r3
    469e:	2b00      	cmp	r3, #0
    46a0:	d00b      	beq.n	46ba <_spi_m_sync_trans+0xba>
			/* In master mode, do not start next byte before previous byte received
			 * to make better output waveform */
			if (ctrl.rxcnt >= ctrl.txcnt) {
    46a2:	697a      	ldr	r2, [r7, #20]
    46a4:	693b      	ldr	r3, [r7, #16]
    46a6:	429a      	cmp	r2, r3
    46a8:	d307      	bcc.n	46ba <_spi_m_sync_trans+0xba>
				_spi_tx_check_and_send(hw, iflag, &ctrl, dev->dummy_byte);
    46aa:	687b      	ldr	r3, [r7, #4]
    46ac:	88db      	ldrh	r3, [r3, #6]
    46ae:	f107 0208 	add.w	r2, r7, #8
    46b2:	69f9      	ldr	r1, [r7, #28]
    46b4:	6a38      	ldr	r0, [r7, #32]
    46b6:	4c16      	ldr	r4, [pc, #88]	; (4710 <_spi_m_sync_trans+0x110>)
    46b8:	47a0      	blx	r4
			}
		}

		rc = _spi_err_check(iflag, hw);
    46ba:	6a39      	ldr	r1, [r7, #32]
    46bc:	69f8      	ldr	r0, [r7, #28]
    46be:	4b15      	ldr	r3, [pc, #84]	; (4714 <_spi_m_sync_trans+0x114>)
    46c0:	4798      	blx	r3
    46c2:	6278      	str	r0, [r7, #36]	; 0x24

		if (rc < 0) {
    46c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    46c6:	2b00      	cmp	r3, #0
    46c8:	db0c      	blt.n	46e4 <_spi_m_sync_trans+0xe4>
			break;
		}
		if (ctrl.txcnt >= msg->size && ctrl.rxcnt >= msg->size) {
    46ca:	693a      	ldr	r2, [r7, #16]
    46cc:	683b      	ldr	r3, [r7, #0]
    46ce:	689b      	ldr	r3, [r3, #8]
    46d0:	429a      	cmp	r2, r3
    46d2:	d3d4      	bcc.n	467e <_spi_m_sync_trans+0x7e>
    46d4:	697a      	ldr	r2, [r7, #20]
    46d6:	683b      	ldr	r3, [r7, #0]
    46d8:	689b      	ldr	r3, [r3, #8]
    46da:	429a      	cmp	r2, r3
    46dc:	d3cf      	bcc.n	467e <_spi_m_sync_trans+0x7e>
			rc = ctrl.txcnt;
    46de:	693b      	ldr	r3, [r7, #16]
    46e0:	627b      	str	r3, [r7, #36]	; 0x24
			break;
    46e2:	e000      	b.n	46e6 <_spi_m_sync_trans+0xe6>
			break;
    46e4:	bf00      	nop
		}
	}
	/* Wait until SPI bus idle */
	_spi_wait_bus_idle(hw);
    46e6:	6a38      	ldr	r0, [r7, #32]
    46e8:	4b0b      	ldr	r3, [pc, #44]	; (4718 <_spi_m_sync_trans+0x118>)
    46ea:	4798      	blx	r3

	return rc;
    46ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
    46ee:	4618      	mov	r0, r3
    46f0:	372c      	adds	r7, #44	; 0x2c
    46f2:	46bd      	mov	sp, r7
    46f4:	bd90      	pop	{r4, r7, pc}
    46f6:	bf00      	nop
    46f8:	0000561c 	.word	0x0000561c
    46fc:	00001c39 	.word	0x00001c39
    4700:	00002f5d 	.word	0x00002f5d
    4704:	000031d1 	.word	0x000031d1
    4708:	00003049 	.word	0x00003049
    470c:	000044dd 	.word	0x000044dd
    4710:	00004549 	.word	0x00004549
    4714:	000045c1 	.word	0x000045c1
    4718:	000044ad 	.word	0x000044ad

0000471c <cache_init>:

/**
 * \brief Initialize cache module
 */
int32_t cache_init(void)
{
    471c:	b580      	push	{r7, lr}
    471e:	af00      	add	r7, sp, #0
	return _cmcc_init();
    4720:	4b02      	ldr	r3, [pc, #8]	; (472c <cache_init+0x10>)
    4722:	4798      	blx	r3
    4724:	4603      	mov	r3, r0
}
    4726:	4618      	mov	r0, r3
    4728:	bd80      	pop	{r7, pc}
    472a:	bf00      	nop
    472c:	00004869 	.word	0x00004869

00004730 <hri_cmcc_get_SR_CSTS_bit>:
{
	return ((Cmcc *)hw)->TYPE.reg;
}

static inline bool hri_cmcc_get_SR_CSTS_bit(const void *const hw)
{
    4730:	b480      	push	{r7}
    4732:	b083      	sub	sp, #12
    4734:	af00      	add	r7, sp, #0
    4736:	6078      	str	r0, [r7, #4]
	return (((Cmcc *)hw)->SR.reg & CMCC_SR_CSTS) >> CMCC_SR_CSTS_Pos;
    4738:	687b      	ldr	r3, [r7, #4]
    473a:	68db      	ldr	r3, [r3, #12]
    473c:	f003 0301 	and.w	r3, r3, #1
    4740:	2b00      	cmp	r3, #0
    4742:	bf14      	ite	ne
    4744:	2301      	movne	r3, #1
    4746:	2300      	moveq	r3, #0
    4748:	b2db      	uxtb	r3, r3
}
    474a:	4618      	mov	r0, r3
    474c:	370c      	adds	r7, #12
    474e:	46bd      	mov	sp, r7
    4750:	f85d 7b04 	ldr.w	r7, [sp], #4
    4754:	4770      	bx	lr

00004756 <hri_cmcc_write_CFG_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_cmcc_write_CFG_reg(const void *const hw, hri_cmcc_cfg_reg_t data)
{
    4756:	b480      	push	{r7}
    4758:	b083      	sub	sp, #12
    475a:	af00      	add	r7, sp, #0
    475c:	6078      	str	r0, [r7, #4]
    475e:	6039      	str	r1, [r7, #0]
	CMCC_CRITICAL_SECTION_ENTER();
	((Cmcc *)hw)->CFG.reg = data;
    4760:	687b      	ldr	r3, [r7, #4]
    4762:	683a      	ldr	r2, [r7, #0]
    4764:	605a      	str	r2, [r3, #4]
	CMCC_CRITICAL_SECTION_LEAVE();
}
    4766:	bf00      	nop
    4768:	370c      	adds	r7, #12
    476a:	46bd      	mov	sp, r7
    476c:	f85d 7b04 	ldr.w	r7, [sp], #4
    4770:	4770      	bx	lr

00004772 <hri_cmcc_write_CTRL_reg>:
{
	return ((Cmcc *)hw)->MEN.reg;
}

static inline void hri_cmcc_write_CTRL_reg(const void *const hw, hri_cmcc_ctrl_reg_t data)
{
    4772:	b480      	push	{r7}
    4774:	b083      	sub	sp, #12
    4776:	af00      	add	r7, sp, #0
    4778:	6078      	str	r0, [r7, #4]
    477a:	6039      	str	r1, [r7, #0]
	CMCC_CRITICAL_SECTION_ENTER();
	((Cmcc *)hw)->CTRL.reg = data;
    477c:	687b      	ldr	r3, [r7, #4]
    477e:	683a      	ldr	r2, [r7, #0]
    4780:	609a      	str	r2, [r3, #8]
	CMCC_CRITICAL_SECTION_LEAVE();
}
    4782:	bf00      	nop
    4784:	370c      	adds	r7, #12
    4786:	46bd      	mov	sp, r7
    4788:	f85d 7b04 	ldr.w	r7, [sp], #4
    478c:	4770      	bx	lr
	...

00004790 <_is_cache_enabled>:

/**
 * \brief Cache enable status
 */
static inline bool _is_cache_enabled(const void *hw)
{
    4790:	b580      	push	{r7, lr}
    4792:	b082      	sub	sp, #8
    4794:	af00      	add	r7, sp, #0
    4796:	6078      	str	r0, [r7, #4]
	return (hri_cmcc_get_SR_CSTS_bit(hw) == IS_CMCC_ENABLED ? true : false);
    4798:	6878      	ldr	r0, [r7, #4]
    479a:	4b03      	ldr	r3, [pc, #12]	; (47a8 <_is_cache_enabled+0x18>)
    479c:	4798      	blx	r3
    479e:	4603      	mov	r3, r0
}
    47a0:	4618      	mov	r0, r3
    47a2:	3708      	adds	r7, #8
    47a4:	46bd      	mov	sp, r7
    47a6:	bd80      	pop	{r7, pc}
    47a8:	00004731 	.word	0x00004731

000047ac <_is_cache_disabled>:

/**
 * \brief Cache disable status
 */
static inline bool _is_cache_disabled(const void *hw)
{
    47ac:	b580      	push	{r7, lr}
    47ae:	b082      	sub	sp, #8
    47b0:	af00      	add	r7, sp, #0
    47b2:	6078      	str	r0, [r7, #4]
	return (hri_cmcc_get_SR_CSTS_bit(hw) == IS_CMCC_DISABLED ? true : false);
    47b4:	6878      	ldr	r0, [r7, #4]
    47b6:	4b09      	ldr	r3, [pc, #36]	; (47dc <_is_cache_disabled+0x30>)
    47b8:	4798      	blx	r3
    47ba:	4603      	mov	r3, r0
    47bc:	2b00      	cmp	r3, #0
    47be:	bf14      	ite	ne
    47c0:	2301      	movne	r3, #1
    47c2:	2300      	moveq	r3, #0
    47c4:	b2db      	uxtb	r3, r3
    47c6:	f083 0301 	eor.w	r3, r3, #1
    47ca:	b2db      	uxtb	r3, r3
    47cc:	f003 0301 	and.w	r3, r3, #1
    47d0:	b2db      	uxtb	r3, r3
}
    47d2:	4618      	mov	r0, r3
    47d4:	3708      	adds	r7, #8
    47d6:	46bd      	mov	sp, r7
    47d8:	bd80      	pop	{r7, pc}
    47da:	bf00      	nop
    47dc:	00004731 	.word	0x00004731

000047e0 <_cmcc_enable>:

/**
 * \brief Cache enable
 */
static inline int32_t _cmcc_enable(const void *hw)
{
    47e0:	b580      	push	{r7, lr}
    47e2:	b084      	sub	sp, #16
    47e4:	af00      	add	r7, sp, #0
    47e6:	6078      	str	r0, [r7, #4]
	int32_t return_value;

	if (_is_cache_disabled(hw)) {
    47e8:	6878      	ldr	r0, [r7, #4]
    47ea:	4b0e      	ldr	r3, [pc, #56]	; (4824 <_cmcc_enable+0x44>)
    47ec:	4798      	blx	r3
    47ee:	4603      	mov	r3, r0
    47f0:	2b00      	cmp	r3, #0
    47f2:	d00f      	beq.n	4814 <_cmcc_enable+0x34>
		hri_cmcc_write_CTRL_reg(hw, CMCC_CTRL_CEN);
    47f4:	2101      	movs	r1, #1
    47f6:	6878      	ldr	r0, [r7, #4]
    47f8:	4b0b      	ldr	r3, [pc, #44]	; (4828 <_cmcc_enable+0x48>)
    47fa:	4798      	blx	r3
		return_value = _is_cache_enabled(hw) == true ? ERR_NONE : ERR_FAILURE;
    47fc:	6878      	ldr	r0, [r7, #4]
    47fe:	4b0b      	ldr	r3, [pc, #44]	; (482c <_cmcc_enable+0x4c>)
    4800:	4798      	blx	r3
    4802:	4603      	mov	r3, r0
    4804:	2b00      	cmp	r3, #0
    4806:	d001      	beq.n	480c <_cmcc_enable+0x2c>
    4808:	2300      	movs	r3, #0
    480a:	e001      	b.n	4810 <_cmcc_enable+0x30>
    480c:	f06f 031d 	mvn.w	r3, #29
    4810:	60fb      	str	r3, [r7, #12]
    4812:	e002      	b.n	481a <_cmcc_enable+0x3a>
	} else {
		return_value = ERR_NO_CHANGE;
    4814:	f06f 0301 	mvn.w	r3, #1
    4818:	60fb      	str	r3, [r7, #12]
	}

	return return_value;
    481a:	68fb      	ldr	r3, [r7, #12]
}
    481c:	4618      	mov	r0, r3
    481e:	3710      	adds	r7, #16
    4820:	46bd      	mov	sp, r7
    4822:	bd80      	pop	{r7, pc}
    4824:	000047ad 	.word	0x000047ad
    4828:	00004773 	.word	0x00004773
    482c:	00004791 	.word	0x00004791

00004830 <_cmcc_disable>:

/**
 * \brief Cache disable
 */
static inline int32_t _cmcc_disable(const void *hw)
{
    4830:	b580      	push	{r7, lr}
    4832:	b082      	sub	sp, #8
    4834:	af00      	add	r7, sp, #0
    4836:	6078      	str	r0, [r7, #4]
	hri_cmcc_write_CTRL_reg(hw, (CMCC_DISABLE << CMCC_CTRL_CEN_Pos));
    4838:	2100      	movs	r1, #0
    483a:	6878      	ldr	r0, [r7, #4]
    483c:	4b08      	ldr	r3, [pc, #32]	; (4860 <_cmcc_disable+0x30>)
    483e:	4798      	blx	r3
	while (!(_is_cache_disabled(hw)))
    4840:	bf00      	nop
    4842:	6878      	ldr	r0, [r7, #4]
    4844:	4b07      	ldr	r3, [pc, #28]	; (4864 <_cmcc_disable+0x34>)
    4846:	4798      	blx	r3
    4848:	4603      	mov	r3, r0
    484a:	f083 0301 	eor.w	r3, r3, #1
    484e:	b2db      	uxtb	r3, r3
    4850:	2b00      	cmp	r3, #0
    4852:	d1f6      	bne.n	4842 <_cmcc_disable+0x12>
		;

	return ERR_NONE;
    4854:	2300      	movs	r3, #0
}
    4856:	4618      	mov	r0, r3
    4858:	3708      	adds	r7, #8
    485a:	46bd      	mov	sp, r7
    485c:	bd80      	pop	{r7, pc}
    485e:	bf00      	nop
    4860:	00004773 	.word	0x00004773
    4864:	000047ad 	.word	0x000047ad

00004868 <_cmcc_init>:
 * This function does low level cache configuration.
 *
 * \return initialize status
 */
int32_t _cmcc_init(void)
{
    4868:	b580      	push	{r7, lr}
    486a:	b082      	sub	sp, #8
    486c:	af00      	add	r7, sp, #0
	int32_t return_value;

	_cmcc_disable(CMCC);
    486e:	4812      	ldr	r0, [pc, #72]	; (48b8 <_cmcc_init+0x50>)
    4870:	4b12      	ldr	r3, [pc, #72]	; (48bc <_cmcc_init+0x54>)
    4872:	4798      	blx	r3

	if (_is_cache_disabled(CMCC)) {
    4874:	4810      	ldr	r0, [pc, #64]	; (48b8 <_cmcc_init+0x50>)
    4876:	4b12      	ldr	r3, [pc, #72]	; (48c0 <_cmcc_init+0x58>)
    4878:	4798      	blx	r3
    487a:	4603      	mov	r3, r0
    487c:	2b00      	cmp	r3, #0
    487e:	d012      	beq.n	48a6 <_cmcc_init+0x3e>
		hri_cmcc_write_CFG_reg(
    4880:	2120      	movs	r1, #32
    4882:	480d      	ldr	r0, [pc, #52]	; (48b8 <_cmcc_init+0x50>)
    4884:	4b0f      	ldr	r3, [pc, #60]	; (48c4 <_cmcc_init+0x5c>)
    4886:	4798      	blx	r3
		    CMCC,
		    (CMCC_CFG_CSIZESW(CONF_CMCC_CACHE_SIZE) | (CONF_CMCC_DATA_CACHE_DISABLE << CMCC_CFG_DCDIS_Pos)
		     | (CONF_CMCC_INST_CACHE_DISABLE << CMCC_CFG_ICDIS_Pos) | (CONF_CMCC_CLK_GATING_DISABLE)));

		_cmcc_enable(CMCC);
    4888:	480b      	ldr	r0, [pc, #44]	; (48b8 <_cmcc_init+0x50>)
    488a:	4b0f      	ldr	r3, [pc, #60]	; (48c8 <_cmcc_init+0x60>)
    488c:	4798      	blx	r3
		return_value = _is_cache_enabled(CMCC) == true ? ERR_NONE : ERR_FAILURE;
    488e:	480a      	ldr	r0, [pc, #40]	; (48b8 <_cmcc_init+0x50>)
    4890:	4b0e      	ldr	r3, [pc, #56]	; (48cc <_cmcc_init+0x64>)
    4892:	4798      	blx	r3
    4894:	4603      	mov	r3, r0
    4896:	2b00      	cmp	r3, #0
    4898:	d001      	beq.n	489e <_cmcc_init+0x36>
    489a:	2300      	movs	r3, #0
    489c:	e001      	b.n	48a2 <_cmcc_init+0x3a>
    489e:	f06f 031d 	mvn.w	r3, #29
    48a2:	607b      	str	r3, [r7, #4]
    48a4:	e002      	b.n	48ac <_cmcc_init+0x44>
	} else {
		return_value = ERR_NOT_INITIALIZED;
    48a6:	f06f 0313 	mvn.w	r3, #19
    48aa:	607b      	str	r3, [r7, #4]
	}

	return return_value;
    48ac:	687b      	ldr	r3, [r7, #4]
}
    48ae:	4618      	mov	r0, r3
    48b0:	3708      	adds	r7, #8
    48b2:	46bd      	mov	sp, r7
    48b4:	bd80      	pop	{r7, pc}
    48b6:	bf00      	nop
    48b8:	41006000 	.word	0x41006000
    48bc:	00004831 	.word	0x00004831
    48c0:	000047ad 	.word	0x000047ad
    48c4:	00004757 	.word	0x00004757
    48c8:	000047e1 	.word	0x000047e1
    48cc:	00004791 	.word	0x00004791

000048d0 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
    48d0:	b580      	push	{r7, lr}
    48d2:	b082      	sub	sp, #8
    48d4:	af00      	add	r7, sp, #0
	uint32_t *pSrc, *pDest;

	/* Initialize the relocate segment */
	pSrc  = &_etext;
    48d6:	4b1d      	ldr	r3, [pc, #116]	; (494c <Reset_Handler+0x7c>)
    48d8:	607b      	str	r3, [r7, #4]
	pDest = &_srelocate;
    48da:	4b1d      	ldr	r3, [pc, #116]	; (4950 <Reset_Handler+0x80>)
    48dc:	603b      	str	r3, [r7, #0]

	if (pSrc != pDest) {
    48de:	687a      	ldr	r2, [r7, #4]
    48e0:	683b      	ldr	r3, [r7, #0]
    48e2:	429a      	cmp	r2, r3
    48e4:	d00c      	beq.n	4900 <Reset_Handler+0x30>
		for (; pDest < &_erelocate;) {
    48e6:	e007      	b.n	48f8 <Reset_Handler+0x28>
			*pDest++ = *pSrc++;
    48e8:	687a      	ldr	r2, [r7, #4]
    48ea:	1d13      	adds	r3, r2, #4
    48ec:	607b      	str	r3, [r7, #4]
    48ee:	683b      	ldr	r3, [r7, #0]
    48f0:	1d19      	adds	r1, r3, #4
    48f2:	6039      	str	r1, [r7, #0]
    48f4:	6812      	ldr	r2, [r2, #0]
    48f6:	601a      	str	r2, [r3, #0]
		for (; pDest < &_erelocate;) {
    48f8:	683b      	ldr	r3, [r7, #0]
    48fa:	4a16      	ldr	r2, [pc, #88]	; (4954 <Reset_Handler+0x84>)
    48fc:	4293      	cmp	r3, r2
    48fe:	d3f3      	bcc.n	48e8 <Reset_Handler+0x18>
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
    4900:	4b15      	ldr	r3, [pc, #84]	; (4958 <Reset_Handler+0x88>)
    4902:	603b      	str	r3, [r7, #0]
    4904:	e004      	b.n	4910 <Reset_Handler+0x40>
		*pDest++ = 0;
    4906:	683b      	ldr	r3, [r7, #0]
    4908:	1d1a      	adds	r2, r3, #4
    490a:	603a      	str	r2, [r7, #0]
    490c:	2200      	movs	r2, #0
    490e:	601a      	str	r2, [r3, #0]
	for (pDest = &_szero; pDest < &_ezero;) {
    4910:	683b      	ldr	r3, [r7, #0]
    4912:	4a12      	ldr	r2, [pc, #72]	; (495c <Reset_Handler+0x8c>)
    4914:	4293      	cmp	r3, r2
    4916:	d3f6      	bcc.n	4906 <Reset_Handler+0x36>
	}

	/* Set the vector table base address */
	pSrc      = (uint32_t *)&_sfixed;
    4918:	4b11      	ldr	r3, [pc, #68]	; (4960 <Reset_Handler+0x90>)
    491a:	607b      	str	r3, [r7, #4]
	SCB->VTOR = ((uint32_t)pSrc & SCB_VTOR_TBLOFF_Msk);
    491c:	687b      	ldr	r3, [r7, #4]
    491e:	4a11      	ldr	r2, [pc, #68]	; (4964 <Reset_Handler+0x94>)
    4920:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
    4924:	6093      	str	r3, [r2, #8]

#if __FPU_USED
	/* Enable FPU */
	SCB->CPACR |= (0xFu << 20);
    4926:	4b0f      	ldr	r3, [pc, #60]	; (4964 <Reset_Handler+0x94>)
    4928:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    492c:	4a0d      	ldr	r2, [pc, #52]	; (4964 <Reset_Handler+0x94>)
    492e:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
    4932:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    4936:	f3bf 8f4f 	dsb	sy
}
    493a:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
    493c:	f3bf 8f6f 	isb	sy
}
    4940:	bf00      	nop
	__DSB();
	__ISB();
#endif

	/* Initialize the C library */
	__libc_init_array();
    4942:	4b09      	ldr	r3, [pc, #36]	; (4968 <Reset_Handler+0x98>)
    4944:	4798      	blx	r3

	/* Branch to main function */
	main();
    4946:	4b09      	ldr	r3, [pc, #36]	; (496c <Reset_Handler+0x9c>)
    4948:	4798      	blx	r3

	/* Infinite loop */
	while (1)
    494a:	e7fe      	b.n	494a <Reset_Handler+0x7a>
    494c:	000056d0 	.word	0x000056d0
    4950:	20000000 	.word	0x20000000
    4954:	20000030 	.word	0x20000030
    4958:	20000030 	.word	0x20000030
    495c:	20000660 	.word	0x20000660
    4960:	00000000 	.word	0x00000000
    4964:	e000ed00 	.word	0xe000ed00
    4968:	00005249 	.word	0x00005249
    496c:	00000309 	.word	0x00000309

00004970 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    4970:	b480      	push	{r7}
    4972:	af00      	add	r7, sp, #0
	while (1) {
    4974:	e7fe      	b.n	4974 <Dummy_Handler+0x4>
	...

00004978 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
    4978:	b580      	push	{r7, lr}
    497a:	af00      	add	r7, sp, #0
	system_init();
    497c:	4b01      	ldr	r3, [pc, #4]	; (4984 <atmel_start_init+0xc>)
    497e:	4798      	blx	r3
}
    4980:	bf00      	nop
    4982:	bd80      	pop	{r7, pc}
    4984:	00002dd9 	.word	0x00002dd9

00004988 <atomic_enter_critical>:

/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
    4988:	b480      	push	{r7}
    498a:	b085      	sub	sp, #20
    498c:	af00      	add	r7, sp, #0
    498e:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    4990:	f3ef 8310 	mrs	r3, PRIMASK
    4994:	60fb      	str	r3, [r7, #12]
  return(result);
    4996:	68fa      	ldr	r2, [r7, #12]
	*atomic = __get_PRIMASK();
    4998:	687b      	ldr	r3, [r7, #4]
    499a:	601a      	str	r2, [r3, #0]
  __ASM volatile ("cpsid i" : : : "memory");
    499c:	b672      	cpsid	i
}
    499e:	bf00      	nop
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    49a0:	f3bf 8f5f 	dmb	sy
}
    49a4:	bf00      	nop
	__disable_irq();
	__DMB();
}
    49a6:	bf00      	nop
    49a8:	3714      	adds	r7, #20
    49aa:	46bd      	mov	sp, r7
    49ac:	f85d 7b04 	ldr.w	r7, [sp], #4
    49b0:	4770      	bx	lr

000049b2 <atomic_leave_critical>:

/**
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
    49b2:	b480      	push	{r7}
    49b4:	b085      	sub	sp, #20
    49b6:	af00      	add	r7, sp, #0
    49b8:	6078      	str	r0, [r7, #4]
  __ASM volatile ("dmb 0xF":::"memory");
    49ba:	f3bf 8f5f 	dmb	sy
}
    49be:	bf00      	nop
	__DMB();
	__set_PRIMASK(*atomic);
    49c0:	687b      	ldr	r3, [r7, #4]
    49c2:	681b      	ldr	r3, [r3, #0]
    49c4:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
    49c6:	68fb      	ldr	r3, [r7, #12]
    49c8:	f383 8810 	msr	PRIMASK, r3
}
    49cc:	bf00      	nop
}
    49ce:	bf00      	nop
    49d0:	3714      	adds	r7, #20
    49d2:	46bd      	mov	sp, r7
    49d4:	f85d 7b04 	ldr.w	r7, [sp], #4
    49d8:	4770      	bx	lr
	...

000049dc <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick(void)
{
    49dc:	b580      	push	{r7, lr}
    49de:	b086      	sub	sp, #24
    49e0:	af00      	add	r7, sp, #0
	TCB_t *    pxTCB;
	TickType_t xItemValue;
	BaseType_t xSwitchRequired = pdFALSE;
    49e2:	2300      	movs	r3, #0
    49e4:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK(xTickCount);
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    49e6:	4b51      	ldr	r3, [pc, #324]	; (4b2c <xTaskIncrementTick+0x150>)
    49e8:	681b      	ldr	r3, [r3, #0]
    49ea:	2b00      	cmp	r3, #0
    49ec:	f040 808e 	bne.w	4b0c <xTaskIncrementTick+0x130>
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + (TickType_t)1;
    49f0:	4b4f      	ldr	r3, [pc, #316]	; (4b30 <xTaskIncrementTick+0x154>)
    49f2:	681b      	ldr	r3, [r3, #0]
    49f4:	3301      	adds	r3, #1
    49f6:	613b      	str	r3, [r7, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    49f8:	4a4d      	ldr	r2, [pc, #308]	; (4b30 <xTaskIncrementTick+0x154>)
    49fa:	693b      	ldr	r3, [r7, #16]
    49fc:	6013      	str	r3, [r2, #0]

		if (xConstTickCount
    49fe:	693b      	ldr	r3, [r7, #16]
    4a00:	2b00      	cmp	r3, #0
    4a02:	d120      	bne.n	4a46 <xTaskIncrementTick+0x6a>
		    == (TickType_t)0U) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
		{
			taskSWITCH_DELAYED_LISTS();
    4a04:	4b4b      	ldr	r3, [pc, #300]	; (4b34 <xTaskIncrementTick+0x158>)
    4a06:	681b      	ldr	r3, [r3, #0]
    4a08:	681b      	ldr	r3, [r3, #0]
    4a0a:	2b00      	cmp	r3, #0
    4a0c:	d00a      	beq.n	4a24 <xTaskIncrementTick+0x48>
	__asm volatile("	mov %0, %1												\n"
    4a0e:	f04f 0380 	mov.w	r3, #128	; 0x80
    4a12:	f383 8811 	msr	BASEPRI, r3
    4a16:	f3bf 8f6f 	isb	sy
    4a1a:	f3bf 8f4f 	dsb	sy
    4a1e:	603b      	str	r3, [r7, #0]
}
    4a20:	bf00      	nop
    4a22:	e7fe      	b.n	4a22 <xTaskIncrementTick+0x46>
    4a24:	4b43      	ldr	r3, [pc, #268]	; (4b34 <xTaskIncrementTick+0x158>)
    4a26:	681b      	ldr	r3, [r3, #0]
    4a28:	60fb      	str	r3, [r7, #12]
    4a2a:	4b43      	ldr	r3, [pc, #268]	; (4b38 <xTaskIncrementTick+0x15c>)
    4a2c:	681b      	ldr	r3, [r3, #0]
    4a2e:	4a41      	ldr	r2, [pc, #260]	; (4b34 <xTaskIncrementTick+0x158>)
    4a30:	6013      	str	r3, [r2, #0]
    4a32:	4a41      	ldr	r2, [pc, #260]	; (4b38 <xTaskIncrementTick+0x15c>)
    4a34:	68fb      	ldr	r3, [r7, #12]
    4a36:	6013      	str	r3, [r2, #0]
    4a38:	4b40      	ldr	r3, [pc, #256]	; (4b3c <xTaskIncrementTick+0x160>)
    4a3a:	681b      	ldr	r3, [r3, #0]
    4a3c:	3301      	adds	r3, #1
    4a3e:	4a3f      	ldr	r2, [pc, #252]	; (4b3c <xTaskIncrementTick+0x160>)
    4a40:	6013      	str	r3, [r2, #0]
    4a42:	4b3f      	ldr	r3, [pc, #252]	; (4b40 <xTaskIncrementTick+0x164>)
    4a44:	4798      	blx	r3

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if (xConstTickCount >= xNextTaskUnblockTime) {
    4a46:	4b3f      	ldr	r3, [pc, #252]	; (4b44 <xTaskIncrementTick+0x168>)
    4a48:	681b      	ldr	r3, [r3, #0]
    4a4a:	693a      	ldr	r2, [r7, #16]
    4a4c:	429a      	cmp	r2, r3
    4a4e:	d34e      	bcc.n	4aee <xTaskIncrementTick+0x112>
			for (;;) {
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    4a50:	4b38      	ldr	r3, [pc, #224]	; (4b34 <xTaskIncrementTick+0x158>)
    4a52:	681b      	ldr	r3, [r3, #0]
    4a54:	681b      	ldr	r3, [r3, #0]
    4a56:	2b00      	cmp	r3, #0
    4a58:	d101      	bne.n	4a5e <xTaskIncrementTick+0x82>
    4a5a:	2301      	movs	r3, #1
    4a5c:	e000      	b.n	4a60 <xTaskIncrementTick+0x84>
    4a5e:	2300      	movs	r3, #0
    4a60:	2b00      	cmp	r3, #0
    4a62:	d004      	beq.n	4a6e <xTaskIncrementTick+0x92>
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime
					    = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4a64:	4b37      	ldr	r3, [pc, #220]	; (4b44 <xTaskIncrementTick+0x168>)
    4a66:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    4a6a:	601a      	str	r2, [r3, #0]
					break;
    4a6c:	e03f      	b.n	4aee <xTaskIncrementTick+0x112>
				} else {
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB      = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    4a6e:	4b31      	ldr	r3, [pc, #196]	; (4b34 <xTaskIncrementTick+0x158>)
    4a70:	681b      	ldr	r3, [r3, #0]
    4a72:	68db      	ldr	r3, [r3, #12]
    4a74:	68db      	ldr	r3, [r3, #12]
    4a76:	60bb      	str	r3, [r7, #8]
					xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
    4a78:	68bb      	ldr	r3, [r7, #8]
    4a7a:	685b      	ldr	r3, [r3, #4]
    4a7c:	607b      	str	r3, [r7, #4]

					if (xConstTickCount < xItemValue) {
    4a7e:	693a      	ldr	r2, [r7, #16]
    4a80:	687b      	ldr	r3, [r7, #4]
    4a82:	429a      	cmp	r2, r3
    4a84:	d203      	bcs.n	4a8e <xTaskIncrementTick+0xb2>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    4a86:	4a2f      	ldr	r2, [pc, #188]	; (4b44 <xTaskIncrementTick+0x168>)
    4a88:	687b      	ldr	r3, [r7, #4]
    4a8a:	6013      	str	r3, [r2, #0]
						break;
    4a8c:	e02f      	b.n	4aee <xTaskIncrementTick+0x112>
					} else {
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					(void)uxListRemove(&(pxTCB->xStateListItem));
    4a8e:	68bb      	ldr	r3, [r7, #8]
    4a90:	3304      	adds	r3, #4
    4a92:	4618      	mov	r0, r3
    4a94:	4b2c      	ldr	r3, [pc, #176]	; (4b48 <xTaskIncrementTick+0x16c>)
    4a96:	4798      	blx	r3

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
    4a98:	68bb      	ldr	r3, [r7, #8]
    4a9a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    4a9c:	2b00      	cmp	r3, #0
    4a9e:	d004      	beq.n	4aaa <xTaskIncrementTick+0xce>
						(void)uxListRemove(&(pxTCB->xEventListItem));
    4aa0:	68bb      	ldr	r3, [r7, #8]
    4aa2:	3318      	adds	r3, #24
    4aa4:	4618      	mov	r0, r3
    4aa6:	4b28      	ldr	r3, [pc, #160]	; (4b48 <xTaskIncrementTick+0x16c>)
    4aa8:	4798      	blx	r3
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList(pxTCB);
    4aaa:	68bb      	ldr	r3, [r7, #8]
    4aac:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4aae:	4b27      	ldr	r3, [pc, #156]	; (4b4c <xTaskIncrementTick+0x170>)
    4ab0:	681b      	ldr	r3, [r3, #0]
    4ab2:	429a      	cmp	r2, r3
    4ab4:	d903      	bls.n	4abe <xTaskIncrementTick+0xe2>
    4ab6:	68bb      	ldr	r3, [r7, #8]
    4ab8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    4aba:	4a24      	ldr	r2, [pc, #144]	; (4b4c <xTaskIncrementTick+0x170>)
    4abc:	6013      	str	r3, [r2, #0]
    4abe:	68bb      	ldr	r3, [r7, #8]
    4ac0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4ac2:	4613      	mov	r3, r2
    4ac4:	009b      	lsls	r3, r3, #2
    4ac6:	4413      	add	r3, r2
    4ac8:	009b      	lsls	r3, r3, #2
    4aca:	4a21      	ldr	r2, [pc, #132]	; (4b50 <xTaskIncrementTick+0x174>)
    4acc:	441a      	add	r2, r3
    4ace:	68bb      	ldr	r3, [r7, #8]
    4ad0:	3304      	adds	r3, #4
    4ad2:	4619      	mov	r1, r3
    4ad4:	4610      	mov	r0, r2
    4ad6:	4b1f      	ldr	r3, [pc, #124]	; (4b54 <xTaskIncrementTick+0x178>)
    4ad8:	4798      	blx	r3
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    4ada:	68bb      	ldr	r3, [r7, #8]
    4adc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4ade:	4b1e      	ldr	r3, [pc, #120]	; (4b58 <xTaskIncrementTick+0x17c>)
    4ae0:	681b      	ldr	r3, [r3, #0]
    4ae2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    4ae4:	429a      	cmp	r2, r3
    4ae6:	d3b3      	bcc.n	4a50 <xTaskIncrementTick+0x74>
							xSwitchRequired = pdTRUE;
    4ae8:	2301      	movs	r3, #1
    4aea:	617b      	str	r3, [r7, #20]
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    4aec:	e7b0      	b.n	4a50 <xTaskIncrementTick+0x74>
/* Tasks of equal priority to the currently running task will share
processing time (time slice) if preemption is on, and the application
writer has not explicitly turned time slicing off. */
#if ((configUSE_PREEMPTION == 1) && (configUSE_TIME_SLICING == 1))
		{
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1) {
    4aee:	4b1a      	ldr	r3, [pc, #104]	; (4b58 <xTaskIncrementTick+0x17c>)
    4af0:	681b      	ldr	r3, [r3, #0]
    4af2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    4af4:	4916      	ldr	r1, [pc, #88]	; (4b50 <xTaskIncrementTick+0x174>)
    4af6:	4613      	mov	r3, r2
    4af8:	009b      	lsls	r3, r3, #2
    4afa:	4413      	add	r3, r2
    4afc:	009b      	lsls	r3, r3, #2
    4afe:	440b      	add	r3, r1
    4b00:	681b      	ldr	r3, [r3, #0]
    4b02:	2b01      	cmp	r3, #1
    4b04:	d907      	bls.n	4b16 <xTaskIncrementTick+0x13a>
				xSwitchRequired = pdTRUE;
    4b06:	2301      	movs	r3, #1
    4b08:	617b      	str	r3, [r7, #20]
    4b0a:	e004      	b.n	4b16 <xTaskIncrementTick+0x13a>
				mtCOVERAGE_TEST_MARKER();
			}
		}
#endif /* configUSE_TICK_HOOK */
	} else {
		++uxPendedTicks;
    4b0c:	4b13      	ldr	r3, [pc, #76]	; (4b5c <xTaskIncrementTick+0x180>)
    4b0e:	681b      	ldr	r3, [r3, #0]
    4b10:	3301      	adds	r3, #1
    4b12:	4a12      	ldr	r2, [pc, #72]	; (4b5c <xTaskIncrementTick+0x180>)
    4b14:	6013      	str	r3, [r2, #0]
#endif
	}

#if (configUSE_PREEMPTION == 1)
	{
		if (xYieldPending != pdFALSE) {
    4b16:	4b12      	ldr	r3, [pc, #72]	; (4b60 <xTaskIncrementTick+0x184>)
    4b18:	681b      	ldr	r3, [r3, #0]
    4b1a:	2b00      	cmp	r3, #0
    4b1c:	d001      	beq.n	4b22 <xTaskIncrementTick+0x146>
			xSwitchRequired = pdTRUE;
    4b1e:	2301      	movs	r3, #1
    4b20:	617b      	str	r3, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    4b22:	697b      	ldr	r3, [r7, #20]
}
    4b24:	4618      	mov	r0, r3
    4b26:	3718      	adds	r7, #24
    4b28:	46bd      	mov	sp, r7
    4b2a:	bd80      	pop	{r7, pc}
    4b2c:	2000065c 	.word	0x2000065c
    4b30:	20000638 	.word	0x20000638
    4b34:	20000604 	.word	0x20000604
    4b38:	20000608 	.word	0x20000608
    4b3c:	2000064c 	.word	0x2000064c
    4b40:	00004c21 	.word	0x00004c21
    4b44:	20000654 	.word	0x20000654
    4b48:	000012a9 	.word	0x000012a9
    4b4c:	2000063c 	.word	0x2000063c
    4b50:	20000578 	.word	0x20000578
    4b54:	00001261 	.word	0x00001261
    4b58:	20000574 	.word	0x20000574
    4b5c:	20000644 	.word	0x20000644
    4b60:	20000648 	.word	0x20000648

00004b64 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext(void)
{
    4b64:	b480      	push	{r7}
    4b66:	b085      	sub	sp, #20
    4b68:	af00      	add	r7, sp, #0
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
    4b6a:	4b28      	ldr	r3, [pc, #160]	; (4c0c <vTaskSwitchContext+0xa8>)
    4b6c:	681b      	ldr	r3, [r3, #0]
    4b6e:	2b00      	cmp	r3, #0
    4b70:	d003      	beq.n	4b7a <vTaskSwitchContext+0x16>
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    4b72:	4b27      	ldr	r3, [pc, #156]	; (4c10 <vTaskSwitchContext+0xac>)
    4b74:	2201      	movs	r2, #1
    4b76:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &(pxCurrentTCB->xNewLib_reent);
		}
#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    4b78:	e041      	b.n	4bfe <vTaskSwitchContext+0x9a>
		xYieldPending = pdFALSE;
    4b7a:	4b25      	ldr	r3, [pc, #148]	; (4c10 <vTaskSwitchContext+0xac>)
    4b7c:	2200      	movs	r2, #0
    4b7e:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
    4b80:	4b24      	ldr	r3, [pc, #144]	; (4c14 <vTaskSwitchContext+0xb0>)
    4b82:	681b      	ldr	r3, [r3, #0]
    4b84:	60fb      	str	r3, [r7, #12]
    4b86:	e010      	b.n	4baa <vTaskSwitchContext+0x46>
    4b88:	68fb      	ldr	r3, [r7, #12]
    4b8a:	2b00      	cmp	r3, #0
    4b8c:	d10a      	bne.n	4ba4 <vTaskSwitchContext+0x40>
	__asm volatile("	mov %0, %1												\n"
    4b8e:	f04f 0380 	mov.w	r3, #128	; 0x80
    4b92:	f383 8811 	msr	BASEPRI, r3
    4b96:	f3bf 8f6f 	isb	sy
    4b9a:	f3bf 8f4f 	dsb	sy
    4b9e:	607b      	str	r3, [r7, #4]
}
    4ba0:	bf00      	nop
    4ba2:	e7fe      	b.n	4ba2 <vTaskSwitchContext+0x3e>
    4ba4:	68fb      	ldr	r3, [r7, #12]
    4ba6:	3b01      	subs	r3, #1
    4ba8:	60fb      	str	r3, [r7, #12]
    4baa:	491b      	ldr	r1, [pc, #108]	; (4c18 <vTaskSwitchContext+0xb4>)
    4bac:	68fa      	ldr	r2, [r7, #12]
    4bae:	4613      	mov	r3, r2
    4bb0:	009b      	lsls	r3, r3, #2
    4bb2:	4413      	add	r3, r2
    4bb4:	009b      	lsls	r3, r3, #2
    4bb6:	440b      	add	r3, r1
    4bb8:	681b      	ldr	r3, [r3, #0]
    4bba:	2b00      	cmp	r3, #0
    4bbc:	d0e4      	beq.n	4b88 <vTaskSwitchContext+0x24>
    4bbe:	68fa      	ldr	r2, [r7, #12]
    4bc0:	4613      	mov	r3, r2
    4bc2:	009b      	lsls	r3, r3, #2
    4bc4:	4413      	add	r3, r2
    4bc6:	009b      	lsls	r3, r3, #2
    4bc8:	4a13      	ldr	r2, [pc, #76]	; (4c18 <vTaskSwitchContext+0xb4>)
    4bca:	4413      	add	r3, r2
    4bcc:	60bb      	str	r3, [r7, #8]
    4bce:	68bb      	ldr	r3, [r7, #8]
    4bd0:	685b      	ldr	r3, [r3, #4]
    4bd2:	685a      	ldr	r2, [r3, #4]
    4bd4:	68bb      	ldr	r3, [r7, #8]
    4bd6:	605a      	str	r2, [r3, #4]
    4bd8:	68bb      	ldr	r3, [r7, #8]
    4bda:	685a      	ldr	r2, [r3, #4]
    4bdc:	68bb      	ldr	r3, [r7, #8]
    4bde:	3308      	adds	r3, #8
    4be0:	429a      	cmp	r2, r3
    4be2:	d104      	bne.n	4bee <vTaskSwitchContext+0x8a>
    4be4:	68bb      	ldr	r3, [r7, #8]
    4be6:	685b      	ldr	r3, [r3, #4]
    4be8:	685a      	ldr	r2, [r3, #4]
    4bea:	68bb      	ldr	r3, [r7, #8]
    4bec:	605a      	str	r2, [r3, #4]
    4bee:	68bb      	ldr	r3, [r7, #8]
    4bf0:	685b      	ldr	r3, [r3, #4]
    4bf2:	68db      	ldr	r3, [r3, #12]
    4bf4:	4a09      	ldr	r2, [pc, #36]	; (4c1c <vTaskSwitchContext+0xb8>)
    4bf6:	6013      	str	r3, [r2, #0]
    4bf8:	4a06      	ldr	r2, [pc, #24]	; (4c14 <vTaskSwitchContext+0xb0>)
    4bfa:	68fb      	ldr	r3, [r7, #12]
    4bfc:	6013      	str	r3, [r2, #0]
}
    4bfe:	bf00      	nop
    4c00:	3714      	adds	r7, #20
    4c02:	46bd      	mov	sp, r7
    4c04:	f85d 7b04 	ldr.w	r7, [sp], #4
    4c08:	4770      	bx	lr
    4c0a:	bf00      	nop
    4c0c:	2000065c 	.word	0x2000065c
    4c10:	20000648 	.word	0x20000648
    4c14:	2000063c 	.word	0x2000063c
    4c18:	20000578 	.word	0x20000578
    4c1c:	20000574 	.word	0x20000574

00004c20 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime(void)
{
    4c20:	b480      	push	{r7}
    4c22:	b083      	sub	sp, #12
    4c24:	af00      	add	r7, sp, #0
	TCB_t *pxTCB;

	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    4c26:	4b0f      	ldr	r3, [pc, #60]	; (4c64 <prvResetNextTaskUnblockTime+0x44>)
    4c28:	681b      	ldr	r3, [r3, #0]
    4c2a:	681b      	ldr	r3, [r3, #0]
    4c2c:	2b00      	cmp	r3, #0
    4c2e:	d101      	bne.n	4c34 <prvResetNextTaskUnblockTime+0x14>
    4c30:	2301      	movs	r3, #1
    4c32:	e000      	b.n	4c36 <prvResetNextTaskUnblockTime+0x16>
    4c34:	2300      	movs	r3, #0
    4c36:	2b00      	cmp	r3, #0
    4c38:	d004      	beq.n	4c44 <prvResetNextTaskUnblockTime+0x24>
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    4c3a:	4b0b      	ldr	r3, [pc, #44]	; (4c68 <prvResetNextTaskUnblockTime+0x48>)
    4c3c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    4c40:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
	}
}
    4c42:	e008      	b.n	4c56 <prvResetNextTaskUnblockTime+0x36>
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    4c44:	4b07      	ldr	r3, [pc, #28]	; (4c64 <prvResetNextTaskUnblockTime+0x44>)
    4c46:	681b      	ldr	r3, [r3, #0]
    4c48:	68db      	ldr	r3, [r3, #12]
    4c4a:	68db      	ldr	r3, [r3, #12]
    4c4c:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
    4c4e:	687b      	ldr	r3, [r7, #4]
    4c50:	685b      	ldr	r3, [r3, #4]
    4c52:	4a05      	ldr	r2, [pc, #20]	; (4c68 <prvResetNextTaskUnblockTime+0x48>)
    4c54:	6013      	str	r3, [r2, #0]
}
    4c56:	bf00      	nop
    4c58:	370c      	adds	r7, #12
    4c5a:	46bd      	mov	sp, r7
    4c5c:	f85d 7b04 	ldr.w	r7, [sp], #4
    4c60:	4770      	bx	lr
    4c62:	bf00      	nop
    4c64:	20000604 	.word	0x20000604
    4c68:	20000654 	.word	0x20000654

00004c6c <hri_adc_wait_for_sync>:
typedef uint8_t  hri_adc_sampctrl_reg_t;
typedef uint8_t  hri_adc_status_reg_t;
typedef uint8_t  hri_adc_swtrig_reg_t;

static inline void hri_adc_wait_for_sync(const void *const hw, hri_adc_syncbusy_reg_t reg)
{
    4c6c:	b480      	push	{r7}
    4c6e:	b083      	sub	sp, #12
    4c70:	af00      	add	r7, sp, #0
    4c72:	6078      	str	r0, [r7, #4]
    4c74:	6039      	str	r1, [r7, #0]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    4c76:	bf00      	nop
    4c78:	687b      	ldr	r3, [r7, #4]
    4c7a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    4c7c:	683b      	ldr	r3, [r7, #0]
    4c7e:	4013      	ands	r3, r2
    4c80:	2b00      	cmp	r3, #0
    4c82:	d1f9      	bne.n	4c78 <hri_adc_wait_for_sync+0xc>
	};
}
    4c84:	bf00      	nop
    4c86:	bf00      	nop
    4c88:	370c      	adds	r7, #12
    4c8a:	46bd      	mov	sp, r7
    4c8c:	f85d 7b04 	ldr.w	r7, [sp], #4
    4c90:	4770      	bx	lr

00004c92 <hri_adc_is_syncing>:

static inline bool hri_adc_is_syncing(const void *const hw, hri_adc_syncbusy_reg_t reg)
{
    4c92:	b480      	push	{r7}
    4c94:	b083      	sub	sp, #12
    4c96:	af00      	add	r7, sp, #0
    4c98:	6078      	str	r0, [r7, #4]
    4c9a:	6039      	str	r1, [r7, #0]
	return ((Adc *)hw)->SYNCBUSY.reg & reg;
    4c9c:	687b      	ldr	r3, [r7, #4]
    4c9e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    4ca0:	683b      	ldr	r3, [r7, #0]
    4ca2:	4013      	ands	r3, r2
    4ca4:	2b00      	cmp	r3, #0
    4ca6:	bf14      	ite	ne
    4ca8:	2301      	movne	r3, #1
    4caa:	2300      	moveq	r3, #0
    4cac:	b2db      	uxtb	r3, r3
}
    4cae:	4618      	mov	r0, r3
    4cb0:	370c      	adds	r7, #12
    4cb2:	46bd      	mov	sp, r7
    4cb4:	f85d 7b04 	ldr.w	r7, [sp], #4
    4cb8:	4770      	bx	lr
	...

00004cbc <hri_adc_clear_CTRLA_ENABLE_bit>:
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
	ADC_CRITICAL_SECTION_LEAVE();
}

static inline void hri_adc_clear_CTRLA_ENABLE_bit(const void *const hw)
{
    4cbc:	b580      	push	{r7, lr}
    4cbe:	b082      	sub	sp, #8
    4cc0:	af00      	add	r7, sp, #0
    4cc2:	6078      	str	r0, [r7, #4]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg &= ~ADC_CTRLA_ENABLE;
    4cc4:	687b      	ldr	r3, [r7, #4]
    4cc6:	881b      	ldrh	r3, [r3, #0]
    4cc8:	b29b      	uxth	r3, r3
    4cca:	f023 0302 	bic.w	r3, r3, #2
    4cce:	b29a      	uxth	r2, r3
    4cd0:	687b      	ldr	r3, [r7, #4]
    4cd2:	801a      	strh	r2, [r3, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
    4cd4:	2103      	movs	r1, #3
    4cd6:	6878      	ldr	r0, [r7, #4]
    4cd8:	4b02      	ldr	r3, [pc, #8]	; (4ce4 <hri_adc_clear_CTRLA_ENABLE_bit+0x28>)
    4cda:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    4cdc:	bf00      	nop
    4cde:	3708      	adds	r7, #8
    4ce0:	46bd      	mov	sp, r7
    4ce2:	bd80      	pop	{r7, pc}
    4ce4:	00004c6d 	.word	0x00004c6d

00004ce8 <hri_adc_get_CTRLA_reg>:
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
	ADC_CRITICAL_SECTION_LEAVE();
}

static inline hri_adc_ctrla_reg_t hri_adc_get_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t mask)
{
    4ce8:	b580      	push	{r7, lr}
    4cea:	b084      	sub	sp, #16
    4cec:	af00      	add	r7, sp, #0
    4cee:	6078      	str	r0, [r7, #4]
    4cf0:	460b      	mov	r3, r1
    4cf2:	807b      	strh	r3, [r7, #2]
	uint16_t tmp;
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
    4cf4:	2103      	movs	r1, #3
    4cf6:	6878      	ldr	r0, [r7, #4]
    4cf8:	4b06      	ldr	r3, [pc, #24]	; (4d14 <hri_adc_get_CTRLA_reg+0x2c>)
    4cfa:	4798      	blx	r3
	tmp = ((Adc *)hw)->CTRLA.reg;
    4cfc:	687b      	ldr	r3, [r7, #4]
    4cfe:	881b      	ldrh	r3, [r3, #0]
    4d00:	81fb      	strh	r3, [r7, #14]
	tmp &= mask;
    4d02:	89fa      	ldrh	r2, [r7, #14]
    4d04:	887b      	ldrh	r3, [r7, #2]
    4d06:	4013      	ands	r3, r2
    4d08:	81fb      	strh	r3, [r7, #14]
	return tmp;
    4d0a:	89fb      	ldrh	r3, [r7, #14]
}
    4d0c:	4618      	mov	r0, r3
    4d0e:	3710      	adds	r7, #16
    4d10:	46bd      	mov	sp, r7
    4d12:	bd80      	pop	{r7, pc}
    4d14:	00004c6d 	.word	0x00004c6d

00004d18 <hri_adc_write_CTRLA_reg>:

static inline void hri_adc_write_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t data)
{
    4d18:	b580      	push	{r7, lr}
    4d1a:	b082      	sub	sp, #8
    4d1c:	af00      	add	r7, sp, #0
    4d1e:	6078      	str	r0, [r7, #4]
    4d20:	460b      	mov	r3, r1
    4d22:	807b      	strh	r3, [r7, #2]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg = data;
    4d24:	687b      	ldr	r3, [r7, #4]
    4d26:	887a      	ldrh	r2, [r7, #2]
    4d28:	801a      	strh	r2, [r3, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
    4d2a:	2103      	movs	r1, #3
    4d2c:	6878      	ldr	r0, [r7, #4]
    4d2e:	4b03      	ldr	r3, [pc, #12]	; (4d3c <hri_adc_write_CTRLA_reg+0x24>)
    4d30:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    4d32:	bf00      	nop
    4d34:	3708      	adds	r7, #8
    4d36:	46bd      	mov	sp, r7
    4d38:	bd80      	pop	{r7, pc}
    4d3a:	bf00      	nop
    4d3c:	00004c6d 	.word	0x00004c6d

00004d40 <hri_adc_write_EVCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_EVCTRL_reg(const void *const hw, hri_adc_evctrl_reg_t data)
{
    4d40:	b480      	push	{r7}
    4d42:	b083      	sub	sp, #12
    4d44:	af00      	add	r7, sp, #0
    4d46:	6078      	str	r0, [r7, #4]
    4d48:	460b      	mov	r3, r1
    4d4a:	70fb      	strb	r3, [r7, #3]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->EVCTRL.reg = data;
    4d4c:	687b      	ldr	r3, [r7, #4]
    4d4e:	78fa      	ldrb	r2, [r7, #3]
    4d50:	709a      	strb	r2, [r3, #2]
	ADC_CRITICAL_SECTION_LEAVE();
}
    4d52:	bf00      	nop
    4d54:	370c      	adds	r7, #12
    4d56:	46bd      	mov	sp, r7
    4d58:	f85d 7b04 	ldr.w	r7, [sp], #4
    4d5c:	4770      	bx	lr

00004d5e <hri_adc_write_DBGCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_DBGCTRL_reg(const void *const hw, hri_adc_dbgctrl_reg_t data)
{
    4d5e:	b480      	push	{r7}
    4d60:	b083      	sub	sp, #12
    4d62:	af00      	add	r7, sp, #0
    4d64:	6078      	str	r0, [r7, #4]
    4d66:	460b      	mov	r3, r1
    4d68:	70fb      	strb	r3, [r7, #3]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->DBGCTRL.reg = data;
    4d6a:	687b      	ldr	r3, [r7, #4]
    4d6c:	78fa      	ldrb	r2, [r7, #3]
    4d6e:	70da      	strb	r2, [r3, #3]
	ADC_CRITICAL_SECTION_LEAVE();
}
    4d70:	bf00      	nop
    4d72:	370c      	adds	r7, #12
    4d74:	46bd      	mov	sp, r7
    4d76:	f85d 7b04 	ldr.w	r7, [sp], #4
    4d7a:	4770      	bx	lr

00004d7c <hri_adc_write_INPUTCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_INPUTCTRL_reg(const void *const hw, hri_adc_inputctrl_reg_t data)
{
    4d7c:	b580      	push	{r7, lr}
    4d7e:	b082      	sub	sp, #8
    4d80:	af00      	add	r7, sp, #0
    4d82:	6078      	str	r0, [r7, #4]
    4d84:	460b      	mov	r3, r1
    4d86:	807b      	strh	r3, [r7, #2]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->INPUTCTRL.reg = data;
    4d88:	687b      	ldr	r3, [r7, #4]
    4d8a:	887a      	ldrh	r2, [r7, #2]
    4d8c:	809a      	strh	r2, [r3, #4]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
    4d8e:	f640 71ff 	movw	r1, #4095	; 0xfff
    4d92:	6878      	ldr	r0, [r7, #4]
    4d94:	4b02      	ldr	r3, [pc, #8]	; (4da0 <hri_adc_write_INPUTCTRL_reg+0x24>)
    4d96:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    4d98:	bf00      	nop
    4d9a:	3708      	adds	r7, #8
    4d9c:	46bd      	mov	sp, r7
    4d9e:	bd80      	pop	{r7, pc}
    4da0:	00004c6d 	.word	0x00004c6d

00004da4 <hri_adc_write_CTRLB_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_CTRLB_reg(const void *const hw, hri_adc_ctrlb_reg_t data)
{
    4da4:	b580      	push	{r7, lr}
    4da6:	b082      	sub	sp, #8
    4da8:	af00      	add	r7, sp, #0
    4daa:	6078      	str	r0, [r7, #4]
    4dac:	460b      	mov	r3, r1
    4dae:	807b      	strh	r3, [r7, #2]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLB.reg = data;
    4db0:	687b      	ldr	r3, [r7, #4]
    4db2:	887a      	ldrh	r2, [r7, #2]
    4db4:	80da      	strh	r2, [r3, #6]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
    4db6:	f640 71ff 	movw	r1, #4095	; 0xfff
    4dba:	6878      	ldr	r0, [r7, #4]
    4dbc:	4b02      	ldr	r3, [pc, #8]	; (4dc8 <hri_adc_write_CTRLB_reg+0x24>)
    4dbe:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    4dc0:	bf00      	nop
    4dc2:	3708      	adds	r7, #8
    4dc4:	46bd      	mov	sp, r7
    4dc6:	bd80      	pop	{r7, pc}
    4dc8:	00004c6d 	.word	0x00004c6d

00004dcc <hri_adc_write_REFCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_REFCTRL_reg(const void *const hw, hri_adc_refctrl_reg_t data)
{
    4dcc:	b580      	push	{r7, lr}
    4dce:	b082      	sub	sp, #8
    4dd0:	af00      	add	r7, sp, #0
    4dd2:	6078      	str	r0, [r7, #4]
    4dd4:	460b      	mov	r3, r1
    4dd6:	70fb      	strb	r3, [r7, #3]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->REFCTRL.reg = data;
    4dd8:	687b      	ldr	r3, [r7, #4]
    4dda:	78fa      	ldrb	r2, [r7, #3]
    4ddc:	721a      	strb	r2, [r3, #8]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
    4dde:	f640 71ff 	movw	r1, #4095	; 0xfff
    4de2:	6878      	ldr	r0, [r7, #4]
    4de4:	4b02      	ldr	r3, [pc, #8]	; (4df0 <hri_adc_write_REFCTRL_reg+0x24>)
    4de6:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    4de8:	bf00      	nop
    4dea:	3708      	adds	r7, #8
    4dec:	46bd      	mov	sp, r7
    4dee:	bd80      	pop	{r7, pc}
    4df0:	00004c6d 	.word	0x00004c6d

00004df4 <hri_adc_write_AVGCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_AVGCTRL_reg(const void *const hw, hri_adc_avgctrl_reg_t data)
{
    4df4:	b580      	push	{r7, lr}
    4df6:	b082      	sub	sp, #8
    4df8:	af00      	add	r7, sp, #0
    4dfa:	6078      	str	r0, [r7, #4]
    4dfc:	460b      	mov	r3, r1
    4dfe:	70fb      	strb	r3, [r7, #3]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->AVGCTRL.reg = data;
    4e00:	687b      	ldr	r3, [r7, #4]
    4e02:	78fa      	ldrb	r2, [r7, #3]
    4e04:	729a      	strb	r2, [r3, #10]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
    4e06:	f640 71ff 	movw	r1, #4095	; 0xfff
    4e0a:	6878      	ldr	r0, [r7, #4]
    4e0c:	4b02      	ldr	r3, [pc, #8]	; (4e18 <hri_adc_write_AVGCTRL_reg+0x24>)
    4e0e:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    4e10:	bf00      	nop
    4e12:	3708      	adds	r7, #8
    4e14:	46bd      	mov	sp, r7
    4e16:	bd80      	pop	{r7, pc}
    4e18:	00004c6d 	.word	0x00004c6d

00004e1c <hri_adc_write_SAMPCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_SAMPCTRL_reg(const void *const hw, hri_adc_sampctrl_reg_t data)
{
    4e1c:	b580      	push	{r7, lr}
    4e1e:	b082      	sub	sp, #8
    4e20:	af00      	add	r7, sp, #0
    4e22:	6078      	str	r0, [r7, #4]
    4e24:	460b      	mov	r3, r1
    4e26:	70fb      	strb	r3, [r7, #3]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->SAMPCTRL.reg = data;
    4e28:	687b      	ldr	r3, [r7, #4]
    4e2a:	78fa      	ldrb	r2, [r7, #3]
    4e2c:	72da      	strb	r2, [r3, #11]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
    4e2e:	f640 71ff 	movw	r1, #4095	; 0xfff
    4e32:	6878      	ldr	r0, [r7, #4]
    4e34:	4b02      	ldr	r3, [pc, #8]	; (4e40 <hri_adc_write_SAMPCTRL_reg+0x24>)
    4e36:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    4e38:	bf00      	nop
    4e3a:	3708      	adds	r7, #8
    4e3c:	46bd      	mov	sp, r7
    4e3e:	bd80      	pop	{r7, pc}
    4e40:	00004c6d 	.word	0x00004c6d

00004e44 <hri_adc_write_WINLT_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_WINLT_reg(const void *const hw, hri_adc_winlt_reg_t data)
{
    4e44:	b580      	push	{r7, lr}
    4e46:	b082      	sub	sp, #8
    4e48:	af00      	add	r7, sp, #0
    4e4a:	6078      	str	r0, [r7, #4]
    4e4c:	460b      	mov	r3, r1
    4e4e:	807b      	strh	r3, [r7, #2]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->WINLT.reg = data;
    4e50:	687b      	ldr	r3, [r7, #4]
    4e52:	887a      	ldrh	r2, [r7, #2]
    4e54:	819a      	strh	r2, [r3, #12]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_WINLT);
    4e56:	2180      	movs	r1, #128	; 0x80
    4e58:	6878      	ldr	r0, [r7, #4]
    4e5a:	4b03      	ldr	r3, [pc, #12]	; (4e68 <hri_adc_write_WINLT_reg+0x24>)
    4e5c:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    4e5e:	bf00      	nop
    4e60:	3708      	adds	r7, #8
    4e62:	46bd      	mov	sp, r7
    4e64:	bd80      	pop	{r7, pc}
    4e66:	bf00      	nop
    4e68:	00004c6d 	.word	0x00004c6d

00004e6c <hri_adc_write_WINUT_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_WINUT_reg(const void *const hw, hri_adc_winut_reg_t data)
{
    4e6c:	b580      	push	{r7, lr}
    4e6e:	b082      	sub	sp, #8
    4e70:	af00      	add	r7, sp, #0
    4e72:	6078      	str	r0, [r7, #4]
    4e74:	460b      	mov	r3, r1
    4e76:	807b      	strh	r3, [r7, #2]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->WINUT.reg = data;
    4e78:	687b      	ldr	r3, [r7, #4]
    4e7a:	887a      	ldrh	r2, [r7, #2]
    4e7c:	81da      	strh	r2, [r3, #14]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_WINUT);
    4e7e:	f44f 7180 	mov.w	r1, #256	; 0x100
    4e82:	6878      	ldr	r0, [r7, #4]
    4e84:	4b02      	ldr	r3, [pc, #8]	; (4e90 <hri_adc_write_WINUT_reg+0x24>)
    4e86:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    4e88:	bf00      	nop
    4e8a:	3708      	adds	r7, #8
    4e8c:	46bd      	mov	sp, r7
    4e8e:	bd80      	pop	{r7, pc}
    4e90:	00004c6d 	.word	0x00004c6d

00004e94 <hri_adc_write_GAINCORR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_GAINCORR_reg(const void *const hw, hri_adc_gaincorr_reg_t data)
{
    4e94:	b580      	push	{r7, lr}
    4e96:	b082      	sub	sp, #8
    4e98:	af00      	add	r7, sp, #0
    4e9a:	6078      	str	r0, [r7, #4]
    4e9c:	460b      	mov	r3, r1
    4e9e:	807b      	strh	r3, [r7, #2]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->GAINCORR.reg = data;
    4ea0:	687b      	ldr	r3, [r7, #4]
    4ea2:	887a      	ldrh	r2, [r7, #2]
    4ea4:	821a      	strh	r2, [r3, #16]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_GAINCORR);
    4ea6:	f44f 7100 	mov.w	r1, #512	; 0x200
    4eaa:	6878      	ldr	r0, [r7, #4]
    4eac:	4b02      	ldr	r3, [pc, #8]	; (4eb8 <hri_adc_write_GAINCORR_reg+0x24>)
    4eae:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    4eb0:	bf00      	nop
    4eb2:	3708      	adds	r7, #8
    4eb4:	46bd      	mov	sp, r7
    4eb6:	bd80      	pop	{r7, pc}
    4eb8:	00004c6d 	.word	0x00004c6d

00004ebc <hri_adc_write_OFFSETCORR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_OFFSETCORR_reg(const void *const hw, hri_adc_offsetcorr_reg_t data)
{
    4ebc:	b580      	push	{r7, lr}
    4ebe:	b082      	sub	sp, #8
    4ec0:	af00      	add	r7, sp, #0
    4ec2:	6078      	str	r0, [r7, #4]
    4ec4:	460b      	mov	r3, r1
    4ec6:	807b      	strh	r3, [r7, #2]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->OFFSETCORR.reg = data;
    4ec8:	687b      	ldr	r3, [r7, #4]
    4eca:	887a      	ldrh	r2, [r7, #2]
    4ecc:	825a      	strh	r2, [r3, #18]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_OFFSETCORR);
    4ece:	f44f 6180 	mov.w	r1, #1024	; 0x400
    4ed2:	6878      	ldr	r0, [r7, #4]
    4ed4:	4b02      	ldr	r3, [pc, #8]	; (4ee0 <hri_adc_write_OFFSETCORR_reg+0x24>)
    4ed6:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    4ed8:	bf00      	nop
    4eda:	3708      	adds	r7, #8
    4edc:	46bd      	mov	sp, r7
    4ede:	bd80      	pop	{r7, pc}
    4ee0:	00004c6d 	.word	0x00004c6d

00004ee4 <hri_adc_write_CALIB_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_CALIB_reg(const void *const hw, hri_adc_calib_reg_t data)
{
    4ee4:	b480      	push	{r7}
    4ee6:	b083      	sub	sp, #12
    4ee8:	af00      	add	r7, sp, #0
    4eea:	6078      	str	r0, [r7, #4]
    4eec:	460b      	mov	r3, r1
    4eee:	807b      	strh	r3, [r7, #2]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CALIB.reg = data;
    4ef0:	687b      	ldr	r3, [r7, #4]
    4ef2:	887a      	ldrh	r2, [r7, #2]
    4ef4:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
	ADC_CRITICAL_SECTION_LEAVE();
}
    4ef8:	bf00      	nop
    4efa:	370c      	adds	r7, #12
    4efc:	46bd      	mov	sp, r7
    4efe:	f85d 7b04 	ldr.w	r7, [sp], #4
    4f02:	4770      	bx	lr

00004f04 <_adc_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given adc hardware instance
 */
static uint8_t _adc_get_hardware_index(const void *const hw)
{
    4f04:	b480      	push	{r7}
    4f06:	b083      	sub	sp, #12
    4f08:	af00      	add	r7, sp, #0
    4f0a:	6078      	str	r0, [r7, #4]
	return ((uint32_t)hw - (uint32_t)ADC0) >> 10;
    4f0c:	687b      	ldr	r3, [r7, #4]
    4f0e:	f103 433d 	add.w	r3, r3, #3170893824	; 0xbd000000
    4f12:	f5a3 53e0 	sub.w	r3, r3, #7168	; 0x1c00
    4f16:	0a9b      	lsrs	r3, r3, #10
    4f18:	b2db      	uxtb	r3, r3
}
    4f1a:	4618      	mov	r0, r3
    4f1c:	370c      	adds	r7, #12
    4f1e:	46bd      	mov	sp, r7
    4f20:	f85d 7b04 	ldr.w	r7, [sp], #4
    4f24:	4770      	bx	lr
	...

00004f28 <_adc_get_regs>:
/** \brief Return the pointer to register settings of specific ADC
 *  \param[in] hw_addr The hardware register base address.
 *  \return Pointer to register settings of specific ADC.
 */
static uint8_t _adc_get_regs(const uint32_t hw_addr)
{
    4f28:	b580      	push	{r7, lr}
    4f2a:	b084      	sub	sp, #16
    4f2c:	af00      	add	r7, sp, #0
    4f2e:	6078      	str	r0, [r7, #4]
	uint8_t n = _adc_get_hardware_index((const void *)hw_addr);
    4f30:	687b      	ldr	r3, [r7, #4]
    4f32:	4618      	mov	r0, r3
    4f34:	4b11      	ldr	r3, [pc, #68]	; (4f7c <_adc_get_regs+0x54>)
    4f36:	4798      	blx	r3
    4f38:	4603      	mov	r3, r0
    4f3a:	73bb      	strb	r3, [r7, #14]
	uint8_t i;

	for (i = 0; i < sizeof(_adcs) / sizeof(struct adc_configuration); i++) {
    4f3c:	2300      	movs	r3, #0
    4f3e:	73fb      	strb	r3, [r7, #15]
    4f40:	e00e      	b.n	4f60 <_adc_get_regs+0x38>
		if (_adcs[i].number == n) {
    4f42:	7bfb      	ldrb	r3, [r7, #15]
    4f44:	4a0e      	ldr	r2, [pc, #56]	; (4f80 <_adc_get_regs+0x58>)
    4f46:	2116      	movs	r1, #22
    4f48:	fb01 f303 	mul.w	r3, r1, r3
    4f4c:	4413      	add	r3, r2
    4f4e:	781b      	ldrb	r3, [r3, #0]
    4f50:	7bba      	ldrb	r2, [r7, #14]
    4f52:	429a      	cmp	r2, r3
    4f54:	d101      	bne.n	4f5a <_adc_get_regs+0x32>
			return i;
    4f56:	7bfb      	ldrb	r3, [r7, #15]
    4f58:	e00b      	b.n	4f72 <_adc_get_regs+0x4a>
	for (i = 0; i < sizeof(_adcs) / sizeof(struct adc_configuration); i++) {
    4f5a:	7bfb      	ldrb	r3, [r7, #15]
    4f5c:	3301      	adds	r3, #1
    4f5e:	73fb      	strb	r3, [r7, #15]
    4f60:	7bfb      	ldrb	r3, [r7, #15]
    4f62:	2b01      	cmp	r3, #1
    4f64:	d9ed      	bls.n	4f42 <_adc_get_regs+0x1a>
		}
	}

	ASSERT(false);
    4f66:	2288      	movs	r2, #136	; 0x88
    4f68:	4906      	ldr	r1, [pc, #24]	; (4f84 <_adc_get_regs+0x5c>)
    4f6a:	2000      	movs	r0, #0
    4f6c:	4b06      	ldr	r3, [pc, #24]	; (4f88 <_adc_get_regs+0x60>)
    4f6e:	4798      	blx	r3
	return 0;
    4f70:	2300      	movs	r3, #0
}
    4f72:	4618      	mov	r0, r3
    4f74:	3710      	adds	r7, #16
    4f76:	46bd      	mov	sp, r7
    4f78:	bd80      	pop	{r7, pc}
    4f7a:	bf00      	nop
    4f7c:	00004f05 	.word	0x00004f05
    4f80:	0000566c 	.word	0x0000566c
    4f84:	00005698 	.word	0x00005698
    4f88:	00001c39 	.word	0x00001c39

00004f8c <_adc_init>:
 *
 * \param[in] hw The pointer to hardware instance
 * \param[in] i The number of hardware instance
 */
static int32_t _adc_init(void *const hw, const uint8_t i)
{
    4f8c:	b580      	push	{r7, lr}
    4f8e:	b084      	sub	sp, #16
    4f90:	af00      	add	r7, sp, #0
    4f92:	6078      	str	r0, [r7, #4]
    4f94:	460b      	mov	r3, r1
    4f96:	70fb      	strb	r3, [r7, #3]
	uint16_t calib_reg = 0;
    4f98:	2300      	movs	r3, #0
    4f9a:	81fb      	strh	r3, [r7, #14]
	if (hw == ADC0) {
    4f9c:	687b      	ldr	r3, [r7, #4]
    4f9e:	4a81      	ldr	r2, [pc, #516]	; (51a4 <_adc_init+0x218>)
    4fa0:	4293      	cmp	r3, r2
    4fa2:	d120      	bne.n	4fe6 <_adc_init+0x5a>
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC0_FUSES_BIASREFBUF_ADDR >> ADC0_FUSES_BIASREFBUF_Pos))
    4fa4:	f04f 1380 	mov.w	r3, #8388736	; 0x800080
    4fa8:	681b      	ldr	r3, [r3, #0]
    4faa:	095b      	lsrs	r3, r3, #5
    4fac:	b29b      	uxth	r3, r3
    4fae:	021b      	lsls	r3, r3, #8
    4fb0:	b29b      	uxth	r3, r3
    4fb2:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    4fb6:	b29a      	uxth	r2, r3
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC0_FUSES_BIASR2R_ADDR >> ADC0_FUSES_BIASR2R_Pos))
    4fb8:	f04f 1380 	mov.w	r3, #8388736	; 0x800080
    4fbc:	681b      	ldr	r3, [r3, #0]
    4fbe:	0a1b      	lsrs	r3, r3, #8
    4fc0:	b29b      	uxth	r3, r3
    4fc2:	011b      	lsls	r3, r3, #4
    4fc4:	b29b      	uxth	r3, r3
    4fc6:	f003 0370 	and.w	r3, r3, #112	; 0x70
    4fca:	b29b      	uxth	r3, r3
    4fcc:	4313      	orrs	r3, r2
    4fce:	b29a      	uxth	r2, r3
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC0_FUSES_BIASCOMP_ADDR >> ADC0_FUSES_BIASCOMP_Pos));
    4fd0:	f04f 1380 	mov.w	r3, #8388736	; 0x800080
    4fd4:	681b      	ldr	r3, [r3, #0]
    4fd6:	089b      	lsrs	r3, r3, #2
    4fd8:	b29b      	uxth	r3, r3
    4fda:	f003 0307 	and.w	r3, r3, #7
    4fde:	b29b      	uxth	r3, r3
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC0_FUSES_BIASREFBUF_ADDR >> ADC0_FUSES_BIASREFBUF_Pos))
    4fe0:	4313      	orrs	r3, r2
    4fe2:	81fb      	strh	r3, [r7, #14]
    4fe4:	e023      	b.n	502e <_adc_init+0xa2>
	} else if (hw == ADC1) {
    4fe6:	687b      	ldr	r3, [r7, #4]
    4fe8:	4a6f      	ldr	r2, [pc, #444]	; (51a8 <_adc_init+0x21c>)
    4fea:	4293      	cmp	r3, r2
    4fec:	d11f      	bne.n	502e <_adc_init+0xa2>
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
    4fee:	f04f 1380 	mov.w	r3, #8388736	; 0x800080
    4ff2:	681b      	ldr	r3, [r3, #0]
    4ff4:	0cdb      	lsrs	r3, r3, #19
    4ff6:	b29b      	uxth	r3, r3
    4ff8:	021b      	lsls	r3, r3, #8
    4ffa:	b29b      	uxth	r3, r3
    4ffc:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    5000:	b29a      	uxth	r2, r3
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC1_FUSES_BIASR2R_ADDR >> ADC1_FUSES_BIASR2R_Pos))
    5002:	f04f 1380 	mov.w	r3, #8388736	; 0x800080
    5006:	681b      	ldr	r3, [r3, #0]
    5008:	0d9b      	lsrs	r3, r3, #22
    500a:	b29b      	uxth	r3, r3
    500c:	011b      	lsls	r3, r3, #4
    500e:	b29b      	uxth	r3, r3
    5010:	f003 0370 	and.w	r3, r3, #112	; 0x70
    5014:	b29b      	uxth	r3, r3
    5016:	4313      	orrs	r3, r2
    5018:	b29a      	uxth	r2, r3
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC1_FUSES_BIASCOMP_ADDR >> ADC1_FUSES_BIASCOMP_Pos));
    501a:	f04f 1380 	mov.w	r3, #8388736	; 0x800080
    501e:	681b      	ldr	r3, [r3, #0]
    5020:	0c1b      	lsrs	r3, r3, #16
    5022:	b29b      	uxth	r3, r3
    5024:	f003 0307 	and.w	r3, r3, #7
    5028:	b29b      	uxth	r3, r3
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
    502a:	4313      	orrs	r3, r2
    502c:	81fb      	strh	r3, [r7, #14]
	}

	if (!hri_adc_is_syncing(hw, ADC_SYNCBUSY_SWRST)) {
    502e:	2101      	movs	r1, #1
    5030:	6878      	ldr	r0, [r7, #4]
    5032:	4b5e      	ldr	r3, [pc, #376]	; (51ac <_adc_init+0x220>)
    5034:	4798      	blx	r3
    5036:	4603      	mov	r3, r0
    5038:	f083 0301 	eor.w	r3, r3, #1
    503c:	b2db      	uxtb	r3, r3
    503e:	2b00      	cmp	r3, #0
    5040:	d011      	beq.n	5066 <_adc_init+0xda>
		if (hri_adc_get_CTRLA_reg(hw, ADC_CTRLA_ENABLE)) {
    5042:	2102      	movs	r1, #2
    5044:	6878      	ldr	r0, [r7, #4]
    5046:	4b5a      	ldr	r3, [pc, #360]	; (51b0 <_adc_init+0x224>)
    5048:	4798      	blx	r3
    504a:	4603      	mov	r3, r0
    504c:	2b00      	cmp	r3, #0
    504e:	d006      	beq.n	505e <_adc_init+0xd2>
			hri_adc_clear_CTRLA_ENABLE_bit(hw);
    5050:	6878      	ldr	r0, [r7, #4]
    5052:	4b58      	ldr	r3, [pc, #352]	; (51b4 <_adc_init+0x228>)
    5054:	4798      	blx	r3
			hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_ENABLE);
    5056:	2102      	movs	r1, #2
    5058:	6878      	ldr	r0, [r7, #4]
    505a:	4b57      	ldr	r3, [pc, #348]	; (51b8 <_adc_init+0x22c>)
    505c:	4798      	blx	r3
		}
		hri_adc_write_CTRLA_reg(hw, ADC_CTRLA_SWRST);
    505e:	2101      	movs	r1, #1
    5060:	6878      	ldr	r0, [r7, #4]
    5062:	4b56      	ldr	r3, [pc, #344]	; (51bc <_adc_init+0x230>)
    5064:	4798      	blx	r3
	}
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST);
    5066:	2101      	movs	r1, #1
    5068:	6878      	ldr	r0, [r7, #4]
    506a:	4b53      	ldr	r3, [pc, #332]	; (51b8 <_adc_init+0x22c>)
    506c:	4798      	blx	r3

	hri_adc_write_CALIB_reg(hw, calib_reg);
    506e:	89fb      	ldrh	r3, [r7, #14]
    5070:	4619      	mov	r1, r3
    5072:	6878      	ldr	r0, [r7, #4]
    5074:	4b52      	ldr	r3, [pc, #328]	; (51c0 <_adc_init+0x234>)
    5076:	4798      	blx	r3
	hri_adc_write_CTRLB_reg(hw, _adcs[i].ctrl_b);
    5078:	78fb      	ldrb	r3, [r7, #3]
    507a:	4a52      	ldr	r2, [pc, #328]	; (51c4 <_adc_init+0x238>)
    507c:	2116      	movs	r1, #22
    507e:	fb01 f303 	mul.w	r3, r1, r3
    5082:	4413      	add	r3, r2
    5084:	3304      	adds	r3, #4
    5086:	881b      	ldrh	r3, [r3, #0]
    5088:	4619      	mov	r1, r3
    508a:	6878      	ldr	r0, [r7, #4]
    508c:	4b4e      	ldr	r3, [pc, #312]	; (51c8 <_adc_init+0x23c>)
    508e:	4798      	blx	r3
	hri_adc_write_REFCTRL_reg(hw, _adcs[i].ref_ctrl);
    5090:	78fb      	ldrb	r3, [r7, #3]
    5092:	4a4c      	ldr	r2, [pc, #304]	; (51c4 <_adc_init+0x238>)
    5094:	2116      	movs	r1, #22
    5096:	fb01 f303 	mul.w	r3, r1, r3
    509a:	4413      	add	r3, r2
    509c:	3306      	adds	r3, #6
    509e:	781b      	ldrb	r3, [r3, #0]
    50a0:	4619      	mov	r1, r3
    50a2:	6878      	ldr	r0, [r7, #4]
    50a4:	4b49      	ldr	r3, [pc, #292]	; (51cc <_adc_init+0x240>)
    50a6:	4798      	blx	r3
	hri_adc_write_EVCTRL_reg(hw, _adcs[i].ev_ctrl);
    50a8:	78fb      	ldrb	r3, [r7, #3]
    50aa:	4a46      	ldr	r2, [pc, #280]	; (51c4 <_adc_init+0x238>)
    50ac:	2116      	movs	r1, #22
    50ae:	fb01 f303 	mul.w	r3, r1, r3
    50b2:	4413      	add	r3, r2
    50b4:	3307      	adds	r3, #7
    50b6:	781b      	ldrb	r3, [r3, #0]
    50b8:	4619      	mov	r1, r3
    50ba:	6878      	ldr	r0, [r7, #4]
    50bc:	4b44      	ldr	r3, [pc, #272]	; (51d0 <_adc_init+0x244>)
    50be:	4798      	blx	r3
	hri_adc_write_INPUTCTRL_reg(hw, _adcs[i].input_ctrl);
    50c0:	78fb      	ldrb	r3, [r7, #3]
    50c2:	4a40      	ldr	r2, [pc, #256]	; (51c4 <_adc_init+0x238>)
    50c4:	2116      	movs	r1, #22
    50c6:	fb01 f303 	mul.w	r3, r1, r3
    50ca:	4413      	add	r3, r2
    50cc:	3308      	adds	r3, #8
    50ce:	881b      	ldrh	r3, [r3, #0]
    50d0:	4619      	mov	r1, r3
    50d2:	6878      	ldr	r0, [r7, #4]
    50d4:	4b3f      	ldr	r3, [pc, #252]	; (51d4 <_adc_init+0x248>)
    50d6:	4798      	blx	r3
	hri_adc_write_AVGCTRL_reg(hw, _adcs[i].avg_ctrl);
    50d8:	78fb      	ldrb	r3, [r7, #3]
    50da:	4a3a      	ldr	r2, [pc, #232]	; (51c4 <_adc_init+0x238>)
    50dc:	2116      	movs	r1, #22
    50de:	fb01 f303 	mul.w	r3, r1, r3
    50e2:	4413      	add	r3, r2
    50e4:	330a      	adds	r3, #10
    50e6:	781b      	ldrb	r3, [r3, #0]
    50e8:	4619      	mov	r1, r3
    50ea:	6878      	ldr	r0, [r7, #4]
    50ec:	4b3a      	ldr	r3, [pc, #232]	; (51d8 <_adc_init+0x24c>)
    50ee:	4798      	blx	r3
	hri_adc_write_SAMPCTRL_reg(hw, _adcs[i].samp_ctrl);
    50f0:	78fb      	ldrb	r3, [r7, #3]
    50f2:	4a34      	ldr	r2, [pc, #208]	; (51c4 <_adc_init+0x238>)
    50f4:	2116      	movs	r1, #22
    50f6:	fb01 f303 	mul.w	r3, r1, r3
    50fa:	4413      	add	r3, r2
    50fc:	330b      	adds	r3, #11
    50fe:	781b      	ldrb	r3, [r3, #0]
    5100:	4619      	mov	r1, r3
    5102:	6878      	ldr	r0, [r7, #4]
    5104:	4b35      	ldr	r3, [pc, #212]	; (51dc <_adc_init+0x250>)
    5106:	4798      	blx	r3
	hri_adc_write_WINLT_reg(hw, _adcs[i].win_lt);
    5108:	78fb      	ldrb	r3, [r7, #3]
    510a:	4a2e      	ldr	r2, [pc, #184]	; (51c4 <_adc_init+0x238>)
    510c:	2116      	movs	r1, #22
    510e:	fb01 f303 	mul.w	r3, r1, r3
    5112:	4413      	add	r3, r2
    5114:	330c      	adds	r3, #12
    5116:	881b      	ldrh	r3, [r3, #0]
    5118:	4619      	mov	r1, r3
    511a:	6878      	ldr	r0, [r7, #4]
    511c:	4b30      	ldr	r3, [pc, #192]	; (51e0 <_adc_init+0x254>)
    511e:	4798      	blx	r3
	hri_adc_write_WINUT_reg(hw, _adcs[i].win_ut);
    5120:	78fb      	ldrb	r3, [r7, #3]
    5122:	4a28      	ldr	r2, [pc, #160]	; (51c4 <_adc_init+0x238>)
    5124:	2116      	movs	r1, #22
    5126:	fb01 f303 	mul.w	r3, r1, r3
    512a:	4413      	add	r3, r2
    512c:	330e      	adds	r3, #14
    512e:	881b      	ldrh	r3, [r3, #0]
    5130:	4619      	mov	r1, r3
    5132:	6878      	ldr	r0, [r7, #4]
    5134:	4b2b      	ldr	r3, [pc, #172]	; (51e4 <_adc_init+0x258>)
    5136:	4798      	blx	r3
	hri_adc_write_GAINCORR_reg(hw, _adcs[i].gain_corr);
    5138:	78fb      	ldrb	r3, [r7, #3]
    513a:	4a22      	ldr	r2, [pc, #136]	; (51c4 <_adc_init+0x238>)
    513c:	2116      	movs	r1, #22
    513e:	fb01 f303 	mul.w	r3, r1, r3
    5142:	4413      	add	r3, r2
    5144:	3310      	adds	r3, #16
    5146:	881b      	ldrh	r3, [r3, #0]
    5148:	4619      	mov	r1, r3
    514a:	6878      	ldr	r0, [r7, #4]
    514c:	4b26      	ldr	r3, [pc, #152]	; (51e8 <_adc_init+0x25c>)
    514e:	4798      	blx	r3
	hri_adc_write_OFFSETCORR_reg(hw, _adcs[i].offset_corr);
    5150:	78fb      	ldrb	r3, [r7, #3]
    5152:	4a1c      	ldr	r2, [pc, #112]	; (51c4 <_adc_init+0x238>)
    5154:	2116      	movs	r1, #22
    5156:	fb01 f303 	mul.w	r3, r1, r3
    515a:	4413      	add	r3, r2
    515c:	3312      	adds	r3, #18
    515e:	881b      	ldrh	r3, [r3, #0]
    5160:	4619      	mov	r1, r3
    5162:	6878      	ldr	r0, [r7, #4]
    5164:	4b21      	ldr	r3, [pc, #132]	; (51ec <_adc_init+0x260>)
    5166:	4798      	blx	r3
	hri_adc_write_DBGCTRL_reg(hw, _adcs[i].dbg_ctrl);
    5168:	78fb      	ldrb	r3, [r7, #3]
    516a:	4a16      	ldr	r2, [pc, #88]	; (51c4 <_adc_init+0x238>)
    516c:	2116      	movs	r1, #22
    516e:	fb01 f303 	mul.w	r3, r1, r3
    5172:	4413      	add	r3, r2
    5174:	3314      	adds	r3, #20
    5176:	781b      	ldrb	r3, [r3, #0]
    5178:	4619      	mov	r1, r3
    517a:	6878      	ldr	r0, [r7, #4]
    517c:	4b1c      	ldr	r3, [pc, #112]	; (51f0 <_adc_init+0x264>)
    517e:	4798      	blx	r3
	hri_adc_write_CTRLA_reg(hw, _adcs[i].ctrl_a);
    5180:	78fb      	ldrb	r3, [r7, #3]
    5182:	4a10      	ldr	r2, [pc, #64]	; (51c4 <_adc_init+0x238>)
    5184:	2116      	movs	r1, #22
    5186:	fb01 f303 	mul.w	r3, r1, r3
    518a:	4413      	add	r3, r2
    518c:	3302      	adds	r3, #2
    518e:	881b      	ldrh	r3, [r3, #0]
    5190:	4619      	mov	r1, r3
    5192:	6878      	ldr	r0, [r7, #4]
    5194:	4b09      	ldr	r3, [pc, #36]	; (51bc <_adc_init+0x230>)
    5196:	4798      	blx	r3

	return ERR_NONE;
    5198:	2300      	movs	r3, #0
}
    519a:	4618      	mov	r0, r3
    519c:	3710      	adds	r7, #16
    519e:	46bd      	mov	sp, r7
    51a0:	bd80      	pop	{r7, pc}
    51a2:	bf00      	nop
    51a4:	43001c00 	.word	0x43001c00
    51a8:	43002000 	.word	0x43002000
    51ac:	00004c93 	.word	0x00004c93
    51b0:	00004ce9 	.word	0x00004ce9
    51b4:	00004cbd 	.word	0x00004cbd
    51b8:	00004c6d 	.word	0x00004c6d
    51bc:	00004d19 	.word	0x00004d19
    51c0:	00004ee5 	.word	0x00004ee5
    51c4:	0000566c 	.word	0x0000566c
    51c8:	00004da5 	.word	0x00004da5
    51cc:	00004dcd 	.word	0x00004dcd
    51d0:	00004d41 	.word	0x00004d41
    51d4:	00004d7d 	.word	0x00004d7d
    51d8:	00004df5 	.word	0x00004df5
    51dc:	00004e1d 	.word	0x00004e1d
    51e0:	00004e45 	.word	0x00004e45
    51e4:	00004e6d 	.word	0x00004e6d
    51e8:	00004e95 	.word	0x00004e95
    51ec:	00004ebd 	.word	0x00004ebd
    51f0:	00004d5f 	.word	0x00004d5f

000051f4 <_adc_sync_init>:

/**
 * \brief Initialize ADC
 */
int32_t _adc_sync_init(struct _adc_sync_device *const device, void *const hw)
{
    51f4:	b580      	push	{r7, lr}
    51f6:	b082      	sub	sp, #8
    51f8:	af00      	add	r7, sp, #0
    51fa:	6078      	str	r0, [r7, #4]
    51fc:	6039      	str	r1, [r7, #0]
	ASSERT(device);
    51fe:	687b      	ldr	r3, [r7, #4]
    5200:	2b00      	cmp	r3, #0
    5202:	bf14      	ite	ne
    5204:	2301      	movne	r3, #1
    5206:	2300      	moveq	r3, #0
    5208:	b2db      	uxtb	r3, r3
    520a:	22d9      	movs	r2, #217	; 0xd9
    520c:	490a      	ldr	r1, [pc, #40]	; (5238 <_adc_sync_init+0x44>)
    520e:	4618      	mov	r0, r3
    5210:	4b0a      	ldr	r3, [pc, #40]	; (523c <_adc_sync_init+0x48>)
    5212:	4798      	blx	r3

	device->hw = hw;
    5214:	687b      	ldr	r3, [r7, #4]
    5216:	683a      	ldr	r2, [r7, #0]
    5218:	601a      	str	r2, [r3, #0]

	return _adc_init(hw, _adc_get_regs((uint32_t)hw));
    521a:	683b      	ldr	r3, [r7, #0]
    521c:	4618      	mov	r0, r3
    521e:	4b08      	ldr	r3, [pc, #32]	; (5240 <_adc_sync_init+0x4c>)
    5220:	4798      	blx	r3
    5222:	4603      	mov	r3, r0
    5224:	4619      	mov	r1, r3
    5226:	6838      	ldr	r0, [r7, #0]
    5228:	4b06      	ldr	r3, [pc, #24]	; (5244 <_adc_sync_init+0x50>)
    522a:	4798      	blx	r3
    522c:	4603      	mov	r3, r0
}
    522e:	4618      	mov	r0, r3
    5230:	3708      	adds	r7, #8
    5232:	46bd      	mov	sp, r7
    5234:	bd80      	pop	{r7, pc}
    5236:	bf00      	nop
    5238:	00005698 	.word	0x00005698
    523c:	00001c39 	.word	0x00001c39
    5240:	00004f29 	.word	0x00004f29
    5244:	00004f8d 	.word	0x00004f8d

00005248 <__libc_init_array>:
    5248:	b570      	push	{r4, r5, r6, lr}
    524a:	4e0d      	ldr	r6, [pc, #52]	; (5280 <__libc_init_array+0x38>)
    524c:	4d0d      	ldr	r5, [pc, #52]	; (5284 <__libc_init_array+0x3c>)
    524e:	1b76      	subs	r6, r6, r5
    5250:	10b6      	asrs	r6, r6, #2
    5252:	d006      	beq.n	5262 <__libc_init_array+0x1a>
    5254:	2400      	movs	r4, #0
    5256:	f855 3b04 	ldr.w	r3, [r5], #4
    525a:	3401      	adds	r4, #1
    525c:	4798      	blx	r3
    525e:	42a6      	cmp	r6, r4
    5260:	d1f9      	bne.n	5256 <__libc_init_array+0xe>
    5262:	4e09      	ldr	r6, [pc, #36]	; (5288 <__libc_init_array+0x40>)
    5264:	4d09      	ldr	r5, [pc, #36]	; (528c <__libc_init_array+0x44>)
    5266:	1b76      	subs	r6, r6, r5
    5268:	f000 fa22 	bl	56b0 <_init>
    526c:	10b6      	asrs	r6, r6, #2
    526e:	d006      	beq.n	527e <__libc_init_array+0x36>
    5270:	2400      	movs	r4, #0
    5272:	f855 3b04 	ldr.w	r3, [r5], #4
    5276:	3401      	adds	r4, #1
    5278:	4798      	blx	r3
    527a:	42a6      	cmp	r6, r4
    527c:	d1f9      	bne.n	5272 <__libc_init_array+0x2a>
    527e:	bd70      	pop	{r4, r5, r6, pc}
    5280:	000056bc 	.word	0x000056bc
    5284:	000056bc 	.word	0x000056bc
    5288:	000056c0 	.word	0x000056c0
    528c:	000056bc 	.word	0x000056bc

00005290 <memcpy>:
    5290:	4684      	mov	ip, r0
    5292:	ea41 0300 	orr.w	r3, r1, r0
    5296:	f013 0303 	ands.w	r3, r3, #3
    529a:	d16d      	bne.n	5378 <memcpy+0xe8>
    529c:	3a40      	subs	r2, #64	; 0x40
    529e:	d341      	bcc.n	5324 <memcpy+0x94>
    52a0:	f851 3b04 	ldr.w	r3, [r1], #4
    52a4:	f840 3b04 	str.w	r3, [r0], #4
    52a8:	f851 3b04 	ldr.w	r3, [r1], #4
    52ac:	f840 3b04 	str.w	r3, [r0], #4
    52b0:	f851 3b04 	ldr.w	r3, [r1], #4
    52b4:	f840 3b04 	str.w	r3, [r0], #4
    52b8:	f851 3b04 	ldr.w	r3, [r1], #4
    52bc:	f840 3b04 	str.w	r3, [r0], #4
    52c0:	f851 3b04 	ldr.w	r3, [r1], #4
    52c4:	f840 3b04 	str.w	r3, [r0], #4
    52c8:	f851 3b04 	ldr.w	r3, [r1], #4
    52cc:	f840 3b04 	str.w	r3, [r0], #4
    52d0:	f851 3b04 	ldr.w	r3, [r1], #4
    52d4:	f840 3b04 	str.w	r3, [r0], #4
    52d8:	f851 3b04 	ldr.w	r3, [r1], #4
    52dc:	f840 3b04 	str.w	r3, [r0], #4
    52e0:	f851 3b04 	ldr.w	r3, [r1], #4
    52e4:	f840 3b04 	str.w	r3, [r0], #4
    52e8:	f851 3b04 	ldr.w	r3, [r1], #4
    52ec:	f840 3b04 	str.w	r3, [r0], #4
    52f0:	f851 3b04 	ldr.w	r3, [r1], #4
    52f4:	f840 3b04 	str.w	r3, [r0], #4
    52f8:	f851 3b04 	ldr.w	r3, [r1], #4
    52fc:	f840 3b04 	str.w	r3, [r0], #4
    5300:	f851 3b04 	ldr.w	r3, [r1], #4
    5304:	f840 3b04 	str.w	r3, [r0], #4
    5308:	f851 3b04 	ldr.w	r3, [r1], #4
    530c:	f840 3b04 	str.w	r3, [r0], #4
    5310:	f851 3b04 	ldr.w	r3, [r1], #4
    5314:	f840 3b04 	str.w	r3, [r0], #4
    5318:	f851 3b04 	ldr.w	r3, [r1], #4
    531c:	f840 3b04 	str.w	r3, [r0], #4
    5320:	3a40      	subs	r2, #64	; 0x40
    5322:	d2bd      	bcs.n	52a0 <memcpy+0x10>
    5324:	3230      	adds	r2, #48	; 0x30
    5326:	d311      	bcc.n	534c <memcpy+0xbc>
    5328:	f851 3b04 	ldr.w	r3, [r1], #4
    532c:	f840 3b04 	str.w	r3, [r0], #4
    5330:	f851 3b04 	ldr.w	r3, [r1], #4
    5334:	f840 3b04 	str.w	r3, [r0], #4
    5338:	f851 3b04 	ldr.w	r3, [r1], #4
    533c:	f840 3b04 	str.w	r3, [r0], #4
    5340:	f851 3b04 	ldr.w	r3, [r1], #4
    5344:	f840 3b04 	str.w	r3, [r0], #4
    5348:	3a10      	subs	r2, #16
    534a:	d2ed      	bcs.n	5328 <memcpy+0x98>
    534c:	320c      	adds	r2, #12
    534e:	d305      	bcc.n	535c <memcpy+0xcc>
    5350:	f851 3b04 	ldr.w	r3, [r1], #4
    5354:	f840 3b04 	str.w	r3, [r0], #4
    5358:	3a04      	subs	r2, #4
    535a:	d2f9      	bcs.n	5350 <memcpy+0xc0>
    535c:	3204      	adds	r2, #4
    535e:	d008      	beq.n	5372 <memcpy+0xe2>
    5360:	07d2      	lsls	r2, r2, #31
    5362:	bf1c      	itt	ne
    5364:	f811 3b01 	ldrbne.w	r3, [r1], #1
    5368:	f800 3b01 	strbne.w	r3, [r0], #1
    536c:	d301      	bcc.n	5372 <memcpy+0xe2>
    536e:	880b      	ldrh	r3, [r1, #0]
    5370:	8003      	strh	r3, [r0, #0]
    5372:	4660      	mov	r0, ip
    5374:	4770      	bx	lr
    5376:	bf00      	nop
    5378:	2a08      	cmp	r2, #8
    537a:	d313      	bcc.n	53a4 <memcpy+0x114>
    537c:	078b      	lsls	r3, r1, #30
    537e:	d08d      	beq.n	529c <memcpy+0xc>
    5380:	f010 0303 	ands.w	r3, r0, #3
    5384:	d08a      	beq.n	529c <memcpy+0xc>
    5386:	f1c3 0304 	rsb	r3, r3, #4
    538a:	1ad2      	subs	r2, r2, r3
    538c:	07db      	lsls	r3, r3, #31
    538e:	bf1c      	itt	ne
    5390:	f811 3b01 	ldrbne.w	r3, [r1], #1
    5394:	f800 3b01 	strbne.w	r3, [r0], #1
    5398:	d380      	bcc.n	529c <memcpy+0xc>
    539a:	f831 3b02 	ldrh.w	r3, [r1], #2
    539e:	f820 3b02 	strh.w	r3, [r0], #2
    53a2:	e77b      	b.n	529c <memcpy+0xc>
    53a4:	3a04      	subs	r2, #4
    53a6:	d3d9      	bcc.n	535c <memcpy+0xcc>
    53a8:	3a01      	subs	r2, #1
    53aa:	f811 3b01 	ldrb.w	r3, [r1], #1
    53ae:	f800 3b01 	strb.w	r3, [r0], #1
    53b2:	d2f9      	bcs.n	53a8 <memcpy+0x118>
    53b4:	780b      	ldrb	r3, [r1, #0]
    53b6:	7003      	strb	r3, [r0, #0]
    53b8:	784b      	ldrb	r3, [r1, #1]
    53ba:	7043      	strb	r3, [r0, #1]
    53bc:	788b      	ldrb	r3, [r1, #2]
    53be:	7083      	strb	r3, [r0, #2]
    53c0:	4660      	mov	r0, ip
    53c2:	4770      	bx	lr

000053c4 <memset>:
    53c4:	0783      	lsls	r3, r0, #30
    53c6:	b530      	push	{r4, r5, lr}
    53c8:	d048      	beq.n	545c <memset+0x98>
    53ca:	1e54      	subs	r4, r2, #1
    53cc:	2a00      	cmp	r2, #0
    53ce:	d03f      	beq.n	5450 <memset+0x8c>
    53d0:	b2ca      	uxtb	r2, r1
    53d2:	4603      	mov	r3, r0
    53d4:	e001      	b.n	53da <memset+0x16>
    53d6:	3c01      	subs	r4, #1
    53d8:	d33a      	bcc.n	5450 <memset+0x8c>
    53da:	f803 2b01 	strb.w	r2, [r3], #1
    53de:	079d      	lsls	r5, r3, #30
    53e0:	d1f9      	bne.n	53d6 <memset+0x12>
    53e2:	2c03      	cmp	r4, #3
    53e4:	d92d      	bls.n	5442 <memset+0x7e>
    53e6:	b2cd      	uxtb	r5, r1
    53e8:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    53ec:	2c0f      	cmp	r4, #15
    53ee:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    53f2:	d936      	bls.n	5462 <memset+0x9e>
    53f4:	f1a4 0210 	sub.w	r2, r4, #16
    53f8:	f022 0c0f 	bic.w	ip, r2, #15
    53fc:	f103 0e20 	add.w	lr, r3, #32
    5400:	44e6      	add	lr, ip
    5402:	ea4f 1c12 	mov.w	ip, r2, lsr #4
    5406:	f103 0210 	add.w	r2, r3, #16
    540a:	e942 5504 	strd	r5, r5, [r2, #-16]
    540e:	e942 5502 	strd	r5, r5, [r2, #-8]
    5412:	3210      	adds	r2, #16
    5414:	4572      	cmp	r2, lr
    5416:	d1f8      	bne.n	540a <memset+0x46>
    5418:	f10c 0201 	add.w	r2, ip, #1
    541c:	f014 0f0c 	tst.w	r4, #12
    5420:	eb03 1202 	add.w	r2, r3, r2, lsl #4
    5424:	f004 0c0f 	and.w	ip, r4, #15
    5428:	d013      	beq.n	5452 <memset+0x8e>
    542a:	f1ac 0304 	sub.w	r3, ip, #4
    542e:	f023 0303 	bic.w	r3, r3, #3
    5432:	3304      	adds	r3, #4
    5434:	4413      	add	r3, r2
    5436:	f842 5b04 	str.w	r5, [r2], #4
    543a:	4293      	cmp	r3, r2
    543c:	d1fb      	bne.n	5436 <memset+0x72>
    543e:	f00c 0403 	and.w	r4, ip, #3
    5442:	b12c      	cbz	r4, 5450 <memset+0x8c>
    5444:	b2ca      	uxtb	r2, r1
    5446:	441c      	add	r4, r3
    5448:	f803 2b01 	strb.w	r2, [r3], #1
    544c:	429c      	cmp	r4, r3
    544e:	d1fb      	bne.n	5448 <memset+0x84>
    5450:	bd30      	pop	{r4, r5, pc}
    5452:	4664      	mov	r4, ip
    5454:	4613      	mov	r3, r2
    5456:	2c00      	cmp	r4, #0
    5458:	d1f4      	bne.n	5444 <memset+0x80>
    545a:	e7f9      	b.n	5450 <memset+0x8c>
    545c:	4603      	mov	r3, r0
    545e:	4614      	mov	r4, r2
    5460:	e7bf      	b.n	53e2 <memset+0x1e>
    5462:	461a      	mov	r2, r3
    5464:	46a4      	mov	ip, r4
    5466:	e7e0      	b.n	542a <memset+0x66>
    5468:	454d5441 	.word	0x454d5441
    546c:	6e49204c 	.word	0x6e49204c
    5470:	61697469 	.word	0x61697469
    5474:	617a696c 	.word	0x617a696c
    5478:	6e6f6974 	.word	0x6e6f6974
    547c:	6d6f4320 	.word	0x6d6f4320
    5480:	74656c70 	.word	0x74656c70
    5484:	000a2165 	.word	0x000a2165
    5488:	6b726f57 	.word	0x6b726f57
    548c:	6d6f6320 	.word	0x6d6f6320
    5490:	74656c70 	.word	0x74656c70
    5494:	2d206465 	.word	0x2d206465
    5498:	6f4c202d 	.word	0x6f4c202d
    549c:	6e69706f 	.word	0x6e69706f
    54a0:	6f662067 	.word	0x6f662067
    54a4:	65766572 	.word	0x65766572
    54a8:	00000a72 	.word	0x00000a72

000054ac <_aTerminalId>:
    54ac:	33323130 37363534 42413938 46454443     0123456789ABCDEF
    54bc:	6d726554 6c616e69 00000000              Terminal....

000054c8 <_aInitStr.0>:
    54c8:	00000000 54540000 45522052 53454747     ......TTR REGGES
    54d8:	00000000                                ....

000054dc <_aV2C.0>:
    54dc:	33323130 37363534 42413938 46454443     0123456789ABCDEF
    54ec:	31334d52 6e203030 6420746f 63657465     RM3100 not detec
    54fc:	20646574 72726f63 6c746365 45202179     ted correctly! E
    550c:	726f7272 77206465 20687469 65646f63     rrored with code
    551c:	6c25203a 00000a64 65207449 726f7272     : %ld...It error
    552c:	000a6465 6f727245 6e692072 334d5220     ed..Error in RM3
    553c:	20303031 74697257 00000065 682f2e2e     100 Write...../h
    554c:	732f6c61 682f6372 695f6c61 00632e6f     al/src/hal_io.c.
    555c:	682f2e2e 772f6c70 682f7464 775f6c70     ../hpl/wdt/hpl_w
    556c:	632e7464 00000000 682f2e2e 732f6c61     dt.c....../hal/s
    557c:	682f6372 735f6c61 6d5f6970 6e79735f     rc/hal_spi_m_syn
    558c:	00632e63 682f2e2e 732f6c61 682f6372     c.c.../hal/src/h
    559c:	695f6c61 6d5f6332 6e79735f 00632e63     al_i2c_m_sync.c.
    55ac:	682f2e2e 732f6c61 682f6372 755f6c61     ../hal/src/hal_u
    55bc:	74726173 6e79735f 00632e63 682f2e2e     sart_sync.c.../h
    55cc:	702f6c70 2f74726f 5f6c7068 6f697067     pl/port/hpl_gpio
    55dc:	7361625f 00682e65 682f2e2e 692f6c61     _base.h.../hal/i
    55ec:	756c636e 682f6564 775f6c61 682e7464     nclude/hal_wdt.h
    55fc:	00000000 682f2e2e 732f6c61 682f6372     ....../hal/src/h
    560c:	615f6c61 735f6364 2e636e79 00000063     al_adc_sync.c...
    561c:	682f2e2e 732f6c70 6f637265 70682f6d     ../hpl/sercom/hp
    562c:	65735f6c 6d6f6372 0000632e 40003000     l_sercom.c...0.@
    563c:	40003400 41012000 41014000 43000000     .4.@. .A.@.A...C
    564c:	43000400 43000800 43000c00              ...C...C...C

00005658 <sercomspi_regs>:
    5658:	0030000c 00020000 00000000 01ff0000     ..0.............
    5668:	00000002                                ....

0000566c <_adcs>:
	...
    5680:	00010000 00000000 00000000 00000000     ................
	...
    5698:	682f2e2e 612f6c70 682f6364 615f6c70     ../hpl/adc/hpl_a
    56a8:	632e6364 00000000                       dc.c....

000056b0 <_init>:
    56b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    56b2:	bf00      	nop
    56b4:	bcf8      	pop	{r3, r4, r5, r6, r7}
    56b6:	bc08      	pop	{r3}
    56b8:	469e      	mov	lr, r3
    56ba:	4770      	bx	lr

000056bc <__frame_dummy_init_array_entry>:
    56bc:	02cd 0000                                   ....

000056c0 <_fini>:
    56c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    56c2:	bf00      	nop
    56c4:	bcf8      	pop	{r3, r4, r5, r6, r7}
    56c6:	bc08      	pop	{r3}
    56c8:	469e      	mov	lr, r3
    56ca:	4770      	bx	lr

000056cc <__do_global_dtors_aux_fini_array_entry>:
    56cc:	02a5 0000                                   ....
