
PVDXos_bootloader.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000488  00006000  00006000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000004  2003d000  00006488  00002000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bkupram      00000000  47000000  47000000  00002004  2**0
                  CONTENTS
  3 .qspi         00000000  04000000  04000000  00002004  2**0
                  CONTENTS
  4 .bss          0000002c  2003d004  0000648c  00002004  2**2
                  ALLOC
  5 .stack        00001000  2003d030  000064b8  00002004  2**0
                  ALLOC
  6 .ARM.attributes 0000002e  00000000  00000000  00002004  2**0
                  CONTENTS, READONLY
  7 .comment      00000046  00000000  00000000  00002032  2**0
                  CONTENTS, READONLY
  8 .debug_info   000018d0  00000000  00000000  00002078  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_abbrev 000005ef  00000000  00000000  00003948  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_loclists 000001cb  00000000  00000000  00003f37  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_aranges 00000080  00000000  00000000  00004102  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_rnglists 00000069  00000000  00000000  00004182  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_macro  00025766  00000000  00000000  000041eb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line   00001f63  00000000  00000000  00029951  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_str    000ed23a  00000000  00000000  0002b8b4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_frame  000000ec  00000000  00000000  00118af0  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00006000 <exception_table>:
    6000:	30 e0 03 20 a9 63 00 00 a5 63 00 00 a5 63 00 00     0.. .c...c...c..
    6010:	a5 63 00 00 a5 63 00 00 a5 63 00 00 00 00 00 00     .c...c...c......
	...
    602c:	a5 63 00 00 a5 63 00 00 00 00 00 00 a5 63 00 00     .c...c.......c..
    603c:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    604c:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    605c:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    606c:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    607c:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    608c:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    609c:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    60ac:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    60bc:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    60cc:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    60dc:	a5 63 00 00 a5 63 00 00 a5 63 00 00 00 00 00 00     .c...c...c......
	...
    60f4:	6d 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     mc...c...c...c..
    6104:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    6114:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    6124:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    6134:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    6144:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    6154:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    6164:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    6174:	a5 63 00 00 00 00 00 00 00 00 00 00 a5 63 00 00     .c...........c..
    6184:	a5 63 00 00 a5 63 00 00 a5 63 00 00 00 00 00 00     .c...c...c......
    6194:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    61a4:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    61b4:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    61c4:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    61d4:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    61e4:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    61f4:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    6204:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    6214:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    6224:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    6234:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    6244:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..
    6254:	a5 63 00 00 a5 63 00 00 a5 63 00 00 a5 63 00 00     .c...c...c...c..

00006264 <deregister_tm_clones>:
    6264:	4803      	ldr	r0, [pc, #12]	@ (6274 <deregister_tm_clones+0x10>)
    6266:	4b04      	ldr	r3, [pc, #16]	@ (6278 <deregister_tm_clones+0x14>)
    6268:	4283      	cmp	r3, r0
    626a:	d002      	beq.n	6272 <deregister_tm_clones+0xe>
    626c:	4b03      	ldr	r3, [pc, #12]	@ (627c <deregister_tm_clones+0x18>)
    626e:	b103      	cbz	r3, 6272 <deregister_tm_clones+0xe>
    6270:	4718      	bx	r3
    6272:	4770      	bx	lr
    6274:	00006488 	.word	0x00006488
    6278:	00006488 	.word	0x00006488
    627c:	00000000 	.word	0x00000000

00006280 <register_tm_clones>:
    6280:	4805      	ldr	r0, [pc, #20]	@ (6298 <register_tm_clones+0x18>)
    6282:	4b06      	ldr	r3, [pc, #24]	@ (629c <register_tm_clones+0x1c>)
    6284:	1a1b      	subs	r3, r3, r0
    6286:	0fd9      	lsrs	r1, r3, #31
    6288:	eb01 01a3 	add.w	r1, r1, r3, asr #2
    628c:	1049      	asrs	r1, r1, #1
    628e:	d002      	beq.n	6296 <register_tm_clones+0x16>
    6290:	4b03      	ldr	r3, [pc, #12]	@ (62a0 <register_tm_clones+0x20>)
    6292:	b103      	cbz	r3, 6296 <register_tm_clones+0x16>
    6294:	4718      	bx	r3
    6296:	4770      	bx	lr
    6298:	00006488 	.word	0x00006488
    629c:	00006488 	.word	0x00006488
    62a0:	00000000 	.word	0x00000000

000062a4 <__do_global_dtors_aux>:
    62a4:	b510      	push	{r4, lr}
    62a6:	4c06      	ldr	r4, [pc, #24]	@ (62c0 <__do_global_dtors_aux+0x1c>)
    62a8:	7823      	ldrb	r3, [r4, #0]
    62aa:	b943      	cbnz	r3, 62be <__do_global_dtors_aux+0x1a>
    62ac:	f7ff ffda 	bl	6264 <deregister_tm_clones>
    62b0:	4b04      	ldr	r3, [pc, #16]	@ (62c4 <__do_global_dtors_aux+0x20>)
    62b2:	b113      	cbz	r3, 62ba <__do_global_dtors_aux+0x16>
    62b4:	4804      	ldr	r0, [pc, #16]	@ (62c8 <__do_global_dtors_aux+0x24>)
    62b6:	f3af 8000 	nop.w
    62ba:	2301      	movs	r3, #1
    62bc:	7023      	strb	r3, [r4, #0]
    62be:	bd10      	pop	{r4, pc}
    62c0:	2003d004 	.word	0x2003d004
    62c4:	00000000 	.word	0x00000000
    62c8:	00006488 	.word	0x00006488

000062cc <frame_dummy>:
    62cc:	b508      	push	{r3, lr}
    62ce:	4b05      	ldr	r3, [pc, #20]	@ (62e4 <frame_dummy+0x18>)
    62d0:	b11b      	cbz	r3, 62da <frame_dummy+0xe>
    62d2:	4905      	ldr	r1, [pc, #20]	@ (62e8 <frame_dummy+0x1c>)
    62d4:	4805      	ldr	r0, [pc, #20]	@ (62ec <frame_dummy+0x20>)
    62d6:	f3af 8000 	nop.w
    62da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    62de:	f7ff bfcf 	b.w	6280 <register_tm_clones>
    62e2:	bf00      	nop
    62e4:	00000000 	.word	0x00000000
    62e8:	2003d008 	.word	0x2003d008
    62ec:	00006488 	.word	0x00006488

000062f0 <go_to_app>:
}

void go_to_app(void) {
    // Read app's vector table (first value is SP, second value is PC)
    long *vector_table = (long *)APP_RAM_START;
    long desired_sp = vector_table[0];
    62f0:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
    long desired_pc = vector_table[1];
    62f4:	e9d2 1300 	ldrd	r1, r3, [r2]

    // Set the least significant bit of the PC to indicate that the reset vector is in Thumb mode
    desired_pc |= 0x1;

    // Tell the SAMD51 where the app's vector table is
    *((long *)SCB_VTOR) = (long)vector_table;
    62f8:	f04f 20e0 	mov.w	r0, #3758153728	@ 0xe000e000
    desired_pc |= 0x1;
    62fc:	f043 0301 	orr.w	r3, r3, #1
    *((long *)SCB_VTOR) = (long)vector_table;
    6300:	f8c0 2d08 	str.w	r2, [r0, #3336]	@ 0xd08

    // Set SP to desired_sp and then jump to PC using assembly
    __asm__ volatile(
    6304:	468d      	mov	sp, r1
    6306:	4718      	bx	r3
        "mov sp, %0\n" // Move the value in desired_sp into SP
        "bx %1"        // Branch to the address contained in desired_pc
        :
        : "r"(desired_sp), "r"(desired_pc) // Arguments to the assembly (accessed as %0 and %1 in the assembly code)
        :);
    6308:	4770      	bx	lr
	...

0000630c <main>:
int main(void) {
    630c:	b538      	push	{r3, r4, r5, lr}
    while (startup_test_value != 8);
    630e:	4a15      	ldr	r2, [pc, #84]	@ (6364 <main+0x58>)
    6310:	6813      	ldr	r3, [r2, #0]
    6312:	2b08      	cmp	r3, #8
    6314:	d1fc      	bne.n	6310 <main+0x4>
    6316:	f44f 42c0 	mov.w	r2, #24576	@ 0x6000
    uint32_t checksum = 0;
    631a:	2300      	movs	r3, #0
        checksum += cur_bootloader_start[i];
    631c:	f812 1b01 	ldrb.w	r1, [r2], #1
    for (uint32_t i = 0; i < BOOTLOADER_SIZE; i++) {
    6320:	f5b2 4f10 	cmp.w	r2, #36864	@ 0x9000
        checksum += cur_bootloader_start[i];
    6324:	440b      	add	r3, r1
    for (uint32_t i = 0; i < BOOTLOADER_SIZE; i++) {
    6326:	d1f9      	bne.n	631c <main+0x10>
    checksum %= 256;
    6328:	b2db      	uxtb	r3, r3
    if (checksum != 0) {
    632a:	b103      	cbz	r3, 632e <main+0x22>
        while (bootloader_index == 2);
    632c:	e7fe      	b.n	632c <main+0x20>
    632e:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
        app_dst[i] = (app_flash_src[i] & app_flash_src[i+APP_FLASH_STEP]) |
    6332:	f5a3 3200 	sub.w	r2, r3, #131072	@ 0x20000
    6336:	f103 50ff 	add.w	r0, r3, #534773760	@ 0x1fe00000
    633a:	f992 1000 	ldrsb.w	r1, [r2]
            (app_flash_src[i+APP_FLASH_STEP] & app_flash_src[i+2*APP_FLASH_STEP]) |
    633e:	f503 3200 	add.w	r2, r3, #131072	@ 0x20000
        app_dst[i] = (app_flash_src[i] & app_flash_src[i+APP_FLASH_STEP]) |
    6342:	f500 10e0 	add.w	r0, r0, #1835008	@ 0x1c0000
            (app_flash_src[i+APP_FLASH_STEP] & app_flash_src[i+2*APP_FLASH_STEP]) |
    6346:	f992 4000 	ldrsb.w	r4, [r2]
        app_dst[i] = (app_flash_src[i] & app_flash_src[i+APP_FLASH_STEP]) |
    634a:	f813 2b01 	ldrb.w	r2, [r3], #1
    634e:	ea41 0504 	orr.w	r5, r1, r4
    6352:	402a      	ands	r2, r5
    6354:	4021      	ands	r1, r4
    6356:	430a      	orrs	r2, r1
    for (long i = 0; i < APP_SIZE; i++) {
    6358:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
        app_dst[i] = (app_flash_src[i] & app_flash_src[i+APP_FLASH_STEP]) |
    635c:	7002      	strb	r2, [r0, #0]
    for (long i = 0; i < APP_SIZE; i++) {
    635e:	d1e8      	bne.n	6332 <main+0x26>
    go_to_app();
    6360:	4b01      	ldr	r3, [pc, #4]	@ (6368 <main+0x5c>)
    6362:	4798      	blx	r3
    __builtin_unreachable();
    6364:	2003d000 	.word	0x2003d000
    6368:	000062f1 	.word	0x000062f1

0000636c <RAMECC_Handler>:
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
	return ((Ramecc *)hw)->INTFLAG.reg;
    636c:	4a0b      	ldr	r2, [pc, #44]	@ (639c <RAMECC_Handler+0x30>)
    636e:	7893      	ldrb	r3, [r2, #2]

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
    6370:	b082      	sub	sp, #8
    6372:	b2db      	uxtb	r3, r3
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
    6374:	9301      	str	r3, [sp, #4]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
    6376:	9b01      	ldr	r3, [sp, #4]
    6378:	0799      	lsls	r1, r3, #30
    637a:	d505      	bpl.n	6388 <RAMECC_Handler+0x1c>
    637c:	4b08      	ldr	r3, [pc, #32]	@ (63a0 <RAMECC_Handler+0x34>)
    637e:	681b      	ldr	r3, [r3, #0]
    6380:	b113      	cbz	r3, 6388 <RAMECC_Handler+0x1c>
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
	return ((Ramecc *)hw)->ERRADDR.reg;
    6382:	6850      	ldr	r0, [r2, #4]
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
	} else {
		return;
	}
}
    6384:	b002      	add	sp, #8
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    6386:	4718      	bx	r3
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
    6388:	9b01      	ldr	r3, [sp, #4]
    638a:	07db      	lsls	r3, r3, #31
    638c:	d504      	bpl.n	6398 <RAMECC_Handler+0x2c>
    638e:	4b04      	ldr	r3, [pc, #16]	@ (63a0 <RAMECC_Handler+0x34>)
    6390:	685b      	ldr	r3, [r3, #4]
    6392:	b10b      	cbz	r3, 6398 <RAMECC_Handler+0x2c>
    6394:	4a01      	ldr	r2, [pc, #4]	@ (639c <RAMECC_Handler+0x30>)
    6396:	e7f4      	b.n	6382 <RAMECC_Handler+0x16>
}
    6398:	b002      	add	sp, #8
    639a:	4770      	bx	lr
    639c:	41020000 	.word	0x41020000
    63a0:	2003d020 	.word	0x2003d020

000063a4 <Dummy_Handler>:
/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
	while (1) {
    63a4:	e7fe      	b.n	63a4 <Dummy_Handler>
	...

000063a8 <Reset_Handler>:
{
    63a8:	b508      	push	{r3, lr}
	if (pSrc != pDest) {
    63aa:	4a14      	ldr	r2, [pc, #80]	@ (63fc <Reset_Handler+0x54>)
    63ac:	4b14      	ldr	r3, [pc, #80]	@ (6400 <Reset_Handler+0x58>)
    63ae:	429a      	cmp	r2, r3
    63b0:	d002      	beq.n	63b8 <Reset_Handler+0x10>
		for (; pDest < &_erelocate;) {
    63b2:	4914      	ldr	r1, [pc, #80]	@ (6404 <Reset_Handler+0x5c>)
    63b4:	428b      	cmp	r3, r1
    63b6:	d318      	bcc.n	63ea <Reset_Handler+0x42>
	pSrc  = &_etext;
    63b8:	4b13      	ldr	r3, [pc, #76]	@ (6408 <Reset_Handler+0x60>)
	for (pDest = &_szero; pDest < &_ezero;) {
    63ba:	4a14      	ldr	r2, [pc, #80]	@ (640c <Reset_Handler+0x64>)
		*pDest++ = 0;
    63bc:	2100      	movs	r1, #0
	for (pDest = &_szero; pDest < &_ezero;) {
    63be:	4293      	cmp	r3, r2
    63c0:	d318      	bcc.n	63f4 <Reset_Handler+0x4c>
	SCB->VTOR = ((uint32_t)pSrc & SCB_VTOR_TBLOFF_Msk);
    63c2:	4a13      	ldr	r2, [pc, #76]	@ (6410 <Reset_Handler+0x68>)
    63c4:	4b13      	ldr	r3, [pc, #76]	@ (6414 <Reset_Handler+0x6c>)
    63c6:	f022 027f 	bic.w	r2, r2, #127	@ 0x7f
    63ca:	609a      	str	r2, [r3, #8]
	SCB->CPACR |= (0xFu << 20);
    63cc:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
    63d0:	f442 0270 	orr.w	r2, r2, #15728640	@ 0xf00000
    63d4:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    63d8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    63dc:	f3bf 8f6f 	isb	sy
	__libc_init_array();
    63e0:	4b0d      	ldr	r3, [pc, #52]	@ (6418 <Reset_Handler+0x70>)
    63e2:	4798      	blx	r3
	main();
    63e4:	4b0d      	ldr	r3, [pc, #52]	@ (641c <Reset_Handler+0x74>)
    63e6:	4798      	blx	r3
	while (1)
    63e8:	e7fe      	b.n	63e8 <Reset_Handler+0x40>
			*pDest++ = *pSrc++;
    63ea:	f852 0b04 	ldr.w	r0, [r2], #4
    63ee:	f843 0b04 	str.w	r0, [r3], #4
    63f2:	e7df      	b.n	63b4 <Reset_Handler+0xc>
		*pDest++ = 0;
    63f4:	f843 1b04 	str.w	r1, [r3], #4
    63f8:	e7e1      	b.n	63be <Reset_Handler+0x16>
    63fa:	bf00      	nop
    63fc:	00006488 	.word	0x00006488
    6400:	2003d000 	.word	0x2003d000
    6404:	2003d004 	.word	0x2003d004
    6408:	2003d004 	.word	0x2003d004
    640c:	2003d030 	.word	0x2003d030
    6410:	00006000 	.word	0x00006000
    6414:	e000ed00 	.word	0xe000ed00
    6418:	00006421 	.word	0x00006421
    641c:	0000630d 	.word	0x0000630d

00006420 <__libc_init_array>:
    6420:	b570      	push	{r4, r5, r6, lr}
    6422:	4b0d      	ldr	r3, [pc, #52]	@ (6458 <__libc_init_array+0x38>)
    6424:	4d0d      	ldr	r5, [pc, #52]	@ (645c <__libc_init_array+0x3c>)
    6426:	1b5b      	subs	r3, r3, r5
    6428:	109c      	asrs	r4, r3, #2
    642a:	2600      	movs	r6, #0
    642c:	42a6      	cmp	r6, r4
    642e:	d109      	bne.n	6444 <__libc_init_array+0x24>
    6430:	f000 f81a 	bl	6468 <_init>
    6434:	4d0a      	ldr	r5, [pc, #40]	@ (6460 <__libc_init_array+0x40>)
    6436:	4b0b      	ldr	r3, [pc, #44]	@ (6464 <__libc_init_array+0x44>)
    6438:	1b5b      	subs	r3, r3, r5
    643a:	109c      	asrs	r4, r3, #2
    643c:	2600      	movs	r6, #0
    643e:	42a6      	cmp	r6, r4
    6440:	d105      	bne.n	644e <__libc_init_array+0x2e>
    6442:	bd70      	pop	{r4, r5, r6, pc}
    6444:	f855 3b04 	ldr.w	r3, [r5], #4
    6448:	4798      	blx	r3
    644a:	3601      	adds	r6, #1
    644c:	e7ee      	b.n	642c <__libc_init_array+0xc>
    644e:	f855 3b04 	ldr.w	r3, [r5], #4
    6452:	4798      	blx	r3
    6454:	3601      	adds	r6, #1
    6456:	e7f2      	b.n	643e <__libc_init_array+0x1e>
    6458:	00006474 	.word	0x00006474
    645c:	00006474 	.word	0x00006474
    6460:	00006474 	.word	0x00006474
    6464:	00006478 	.word	0x00006478

00006468 <_init>:
    6468:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    646a:	bf00      	nop
    646c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    646e:	bc08      	pop	{r3}
    6470:	469e      	mov	lr, r3
    6472:	4770      	bx	lr

00006474 <__frame_dummy_init_array_entry>:
    6474:	62cd 0000                                   .b..

00006478 <_fini>:
    6478:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    647a:	bf00      	nop
    647c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    647e:	bc08      	pop	{r3}
    6480:	469e      	mov	lr, r3
    6482:	4770      	bx	lr

00006484 <__do_global_dtors_aux_fini_array_entry>:
    6484:	62a5 0000                                   .b..
